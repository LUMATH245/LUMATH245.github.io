---
editor_options: 
  markdown: 
    wrap: 72
---

# Functions and Loops {#func_loop}

## Functions

Functions in mathematics, is an assignment of an element from a set to a
different set. Here we give a more "practical" definition.

In the realm of programming, a function is a reusable piece of code that
performs a specific task. Think of it as a mini-program within your
program, a tool you create to do a job so you don't have to. And as a
program does, you give it an input, it will do some voudou magic, and it
will spit an output.

![](images/chapter3/dark_magic.png)

What's the point of a function you might ask? Well, in programming, we
use functions when we have tasks that must be performed again and again.
When we notice a repetitive task occurring, it is a good idea to write a
function that performs this task. If you find yourself copying and
pasting the same piece of code more than three times, it's time to stop
and think: "Should I write a function for this?" Remember, in the world
of coding, being lazy is often a good thing! We aim for efficiency, not
repetitive strain injury.

![](images/chapter3/homer.jpg){width="366"}

Imagine if every time you need to compute the square root, you need to
write the code to compute the square root over and over again. In fact,
it won't come as a surprise that we've already encountered many
functions in the past weeks. For instance:

-   Mathematical functions like `sqrt()` or `sin()` in R, and
    `math.sqrt()` or `math.sin()` in Python.
-   Functions like `np.array()` or `c()` to create vectors.
-   Functions like `length()` in R or `len()` in Python to get
    information about our data structures.

Again, each function I mentioned, has an input, and an output: `sqrt`
takes a number as input and returns the square root of such number,
`length` or `len` take a whole vector as input, and return the length of
it...

Another incredibly useful function is the `help()` function, available
in both R and Python. This function takes a **function** as an input,
and provides us with information said function as ouput! For example:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r eval=FALSE}
help(sqrt)
```

</div>

<div>

**python**

```{python eval=FALSE}
help(math.sqrt)
```

</div>
:::

But the real power of functions comes when we start creating our own. We
can write new functions that perform specific tasks, tailored to our
needs. This allows us to do more complex, interesting, and fun things
with our code. So let's dive in and learn how to create our own
functions!

### Writing new functions

We can wrap our code in a function, and every time the function is called, this code is run. This is incredibly useful for tasks we need to perform multiple times. Letâ€™s look at an example of a simple function that converts cups to grams.

In **R**, we define a function using the `function()` command. The arguments of the function are placed within the parentheses. Here's how we can create a function in R:

```{r}
cups_to_grams <- function(cups) {
  grams <- cups * 201.6
  return(grams)
}
```

In this function, `cups` is the input (or argument), and the function returns the equivalent weight in grams. In R, we create a new function with the `function` statement, and then we assign it to a variable, which is going to be containing our function. The `return()` statement is used to specify the result that the function should output.

In **Python**, we define a function using the `def` keyword. The arguments of the function are placed within the parentheses. Again we need to use indentation: this is crucial in Python as it determines the code blocks. Here's how we can create a function in Python:

```{python}
def cups_to_grams(cups):
  grams = cups * 201.6
  return grams
```

In this function, `cups` is the input (or argument), and the function returns the equivalent weight in grams: following the `def` keyword we need both the function name, followed by the argument. The `return` statement is used to specify the result that the function should output.

Now, once we have made the new function, we can call it by:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
cups_to_grams(2)
cups_to_grams(3)
```

</div>

<div>

**python**

```{python}
cups_to_grams(2)
cups_to_grams(3)
```

</div>
:::

By creating functions like these, we can make our code more efficient and easier to read. Plus, it saves us from having to remember the conversion rate each time we want to convert cups to grams!

You noticed we made a variable within the function: `grams`. Before we proceed, we need to introduce the concept of *environments*.

#### Enviroments 
In programming, an environment refers to a structure that holds variables. When you create a variable in a program, the environment is where this variable lives. The environment keeps track of the variable's name and its current value.

There are two types of environments: global and local.

- The **global environment** is the default environment where your variables live unless you specify otherwise. When you create a variable at the top level of your script, it's stored in the global environment.

- A **local environment** is created when you call a function. Each time a function is called, a new local environment is created for that function call. This environment holds the variables that are created within the function. These variables are only accessible within the function call and cease to exist once the function call is over.

Let's consider the `cups_to_grams` function we made:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r error=TRUE}
cups_to_grams <- function(cups) {
  grams <- cups * 201.6
  return(grams)
}

# Create a variable in the global environment
my_cups <- 2

# Try to access the local variable "grams"
print(grams)
```

</div>

<div>

**python**

```{python error=TRUE}
def cups_to_grams(cups):
  grams = cups * 201.6
  return grams

# Create a variable in the global environment
my_cups = 2

# Try to access the local variable "grams"
print(grams)
```

</div>
:::

In these functions, `cups` and `grams` are variables in the local environment of the function. They are created when the function is called and cease to exist when the function call is over. If you try to access `grams` outside of the function, you'll get an error because `grams` is not in the global environment.

On the other hand, `my_cups` is in the global environment because it's created at the top level of the script, not within a function. You can access `my_cups` anywhere in your script.

This distinction between global and local environments helps keep our code clean and reduces the chance of errors. It ensures that the function does its job without interfering with the rest of our script! **Avoid for this reason to name the variables inside your functions as those outside it, in the rest of your script**

#### Multiple arguments

Say we want now to convert cups to milliliters. To convert from weight to volume, we will need an additional information, the specific weight. In physics, the specific weight (also known as the volumetric weight density) of a substance is the weight per unit volume. 

Fortunately for us, functions can take multiple arguments, allowing us to give more elements to the local environment of the function. This means we can customize the function's behavior based on these inputs. Let's see how we can add more arguments to a function.

We'll create a new function to convert cups to milliliters. This function will take a second argument: `specific_weight`. We'll use the function we created earlier to convert cups to grams, and then, using the `specific_weight`, we'll convert grams to liters. We'll set the default value of `specific_weight` to be the specific weight of water: the default value is the value that the argument will assume if we do not specify the argument.

Here's how we can do this in both R and Python:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
cups_to_ml <- function(cups, specific_weight = 1) {
  grams <- cups_to_grams(cups)
  ml <- grams / specific_weight
  return(ml)
}

# Specific weight of water and oil
water_weight = 1
oil_weight = 0.92

# Convert 2 cups of water and oil to ml
cups_to_ml(2, water_weight)
cups_to_ml(2, oil_weight)
```

</div>

<div>

**python**

```{python}
def cups_to_ml(cups, specific_weight=1):
  grams = cups_to_grams(cups)
  ml = grams / specific_weight
  return ml

# Specific weight of water and oil
water_weight = 1
oil_weight = 0.92

# Convert 2 cups of water and oil to ml
cups_to_ml(2, water_weight)
cups_to_ml(2, oil_weight)
```

</div>
:::

To run the functions we just made: 


::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Specific weight of water and oil
water_weight = 1
oil_weight = 0.92

# Convert 2 cups of water and oil to ml
cups_to_ml(2, specific_weight =  water_weight)
cups_to_ml(2) # equivalent, as the argument defaults to water
cups_to_ml(2, specific_weight =  oil_weight)
cups_to_ml(2, oil_weight) # equivalent, omitting the argument name
```

</div>

<div>

**python**

```{python}
# Specific weight of water and oil
water_weight = 1
oil_weight = 0.92

# Convert 2 cups of water and oil to ml
cups_to_ml(2, specific_weight =  water_weight)
cups_to_ml(2) # equivalent, as the argument defaults to water
cups_to_ml(2, specific_weight =  oil_weight)
cups_to_ml(2, oil_weight) # equivalent, omitting the argument name
```

</div>
:::


```{=html}
<style type="text/css">
.book .book-body .page-wrapper .page-inner {
  max-width: 1200px !important;
}
</style>
```

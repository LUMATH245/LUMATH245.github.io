---
editor_options: 
  markdown: 
    wrap: 72
---

# Functions and Loops {#func_loop}

## Functions

Functions in mathematics, is an assignment of an element from a set to a
different set. Here we give a more "practical" definition.

In the realm of programming, a function is a reusable piece of code that
performs a specific task. Think of it as a mini-program within your
program, a tool you create to do a job so you don't have to. And as a
program does, you give it an input, it will do some voudou magic, and it
will spit an output.

![](images/chapter3/dark_magic.png)

What's the point of a function you might ask? Well, in programming, we
use functions when we have tasks that must be performed again and again.
When we notice a repetitive task occurring, it is a good idea to write a
function that performs this task. If you find yourself copying and
pasting the same piece of code more than three times, it's time to stop
and think: "Should I write a function for this?" Remember, in the world
of coding, being lazy is often a good thing! We aim for efficiency, not
repetitive strain injury.

![](images/chapter3/homer.jpg){width="366"}

Imagine if every time you need to compute the square root, you need to
write the code to compute the square root over and over again. Well, but
in practice, you don't have to! There's *a function* that does the job
for you already: `sqrt` In fact, it won't come as a surprise that we've
already encountered many functions in the past weeks. For instance:

-   Mathematical functions like `sqrt()` or `sin()` in R, and
    `math.sqrt()` or `math.sin()` in Python.
-   Functions like `np.array()` or `c()` to create vectors.
-   Functions like `length()` in R or `len()` in Python to get
    information about our data structures.

Again, each function I mentioned, has an input, and an output: `sqrt`
takes a number as input and returns the square root of such number,
`length` or `len` take a whole vector as input, and return the length of
it...

Another incredibly useful function is the `help()` function, available
in both R and Python. This function takes a **function** as an input,
and provides us with information said function as output! For example:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r eval=FALSE}
help(sqrt)
```

</div>

<div>

**python**

```{python eval=FALSE}
help(math.sqrt)
```

</div>
:::

Whenever you will meet a **built-in** function, or a function from a
**documented external library** you can call the help on the function to
have an explanation about it! Documentation is a requirement in R
libraries, so pretty much all the functions you will meet are
documented! Unfortunately this is not the case for Python, where
documenting functions is not a requirement, so not always the `help`
will return something.

### Writing new functions

The real power of functions comes when we start creating our own. We can
write new functions that perform specific tasks, tailored to our needs.
This allows us to do more complex, interesting, and fun things with our
code. So let's dive in and learn how to create our own functions! We can
wrap our code in a function, and every time the function is called, this
code is run. This is incredibly useful for tasks we need to perform
multiple times. Let's build for example a simple function that converts
pounds (lbs) to grams (g).

Mathematically, this is simply done by the formula: $$
g = 453.5924 * lbs
$$

In **R**, we define a function using the `function()` command. The
arguments of the function are placed within the parentheses. Here's how
we can create a function in R:

```{r}
lbs_to_grams <- function(lbs) {
  grams <- 453.5924 * lbs
  return(grams)
}
```

In this function, `lbs` is the input (or argument), and the function
returns the equivalent weight in grams. In R, we create a new function
with the `function` statement, and then we assign it to a variable,
which is going to be containing our function. The `return()` statement
is used to specify the result that the function should output.

In **Python**, we define a function using the `def` keyword. The
arguments of the function are placed within the parentheses. Again we
need to use indentation: this is crucial in Python as it determines the
code blocks. Here's how we can create a function in Python:

```{python}
def lbs_to_grams(lbs):
  grams = 453.5924 * lbs
  return grams
```

In this function, `lbs` is the input (or argument), and the function
returns the equivalent weight in grams: following the `def` keyword we
need both the function name, followed by the argument. The `return`
statement is used to specify the result that the function should output.

Now, once we have made the new function, we can call it with:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
lbs_to_grams(lbs=2)
lbs_to_grams(lbs=3)

# when calling we can also omit 
# the argument name for brevity
lbs_to_grams(3)
```

</div>

<div>

**python**

```{python}
lbs_to_grams(lbs=2)
lbs_to_grams(lbs=3)

# when calling we can also omit 
# the argument name for brevity
lbs_to_grams(3)
```

</div>
:::

By creating functions like these, we can make our code more efficient
and easier to read. Plus, it saves us from having to remember the
conversion rate each time we want to convert pounds to grams!

The name of the function `lbs_to_grams` and its argument `lbs` are just
names that I chose. There are a few guidelines that could be useful when
naming functions: - Names should be lowercase. - Use an underscore, \_,
to separate words within a name. - Strive for names that are concise and
meaningful (this is not easy!). - Avoid existing function names in R and
python, such as `length()` or `len()`.

Also, you might have noticed we made a variable within the function
code, `grams`. But what does it mean to have variables within functions?
The variables used inside a function are local to that function. Think
of your function as a guarded sandbox, where no child leaves unless you
specifically tell them to. This sandbox is called and *enviroment*.
Let's cover this concept formally!

#### Enviroments

In programming, an environment refers to a structure that holds
variables. When you create a variable in a program, the environment is
where this variable lives. The environment keeps track of the variable's
name and its current value.

There are two types of environments: global and local.

-   The **global environment** is the default environment where your
    variables live unless you specify otherwise. When you create a
    variable at the top level of your script, it's stored in the global
    environment.

-   A **local environment** is created when you call a function. Each
    time a function is called, a new local environment is created for
    that function call. This environment holds the variables that are
    created within the function. These variables are only accessible
    within the function call and cease to exist once the function call
    is over.

Let's consider the `lbs_to_grams` function we made:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r error=TRUE}
lbs_to_grams <- function(lbs) {
  grams = 453.5924 * lbs
  return(grams)
}

# Create a variable in the global environment
glo_grams <- 2

# Try to access the local variable "grams"
print(grams)
# Try to access the global variable "glo_grams"
print(glo_grams)
```

</div>

<div>

**python**

```{python error=TRUE}
def lbs_to_grams(lbs):
  grams = 453.5924 * lbs
  return grams

# Create a variable in the global environment
glo_grams = 2

# Try to access the local variable "grams"
print(grams)
# Try to access the global variable "glo_grams"
print(glo_grams)
```

</div>
:::

In these functions, `lbs` and `grams` are variables in the local
environment of the function. They are created when the function is
called and cease to exist when the function call is over. If you try to
access `grams` outside of the function, you'll get an error because
`grams` is not in the global environment.

On the other hand, `glo_grams` is in the global environment because it's
created at the top level of the script, not within a function. You can
access `glo_grams` anywhere in your script **even within a function**.

This distinction between global and local variables helps keep our code
clean and reduces the chance of errors. It ensures that the function
does its job without interfering with the rest of our script! However,
it can be prone to errors too. Say for instance, I make a typo in the
argument name of my function above, and, for whatever reason I created a
lbs variable in the global... Like for instance:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r error=TRUE}
# I specified in the global lbs at some point 
lbs <- 3

# and here I made a typo!
#                            V
bug_lbs_to_grams <- function(lb) {
  grams = 453.5924 * lbs
  return(grams)
}

# Then, no matter what I call, I will always get the same result! 
# e.g.: 453.5924 * 3 
bug_lbs_to_grams(2)
bug_lbs_to_grams(10)
bug_lbs_to_grams(42)
```

</div>

<div>

**python**

```{python error=TRUE}
# I specified in the global lbs at some point 
lbs = 3

# and here I made a typo!
#                     V
def bug_lbs_to_grams(lb):
  grams = 453.5924 * lbs
  return grams

# Then, no matter what I call, I will always get the same result! 
# e.g.: 453.5924 * 3 
bug_lbs_to_grams(2)
bug_lbs_to_grams(10)
bug_lbs_to_grams(42)
```

</div>
:::

What happened above, is that I pass down as an input the `lb` argument
(without the s) *but this is nowhere used in the function* as inside the
code, at `grams = 453.5924 * lbs` I call the `lbs`. Now since the
compiler can't find any `lbs` within the local enviroment, it will just
assume that this is the `lbs` I specified in the global. Hence, no
matter what I feed to the function, it will return the evaluation with
the global `lbs`. **For this reason try not to name the variables inside
your functions as those outside it, in the rest of your script**. What
happens if I do name a local variable and global variable in the same
way? Well, in this case, the function will use the local `lbs` variable,
and the global will use the global `lbs` variable **but this is still
risky and prone to bugs**.

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r error=TRUE}
# global lbs
lbs <- 3

# but this does not affect the "lbs" of the function argument
lbs_to_grams(2)
lbs_to_grams(10)
lbs_to_grams(42)
```

</div>

<div>

**python**

```{python error=TRUE}
# global lbs 
lbs = 3

# but this does not affect the "lbs" of the function argument
lbs_to_grams(2)
lbs_to_grams(10)
lbs_to_grams(42)
```

</div>
:::

#### Multiple arguments

Say we want now to convert pounds to milliliters. To convert from mass
to volume, we will need an additional information, the specific mass. In
physics, the specific mass (also known as the volumetric mass density)
of a substance is the mass per unit volume.

Fortunately for us, functions can take multiple arguments, allowing us
to give more elements to the local environment of the function. This
means we can customize the function's behavior based on these inputs.
Let's see how we can add more arguments to a function.

We'll create a new function to convert pounds to milliliters. This
function will take a second argument: `specific_mass`. We'll use the
function **we created earlier** to convert pounds to grams, and then,
using the `specific_mass`, we'll convert grams to liters.

Here's how we can do this in both R and Python:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
lbs_to_ml <- function(lbs, specific_mass) {
  grams <- lbs_to_grams(lbs)
  ml <- grams / specific_mass
  return(ml)
}

# Specific mass of water and oil
water_mass = 1
oil_mass = 0.92

# Convert 2 lbs of water and oil to ml
lbs_to_ml(2, water_mass)
lbs_to_ml(2, oil_mass)
```

</div>

<div>

**python**

```{python}
def lbs_to_ml(lbs, specific_mass):
  grams = lbs_to_grams(lbs)
  ml = grams / specific_mass
  return ml

# Specific mass of water and oil
water_mass = 1
oil_mass = 0.92

# Convert 2 lbs of water and oil to ml
lbs_to_ml(2, water_mass)
lbs_to_ml(2, oil_mass)
```

</div>
:::

To run the functions we just made:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Specific mass of water and oil
water_mass = 1
oil_mass = 0.92

# Convert 2 lbs of water and oil to ml
lbs_to_ml(2, specific_mass=water_mass)
lbs_to_ml(2, specific_mass=oil_mass)
```

</div>

<div>

**python**

```{python}
# Specific mass of water and oil
water_mass = 1
oil_mass = 0.92

# Convert 2 lbs of water and oil to ml
lbs_to_ml(2, specific_mass=water_mass)
lbs_to_ml(2, specific_mass=oil_mass)
```

</div>
:::

Let's say that 90% of the time when we are doing these calculations,
they are relative to using water. Then, to be more efficient, rather
than continuously having to give the mass of water, we could set the
arguments to have these as default values.

This is where default arguments in functions come into play. They are
incredibly useful for several reasons:

-   They allow us to make certain parameters optional, which can make
    the function easier to use.
-   They can provide sensible defaults for a function, allowing it to be
    used without requiring the user to specify every single parameter.
-   They can make the code more readable by clearly stating what the
    default behavior of the function is.

Here's how we can do this in both R and Python:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
lbs_to_ml <- function(lbs, specific_weight = 1) {
  grams <- lbs_to_grams(lbs)
  ml <- grams / specific_weight
  return(ml)
}

# Convert 2 lbs of water to ml (default behavior)
lbs_to_ml(2)

# Convert 2 lbs of oil to ml (specific behavior)
lbs_to_ml(2, 0.92)
```

</div>

<div>

**python**

```{python}
def lbs_to_ml(lbs, specific_weight=1):
  grams = lbs_to_grams(lbs)
  ml = grams / specific_weight
  return ml

# Convert 2 lbs of water to ml (default behavior)
lbs_to_ml(2)

# Convert 2 lbs of oil to ml (specific behavior)
lbs_to_ml(2, 0.92)
```

</div>
:::

As you can see, default arguments make our function more flexible and
easier to use. They allow the function to handle a wider range of
scenarios while keeping the code clean and readable.

### Exercise: cups to grams converter

So I once watched this movie with a small rat chef named Remy. Like it's
a very popular one, but I can't say the title for copyright reasons.
Anyway, let's say that one day, Remy decides to leave his home in France
and set sail for the culinary world of the United States.

But as soon as Remy gets onto American soil, and he starts to explore
American recipes, he encounters a problem. All the measurements are in
cups! Back in France, he was used to grams and liters. "Mon Dieu!" he
exclaimed, "How am I supposed to cook with these cup measurements?"
[Imagine this phrase with a French accent].

![](images/chapter3/chef.jpeg){width="292"}

But Remy is not a rat to be easily defeated: To make his life easier, he
decides to hire a programmer on Fiverr to convert cups to grams. You are
that programmer.

As we did with the functions we created before, you should:

1.  Create a new function `cups_to_ml` that takes as input the number of
    cups and returns as output the corresponding value in milliliters.
    Use the relation $$
    cps = 236.588 * ml
    $$
2.  Create a new function called `ml_to_grams`. This function, as above,
    will need the specific weight, but now the relation is given by the
    inverse: $$
    g = ml * \rho,
    $$ where $\rho$ is the specific weight.
3.  Create a last function called `cups_to_ml`. This function should:
    i.  Take as input two arguments: the number of cups, and a string
        that specifies an ingredient, e.g. `"flour"` or `"water"`.
        Default this second argument to `water`.

    ii. Convert the amount of cups in milliliters using the function
        `cups_to_ml`.

    iii. With an if-if else-else statement, it should check the argument
         `ingredient`, and set a `specific_weight` variable based on the
         ingredient. You can find the values in the table below:

         | Ingredient | Specific Weight (g/ml) |
         |:-----------|:-----------------------|
         | water      | 1                      |
         | flour      | 0.53                   |
         | oil        | 0.92                   |
         | oat Milk   | 1.03                   |

    iv. Call the `ml_to_grams` function with the relative ml and
        specific weight computed above, and return the result.
4.  Run the function to convert the following:
    i.  2 cups of water
    ii. Half a cup of oil
    iii. 3 cups of oat milk
    iv. 2 cups of flour plus one cup of water

**Solution:**

This is the solution with the if-elsif-else statement:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Function to convert cups to milliliters
cups_to_ml <- function(cups) {
  ml <- cups * 236.588
  return(ml)
}

# Function to convert milliliters to grams
ml_to_grams <- function(ml, specific_weight) {
  grams <- ml * specific_weight
  return(grams)
}

# Function to convert cups to grams
cups_to_grams <- function(cups, ingredient = "water") {
  # Convert cups to ml
  ml <- cups_to_ml(cups)
  
  # Select specific weight based on ingredient
  if (ingredient == "water") {
    specific_weight <- 1
  } else if (ingredient == "flour") {
    specific_weight <- 0.53
  } else if (ingredient == "oil") {
    specific_weight <- 0.92
  } else if (ingredient == "oat_milk") {
    specific_weight <- 1.03
  } else {
    specific_weight <- 1  # Default to water if ingredient is not recognized
  }
  
  # Convert ml to grams
  grams <- ml_to_grams(ml, specific_weight)
  
  return(grams)
}


# Run the function to convert the following
cups_to_grams(2, "water")
cups_to_grams(0.5, "oil")
cups_to_grams(3, "oat_milk")
cups_to_grams(2, "flour") + cups_to_grams(1, "water")
```

</div>

<div>

**python**

```{python}
# Function to convert cups to milliliters
def cups_to_ml(cups):
  ml = cups * 236.588
  return ml

# Function to convert milliliters to grams
def ml_to_grams(ml, specific_weight):
  grams = ml * specific_weight
  return grams

# Function to convert cups to grams
def cups_to_grams(cups, ingredient = "water"):
  # Convert cups to ml
  ml = cups_to_ml(cups)
  
  # Select specific weight based on ingredient
  if ingredient == "water":
    specific_weight = 1
  elif ingredient == "flour":
    specific_weight = 0.53
  elif ingredient == "oil":
    specific_weight = 0.92
  elif ingredient == "oat_milk":
    specific_weight = 1.03
  else:
    specific_weight = 1  # Default to water if ingredient is not recognized
  
  # Convert ml to grams
  grams = ml_to_grams(ml, specific_weight)
  
  return grams


# Run the function to convert the following
cups_to_grams(2, "water")
cups_to_grams(0.5, "oil")
cups_to_grams(3, "oat_milk")
cups_to_grams(2, "flour") + cups_to_grams(1, "water")
```

</div>
:::

**Bonus** However, there's a better solution that uses named vectors (in
R) and dictionaries (in Python) to avoid the if-elseif-else statement.
These are two new structures we have never seen earlier. Have a look
below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Function to convert cups to milliliters
cups_to_ml <- function(cups) {
  ml <- cups * 236.588
  return(ml)
}

# Function to convert milliliters to grams
ml_to_grams <- function(ml, specific_weight) {
  grams <- ml * specific_weight
  return(grams)
}

# Function to convert cups to grams
cups_to_grams <- function(cups, ingredient = "water") {
  # Specific weights
  weights <- c(water = 1, flour = 0.53, oil = 0.92, oat_milk = 1.03)
  
  # Convert cups to ml
  ml <- cups_to_ml(cups)
  
  # Convert ml to grams
  grams <- ml_to_grams(ml, weights[ingredient])
  
  return(grams)
}

# Run the function to convert the following
cups_to_grams(2, "water")
cups_to_grams(0.5, "oil")
cups_to_grams(3, "oat_milk")
cups_to_grams(2, "flour") + cups_to_grams(1, "water")
```

</div>

<div>

**python**

```{python}
# Function to convert cups to milliliters
def cups_to_ml(cups):
  ml = cups * 236.588
  return ml

# Function to convert milliliters to grams
def ml_to_grams(ml, specific_weight):
  grams = ml * specific_weight
  return grams

# Function to convert cups to grams
def cups_to_grams(cups, ingredient = "water"):
  # Specific weights
  weights = {"water": 1, "flour": 0.53, "oil": 0.92, "oat_milk": 1.03}
  
  # Convert cups to ml
  ml = cups_to_ml(cups)
  
  # Convert ml to grams
  grams = ml_to_grams(ml, weights[ingredient])
  
  return grams

# Run the function to convert the following
cups_to_grams(2, "water")
cups_to_grams(0.5, "oil")
cups_to_grams(3, "oat_milk")
cups_to_grams(2, "flour") + cups_to_grams(1, "water")
```

</div>
:::

Let's break it down!

In **R**, we used a named vector. A named vector is just like a regular
vector, but each element in the vector has a name. In our case, the
names are the ingredients ("water", "flour", "oil", "oat_milk"), and the
elements are the specific weights. We can access the elements of a named
vector using their names. For example, `weights["water"]` gives us the
specific weight of water.

```{r}
weights <- c(water = 1, flour = 0.53, oil = 0.92, oat_milk = 1.03)
```

In **Python**, we used a dictionary. A dictionary is a collection of
key-value pairs. The keys in our dictionary are the ingredients
("water", "flour", "oil", "oat_milk"), and the values are the specific
weights. We can access the values in a dictionary using their keys. For
example, `weights["water"]` gives us the specific weight of water.

```{python}
weights = {"water": 1, "flour": 0.53, "oil": 0.92, "oat_milk": 1.03}
```

Both named vectors in R and dictionaries in Python provide a convenient
way to store and access related pieces of information. They're
particularly useful when we have pairs of related data, like ingredients
and their specific weights in our example!

```{=html}
<style type="text/css">
.book .book-body .page-wrapper .page-inner {
  max-width: 1200px !important;
}
</style>
```
## Loops and State

Normally, if you have to run some operations on multiple objects, you
would store these objects in a vector, and then work with the vector
directly. This is what we've been doing in the past weeks, and what
works for most of the times. For instance, let's say we have a vector
called `measurements` in lbs and we want to convert all these
measurements to grams. Then, we can simply take our function
`lbs_to_grams` we made above, and run it on the `measurements` vector:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Create a vector of measurements in lbs
measurements <- c(1, 2, 3)

# Convert measurements to grams
lbs_to_grams(measurements)
```

</div>

<div>

**python**

```{python}
# importing numpy
import numpy as np

# Create a list of measurements in lbs
measurements = np.array([1, 2, 3])

# Convert measurements to grams
lbs_to_grams(measurements)
```

</div>
:::

This will run the function on each element of the vector
**independently**.

More formally: in the first two weeks, we learned how to work with
vectors and vectorised functions, designed to operate on whole vectors
directly. Technically, we say that vectorised functions are trivially
parallelizable because there's no dependency between elements (the value
of an element of the output vector does not depend on any other
element).

However, *while you should use vectorised functions as much as you can*,
they are not suitable for all programming tasks, particularly when the
computation of an element depends on the previous ones, i.e., when there
is a state involved.

### A question of state

A state is a scenario where certain steps in your code must be executed
in a specific order because the output of one step is the input to the
next step. In these circumstances, we find an answer in **looping**.
Loops allow us to execute a block of code multiple times, which is
exactly what we want in these scenarios.

The Fibonacci sequence is a classic example of a state. If you're not
familiar with it, the Fibonacci sequence is a series of numbers in which
each number is the sum of the two preceding ones, usually starting with
0 and 1. The first 10 values in the series will be:

| $r_{i}$ | $r_{0}$ | $r_{1}$ | $r_{2}$ | $r_{3}$ | $r_{4}$ | $r_{5}$ | $r_{6}$ | $r_{7}$ | $r_{8}$ | $r_{9}$ |
|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|-------|
| Value   | 0       | 1       | 1       | 2       | 3       | 5       | 8       | 13      | 21      | 34      |

: This table shows the first 10 numbers of the Fibonacci sequence,
starting from $r_{0}$ to $r_{9}$.

More formally, the Fibonacci sequence is defined by the recurrence
relation:

$$
r_{i} = r_{i - 1} + r_{i - 2} \quad \text{for}\quad i > 2,
$$

with initial conditions $r_{1} = 0$ and $r_{2} = 1$.

Well, unsurprisingly, in mathematics, you have already met the "for"
statements! As in mathematics a "for" allows to build a relation, a
"for" loop is a control flow statement that allows code to be executed
repeatedly.

Therefore, to generate the Fibonacci sequence using a "for" loop, we
could use the following algorithm:

1.  Start by defining the first two numbers in the sequence, 0 and 1.
2.  For a given number of iterations, do the following:
    -   Calculate the next number in the sequence as the sum of the
        previous two numbers.
    -   Update the previous two numbers to be the last number and the
        newly calculated number.

We will return to the Fibonacci example after having introduced the for
loop syntax.

### The For loop

We can code a for loop as following.

**In R:**

```{r}
for (i in 1:10) {
  print(i)
}
```

In this R code, to explain the syntax:

-   `for (i in 1:10)` is the start of the for loop. The iterator `i`
    goes from 1 to 10. `1:10` creates a vector: this is the sequence of
    values we want to iterate over.
-   `print(i)` is the code chunk that we want to repeat. In this case it
    prints the current value of `i`.
-   `i` is the object that stores our current index. It gets updated at
    each step over the sequence of values for 1 to 10.
-   The for loop ends when it has exhausted the sequence, i.e., when `i`
    has taken all values from 1 to 10.

We can also use the for loop to iterate over the elements of a vector
directly, rather than their indices. For example, a for loop that prints
the elements of a vector:

```{r}
vec <- c("apple", "banana", "cherry")
for (fruit in vec) {
  print(fruit)
}
```

In this case, `fruit` is the iterator that gets updated at each step
over the sequence with the current element of the sequence. The for loop
ends when it has exhausted the sequence.

**In Python:**

In Python, we can print the numbers from 1 to 10 using a for loop as
follows:

```{python}
for i in range(1, 11):
  print(i)
```

In this Python code, to explain the syntax:

-   `for i in range(1, 11)` is the start of the for loop. The iterator
    `i` goes from 1 to 10. This is the sequence we want to iterate over.
    We use `range` function to generate this figure: this function is
    analogue to `np.arange` from numpy, but generates a different object
    called "range" that is specific to iterators
-   `print(i)` is the code chunk that we want to repeat. It prints the
    current value of `i`.
-   `i` is the object that stores our current index. It gets updated at
    each step over the sequence.
-   The for loop ends when it has exhausted the sequence, i.e., when `i`
    has taken all values from 1 to 10.

We can also use the for loop to iterate over the elements of a numpy
array directly, rather than their indices. For example, a for loop that
prints the elements of a numpy array:

```{python}
arr = np.array(["apple", "banana", "cherry"])
for fruit in arr:
  print(fruit)
```

In this Python code:

-   `arr = np.array(["apple", "banana", "cherry"])` creates a numpy
    array with the elements "apple", "banana", and "cherry".
-   `for fruit in arr:` is the start of the for loop. The iterator
    `fruit` goes over each element in the numpy array `arr`.
-   `print(fruit)` is the code chunk that we want to repeat. It prints
    the current value of `fruit`.
-   `fruit` is the object that stores the current element of the array.
    It gets updated at each step over the sequence.
-   The for loop ends when it has exhausted the sequence, i.e., when
    `fruit` has taken all values in the numpy array `arr`.

### Coding The Fibonacci sequence

Having covered how to write a for cycle, we come back to our Fibonacci
example:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Initialize the first two numbers in the sequence
fibonacci <- c(0, 1)

# Generate the next 18 numbers in the sequence
for (i in 3:20) {
  fibonacci[i] <- fibonacci[i - 1] + fibonacci[i - 2]
}

# Print the Fibonacci sequence
print(fibonacci)
```

</div>

<div>

**Python**

```{python}
# Initialize the first two numbers in the sequence
fibonacci = [0, 1]

# Generate the next 18 numbers in the sequence
for i in range(2, 20):
  fibonacci.append(fibonacci[i - 1] + fibonacci[i - 2])

# converting the list into a numpy array 
# (useful if we want to use vectorised operations later!)
fibonacci = np.array(fibonacci)

# Print the Fibonacci sequence
print(fibonacci)
```

</div>
:::

In this R code:

-   `fibonacci <- c(0, 1)` initializes the first two numbers in the
    Fibonacci sequence.
-   `for (i in 3:20)` is the start of the for loop. The iterator `i`
    goes from 3 to 20. This is the sequence we want to iterate over.
-   `fibonacci[i] <- fibonacci[i - 1] + fibonacci[i - 2]` is the code
    chunk that we want to repeat. It calculates the `i`th number in the
    Fibonacci sequence as the sum of the two preceding numbers and
    appends it to the `fibonacci` vector. Given that at iteration `i` we
    have no element `i` in the vector yet (this is still `i-1` long), R
    will automatically extend the vector of one extra element.

In this Python code:

-   `fibonacci = [0, 1]` initializes the first two numbers in the
    Fibonacci sequence.
-   `for i in range(2, 20)` is the start of the for loop. The iterator
    `i` goes from 2 to 19. This is the sequence we want to iterate over.
-   `fibonacci.append(fibonacci[i - 1] + fibonacci[i - 2])` is the code
    chunk that we want to repeat. It calculates the `i`th number in the
    Fibonacci sequence as the sum of the two preceding numbers and
    appends it to the `fibonacci` list using the `append()` method. The
    append method extends our vector, adding a new element at the end of
    the existing one.

### Nested loops

Nested loops are useful when we have to repeat a block of code for each
combination of elements from two or more sequences. This can be
incredibly useful in many situations, such as when we want to perform an
operation for each pair of elements in two lists or vectors.

A simple example, for instance, could be a nested loop that prints the
multiplication table from 1 to 4.

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
for (i in 1:4) {
  for (j in 1:4) {
    print(paste(i, "x", j, "=", i*j))
  }
}
```

</div>

<div>

**Python**

```{python}
for i in range(1, 4):
  for j in range(1, 4):
      print(f"{i} x {j} = {i*j}")
```

</div>
:::

---
editor_options: 
  markdown: 
    wrap: 72
---

# Functions and Loops {#func_loop}

## Functions

Functions in mathematics, is an assignment of an element from a set to a
different set. Here we give a more "practical" definition.

In the realm of programming, a function is a reusable piece of code that
performs a specific task. Think of it as a mini-program within your
program, a tool you create to do a job so you don't have to. And as a
program does, you give it an input, it will do some voudou magic, and it
will spit an output.

![](images/chapter3/dark_magic.png)

What's the point of a function you might ask? Well, in programming, we
use functions when we have tasks that must be performed again and again.
When we notice a repetitive task occurring, it is a good idea to write a
function that performs this task. If you find yourself copying and
pasting the same piece of code more than three times, it's time to stop
and think: "Should I write a function for this?" Remember, in the world
of coding, being lazy is often a good thing! We aim for efficiency, not
repetitive strain injury.

![](images/chapter3/homer.jpg){width="366"}

Imagine if every time you need to compute the square root, you need to
write the code to compute the square root over and over again. Well, but in practice, you don't have to!
There's *a function* that does the job for you already: `sqrt`
In fact, it won't come as a surprise that we've already encountered many
functions in the past weeks. For instance:

-   Mathematical functions like `sqrt()` or `sin()` in R, and
    `math.sqrt()` or `math.sin()` in Python.
-   Functions like `np.array()` or `c()` to create vectors.
-   Functions like `length()` in R or `len()` in Python to get
    information about our data structures.

Again, each function I mentioned, has an input, and an output: `sqrt`
takes a number as input and returns the square root of such number,
`length` or `len` take a whole vector as input, and return the length of
it...

Another incredibly useful function is the `help()` function, available
in both R and Python. This function takes a **function** as an input,
and provides us with information said function as output! For example:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r eval=FALSE}
help(sqrt)
```

</div>

<div>

**python**

```{python eval=FALSE}
help(math.sqrt)
```

</div>
:::

Whenever you will meet a **built-in** function, or a function from a **documented external library** you can call the help on the function to have an explanation about it! Documentation is a requirement in R libraries, so pretty much all the functions you will meet are documented! Unfortunately this is not the case for Python, where documenting functions is not a requirement, so not always the `help` will return something. 

### Writing new functions

The real power of functions comes when we start creating our own. We
can write new functions that perform specific tasks, tailored to our
needs. This allows us to do more complex, interesting, and fun things
with our code. So let's dive in and learn how to create our own
functions!
We can wrap our code in a function, and every time the function is called, this code is run. This is incredibly useful for tasks we need to perform multiple times. Letâ€™s build for example a simple function that converts pounds (lbs) to grams (g).

Mathematically, this is simply done by the formula:
$$
g = 453.5924 * lbs
$$

In **R**, we define a function using the `function()` command. The arguments of the function are placed within the parentheses. Here's how we can create a function in R:

```{r}
lbs_to_grams <- function(lbs) {
  grams <- 453.5924 * lbs
  return(grams)
}
```

In this function, `lbs` is the input (or argument), and the function returns the equivalent weight in grams. In R, we create a new function with the `function` statement, and then we assign it to a variable, which is going to be containing our function. The `return()` statement is used to specify the result that the function should output.

In **Python**, we define a function using the `def` keyword. The arguments of the function are placed within the parentheses. Again we need to use indentation: this is crucial in Python as it determines the code blocks. Here's how we can create a function in Python:

```{python}
def lbs_to_grams(lbs):
  grams = 453.5924 * lbs
  return grams
```

In this function, `lbs` is the input (or argument), and the function returns the equivalent weight in grams: following the `def` keyword we need both the function name, followed by the argument. The `return` statement is used to specify the result that the function should output.


Now, once we have made the new function, we can call it with:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
lbs_to_grams(lbs=2)
lbs_to_grams(lbs=3)

# when calling we can also omit 
# the argument name for brevity
lbs_to_grams(3)
```

</div>

<div>

**python**

```{python}
lbs_to_grams(lbs=2)
lbs_to_grams(lbs=3)

# when calling we can also omit 
# the argument name for brevity
lbs_to_grams(3)
```

</div>
:::

By creating functions like these, we can make our code more efficient and easier to read. Plus, it saves us from having to remember the conversion rate each time we want to convert pounds to grams!

The name of the function `lbs_to_grams` and its argument `lbs` are just names that I chose.
There are a few guidelines that could be useful when naming functions:
-   Names should be lowercase.
-   Use an underscore, _, to separate words within a name.
-   Strive for names that are concise and meaningful (this is not easy!).
-   Avoid existing function names in R and python, such as `length()` or `len()`.

Also, you might have noticed we made a variable within the function code, `grams`. But what does it mean to have variables within functions? The variables used inside a function are local to that function. Think of your function as a guarded sandbox, where no child leaves unless you specifically tell them to. This sandbox is called and *enviroment*. Let's cover this concept formally!

#### Enviroments 
In programming, an environment refers to a structure that holds variables. When you create a variable in a program, the environment is where this variable lives. The environment keeps track of the variable's name and its current value.

There are two types of environments: global and local.

- The **global environment** is the default environment where your variables live unless you specify otherwise. When you create a variable at the top level of your script, it's stored in the global environment.

- A **local environment** is created when you call a function. Each time a function is called, a new local environment is created for that function call. This environment holds the variables that are created within the function. These variables are only accessible within the function call and cease to exist once the function call is over.

Let's consider the `lbs_to_grams` function we made:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r error=TRUE}
lbs_to_grams <- function(lbs) {
  grams = 453.5924 * lbs
  return(grams)
}

# Create a variable in the global environment
glo_grams <- 2

# Try to access the local variable "grams"
print(grams)
# Try to access the global variable "glo_grams"
print(glo_grams)
```

</div>

<div>

**python**

```{python error=TRUE}
def lbs_to_grams(lbs):
  grams = 453.5924 * lbs
  return grams

# Create a variable in the global environment
glo_grams = 2

# Try to access the local variable "grams"
print(grams)
# Try to access the global variable "glo_grams"
print(glo_grams)
```

</div>
:::

In these functions, `lbs` and `grams` are variables in the local environment of the function. They are created when the function is called and cease to exist when the function call is over. If you try to access `grams` outside of the function, you'll get an error because `grams` is not in the global environment.

On the other hand, `glo_grams` is in the global environment because it's created at the top level of the script, not within a function. You can access `glo_grams` anywhere in your script **even within a function**.

This distinction between global and local variables helps keep our code clean and reduces the chance of errors. It ensures that the function does its job without interfering with the rest of our script! However, it can be prone to errors too. Say for instance, I make a typo in the argument name of my function above, and, for whatever reason I created a lbs variable in the global... Like for instance:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r error=TRUE}
# I specified in the global lbs at some point 
lbs <- 3

# and here I made a typo!
#                            V
bug_lbs_to_grams <- function(lb) {
  grams = 453.5924 * lbs
  return(grams)
}

# Then, no matter what I call, I will always get the same result! 
# e.g.: 453.5924 * 3 
bug_lbs_to_grams(2)
bug_lbs_to_grams(10)
bug_lbs_to_grams(42)
```

</div>

<div>

**python**

```{python error=TRUE}
# I specified in the global lbs at some point 
lbs = 3

# and here I made a typo!
#                     V
def bug_lbs_to_grams(lb):
  grams = 453.5924 * lbs
  return grams

# Then, no matter what I call, I will always get the same result! 
# e.g.: 453.5924 * 3 
bug_lbs_to_grams(2)
bug_lbs_to_grams(10)
bug_lbs_to_grams(42)
```

</div>
:::

What happened above, is that I pass down as an input the `lb` argument (without the s) *but this is nowhere used in the function* as inside the code, at `grams = 453.5924 * lbs` I call the `lbs`. Now since the compiler can't find any `lbs` within the local enviroment, it will just assume that this is the `lbs` I specified in the global. 
Hence, no matter what I feed to the function, it will return the evaluation with the global `lbs`.
**For this reason try not to name the variables inside your functions as those outside it, in the rest of your script**. What happens if I do name a local variable and global variable in the same way? Well, in this case, the function will use the local `lbs` variable, and the global will use the global `lbs` variable **but this is still risky and prone to bugs**.

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r error=TRUE}
# global lbs
lbs <- 3

# but this does not affect the "lbs" of the function argument
lbs_to_grams(2)
lbs_to_grams(10)
lbs_to_grams(42)
```

</div>

<div>

**python**

```{python error=TRUE}
# global lbs 
lbs = 3

# but this does not affect the "lbs" of the function argument
lbs_to_grams(2)
lbs_to_grams(10)
lbs_to_grams(42)
```

</div>
:::

#### Multiple arguments

Say we want now to convert pounds to milliliters. To convert from mass to volume, we will need an additional information, the specific mass. In physics, the specific mass (also known as the volumetric mass density) of a substance is the mass per unit volume. 

Fortunately for us, functions can take multiple arguments, allowing us to give more elements to the local environment of the function. This means we can customize the function's behavior based on these inputs. Let's see how we can add more arguments to a function.

We'll create a new function to convert pounds to milliliters. This function will take a second argument: `specific_mass`. We'll use the function **we created earlier** to convert pounds to grams, and then, using the `specific_mass`, we'll convert grams to liters.

Here's how we can do this in both R and Python:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
lbs_to_ml <- function(lbs, specific_mass) {
  grams <- lbs_to_grams(lbs)
  ml <- grams / specific_mass
  return(ml)
}

# Specific mass of water and oil
water_mass = 1
oil_mass = 0.92

# Convert 2 lbs of water and oil to ml
lbs_to_ml(2, water_mass)
lbs_to_ml(2, oil_mass)
```

</div>

<div>

**python**

```{python}
def lbs_to_ml(lbs, specific_mass):
  grams = lbs_to_grams(lbs)
  ml = grams / specific_mass
  return ml

# Specific mass of water and oil
water_mass = 1
oil_mass = 0.92

# Convert 2 lbs of water and oil to ml
lbs_to_ml(2, water_mass)
lbs_to_ml(2, oil_mass)
```

</div>
:::

To run the functions we just made: 

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Specific mass of water and oil
water_mass = 1
oil_mass = 0.92

# Convert 2 lbs of water and oil to ml
lbs_to_ml(2, specific_mass=water_mass)
lbs_to_ml(2, specific_mass=oil_mass)
```

</div>

<div>

**python**

```{python}
# Specific mass of water and oil
water_mass = 1
oil_mass = 0.92

# Convert 2 lbs of water and oil to ml
lbs_to_ml(2, specific_mass=water_mass)
lbs_to_ml(2, specific_mass=oil_mass)
```

</div>
:::

Let's say that 90% of the time when we are doing these calculations, they are relative to using water. Then, to be more efficient, rather than continuously having to give the mass of water, we could set the arguments to have these as default values. 

This is where default arguments in functions come into play. They are incredibly useful for several reasons:

- They allow us to make certain parameters optional, which can make the function easier to use.
- They can provide sensible defaults for a function, allowing it to be used without requiring the user to specify every single parameter.
- They can make the code more readable by clearly stating what the default behavior of the function is.

Here's how we can do this in both R and Python:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
cups_to_ml <- function(cups, specific_weight = 1) {
  grams <- cups_to_grams(cups)
  ml <- grams / specific_weight
  return(ml)
}

# Convert 2 cups of water to ml (default behavior)
cups_to_ml(2)

# Convert 2 cups of oil to ml (specific behavior)
cups_to_ml(2, 0.92)
```

</div>

<div>

**python**

```{python}
def cups_to_ml(cups, specific_weight=1):
  grams = cups_to_grams(cups)
  ml = grams / specific_weight
  return ml

# Convert 2 cups of water to ml (default behavior)
cups_to_ml(2)

# Convert 2 cups of oil to ml (specific behavior)
cups_to_ml(2, 0.92)
```

</div>
:::

As you can see, default arguments make our function more flexible and easier to use. They allow the function to handle a wider range of scenarios while keeping the code clean and readable.
```{=html}
<style type="text/css">
.book .book-body .page-wrapper .page-inner {
  max-width: 1200px !important;
}
</style>
```

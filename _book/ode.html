<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>10 Ordinary differential equations | Lancaster University MATH245 Computational Mathematics</title>
  <meta name="description" content="10 Ordinary differential equations | Lancaster University MATH245 Computational Mathematics" />
  <meta name="generator" content="bookdown 0.34 and GitBook 2.6.7" />

  <meta property="og:title" content="10 Ordinary differential equations | Lancaster University MATH245 Computational Mathematics" />
  <meta property="og:type" content="book" />
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="10 Ordinary differential equations | Lancaster University MATH245 Computational Mathematics" />
  
  
  

<meta name="author" content="Lecturers: Dr Eduard Campillo-Funollet and Dr Gaetano Romano" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="mc.html"/>
<link rel="next" href="challenge.html"/>
<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="chapter" data-level="1" data-path="intro_prog.html"><a href="intro_prog.html"><i class="fa fa-check"></i><b>1</b> Introduction to Computational Mathematics</a>
<ul>
<li class="chapter" data-level="1.1" data-path="intro_prog.html"><a href="intro_prog.html#what-is-a-computer"><i class="fa fa-check"></i><b>1.1</b> What is a Computer?</a></li>
<li class="chapter" data-level="1.2" data-path="intro_prog.html"><a href="intro_prog.html#computing-accessing-memory-and-storing"><i class="fa fa-check"></i><b>1.2</b> Computing, Accessing Memory and Storing</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="log_vec.html"><a href="log_vec.html"><i class="fa fa-check"></i><b>2</b> Logic and Vectors</a>
<ul>
<li class="chapter" data-level="2.1" data-path="log_vec.html"><a href="log_vec.html#comparisons"><i class="fa fa-check"></i><b>2.1</b> Comparisons</a></li>
<li class="chapter" data-level="2.2" data-path="log_vec.html"><a href="log_vec.html#logical-arithmetic"><i class="fa fa-check"></i><b>2.2</b> Logical Arithmetic</a></li>
<li class="chapter" data-level="2.3" data-path="log_vec.html"><a href="log_vec.html#flow"><i class="fa fa-check"></i><b>2.3</b> Flow</a></li>
<li class="chapter" data-level="2.4" data-path="log_vec.html"><a href="log_vec.html#vectors"><i class="fa fa-check"></i><b>2.4</b> Vectors</a></li>
<li class="chapter" data-level="2.5" data-path="log_vec.html"><a href="log_vec.html#accessing-vectors"><i class="fa fa-check"></i><b>2.5</b> Accessing vectors</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="func_loop.html"><a href="func_loop.html"><i class="fa fa-check"></i><b>3</b> Functions and Loops</a>
<ul>
<li class="chapter" data-level="3.1" data-path="func_loop.html"><a href="func_loop.html#functions"><i class="fa fa-check"></i><b>3.1</b> Functions</a></li>
<li class="chapter" data-level="3.2" data-path="func_loop.html"><a href="func_loop.html#looping"><i class="fa fa-check"></i><b>3.2</b> State and For Loop</a></li>
<li class="chapter" data-level="3.3" data-path="func_loop.html"><a href="func_loop.html#more-about-looping"><i class="fa fa-check"></i><b>3.3</b> More about looping</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="maps_alg.html"><a href="maps_alg.html"><i class="fa fa-check"></i><b>4</b> Functional Programming and Linear Algebra</a>
<ul>
<li class="chapter" data-level="4.1" data-path="maps_alg.html"><a href="maps_alg.html#Maps"><i class="fa fa-check"></i><b>4.1</b> An intro to Functional Programming</a></li>
<li class="chapter" data-level="4.2" data-path="maps_alg.html"><a href="maps_alg.html#doing-linear-algebra"><i class="fa fa-check"></i><b>4.2</b> Doing Linear Algebra</a></li>
<li class="chapter" data-level="4.3" data-path="maps_alg.html"><a href="maps_alg.html#an-end-note-to-this-chapter"><i class="fa fa-check"></i><b>4.3</b> An end note to this chapter</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="df_plt.html"><a href="df_plt.html"><i class="fa fa-check"></i><b>5</b> Data Frames and Plotting</a>
<ul>
<li class="chapter" data-level="5.1" data-path="df_plt.html"><a href="df_plt.html#data-frames"><i class="fa fa-check"></i><b>5.1</b> Data Frames</a></li>
<li class="chapter" data-level="5.2" data-path="df_plt.html"><a href="df_plt.html#plotting-with-ggplot-and-plotnine"><i class="fa fa-check"></i><b>5.2</b> Plotting with ggplot (and plotnine)</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="fixed.html"><a href="fixed.html"><i class="fa fa-check"></i><b>6</b> Fixed point iteration</a>
<ul>
<li class="chapter" data-level="6.1" data-path="fixed.html"><a href="fixed.html#fixed-points"><i class="fa fa-check"></i><b>6.1</b> Fixed points</a></li>
<li class="chapter" data-level="6.2" data-path="fixed.html"><a href="fixed.html#convergence"><i class="fa fa-check"></i><b>6.2</b> Convergence</a></li>
<li class="chapter" data-level="6.3" data-path="fixed.html"><a href="fixed.html#fixed-point-theorems"><i class="fa fa-check"></i><b>6.3</b> Fixed point theorems</a></li>
<li class="chapter" data-level="6.4" data-path="fixed.html"><a href="fixed.html#exercises"><i class="fa fa-check"></i><b>6.4</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="roots.html"><a href="roots.html"><i class="fa fa-check"></i><b>7</b> Root finding</a>
<ul>
<li class="chapter" data-level="7.1" data-path="roots.html"><a href="roots.html#fixed-point-iteration-1"><i class="fa fa-check"></i><b>7.1</b> Fixed point iteration</a></li>
<li class="chapter" data-level="7.2" data-path="roots.html"><a href="roots.html#newtons-method"><i class="fa fa-check"></i><b>7.2</b> Newton’s method</a></li>
<li class="chapter" data-level="7.3" data-path="roots.html"><a href="roots.html#a-note-on-convergence"><i class="fa fa-check"></i><b>7.3</b> A note on convergence</a></li>
<li class="chapter" data-level="7.4" data-path="roots.html"><a href="roots.html#a-note-on-newtons-method."><i class="fa fa-check"></i><b>7.4</b> A note on Newton’s method.</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="gd.html"><a href="gd.html"><i class="fa fa-check"></i><b>8</b> Gradient descent</a>
<ul>
<li class="chapter" data-level="8.1" data-path="gd.html"><a href="gd.html#optimisation-and-root-finding"><i class="fa fa-check"></i><b>8.1</b> Optimisation and root finding</a></li>
<li class="chapter" data-level="8.2" data-path="gd.html"><a href="gd.html#gradient-descent"><i class="fa fa-check"></i><b>8.2</b> Gradient descent</a></li>
<li class="chapter" data-level="8.3" data-path="gd.html"><a href="gd.html#notes"><i class="fa fa-check"></i><b>8.3</b> Notes</a></li>
<li class="chapter" data-level="8.4" data-path="gd.html"><a href="gd.html#exercises-and-challenges"><i class="fa fa-check"></i><b>8.4</b> Exercises and challenges</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="mc.html"><a href="mc.html"><i class="fa fa-check"></i><b>9</b> Monte Carlo methods</a>
<ul>
<li class="chapter" data-level="9.1" data-path="mc.html"><a href="mc.html#simple-example-area-of-a-circle"><i class="fa fa-check"></i><b>9.1</b> Simple example: area of a circle</a></li>
<li class="chapter" data-level="9.2" data-path="mc.html"><a href="mc.html#definition-and-properties"><i class="fa fa-check"></i><b>9.2</b> Definition and properties</a></li>
<li class="chapter" data-level="9.3" data-path="mc.html"><a href="mc.html#example"><i class="fa fa-check"></i><b>9.3</b> Example</a></li>
<li class="chapter" data-level="9.4" data-path="mc.html"><a href="mc.html#error-estimate"><i class="fa fa-check"></i><b>9.4</b> Error estimate</a></li>
<li class="chapter" data-level="9.5" data-path="mc.html"><a href="mc.html#asymptotic-error"><i class="fa fa-check"></i><b>9.5</b> Asymptotic error</a></li>
<li class="chapter" data-level="9.6" data-path="mc.html"><a href="mc.html#exercises-1"><i class="fa fa-check"></i><b>9.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="ode.html"><a href="ode.html"><i class="fa fa-check"></i><b>10</b> Ordinary differential equations</a>
<ul>
<li class="chapter" data-level="10.1" data-path="ode.html"><a href="ode.html#numerical-integration"><i class="fa fa-check"></i><b>10.1</b> Numerical integration</a></li>
<li class="chapter" data-level="10.2" data-path="ode.html"><a href="ode.html#ordinary-differential-equations"><i class="fa fa-check"></i><b>10.2</b> Ordinary differential equations</a></li>
<li class="chapter" data-level="10.3" data-path="ode.html"><a href="ode.html#higher-order-methods"><i class="fa fa-check"></i><b>10.3</b> Higher order methods</a></li>
<li class="chapter" data-level="10.4" data-path="ode.html"><a href="ode.html#systems-of-odes"><i class="fa fa-check"></i><b>10.4</b> Systems of ODEs</a></li>
<li class="chapter" data-level="10.5" data-path="ode.html"><a href="ode.html#examples-1"><i class="fa fa-check"></i><b>10.5</b> Examples</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="challenge.html"><a href="challenge.html"><i class="fa fa-check"></i><b>11</b> Additional Programming Challenges</a>
<ul>
<li class="chapter" data-level="11.1" data-path="challenge.html"><a href="challenge.html#part-1-scientific-computing"><i class="fa fa-check"></i><b>11.1</b> Part 1: Scientific Computing</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Lancaster University MATH245 Computational Mathematics</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="ode" class="section level1 hasAnchor" number="10">
<h1><span class="header-section-number">10</span> Ordinary differential equations<a href="ode.html#ode" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<div id="numerical-integration" class="section level2 hasAnchor" number="10.1">
<h2><span class="header-section-number">10.1</span> Numerical integration<a href="ode.html#numerical-integration" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>We will start with a particular type of differential equation, where the right hand side of the equations only depends on <span class="math inline">\(x\)</span>. The problem becomes to find <span class="math inline">\(y: [a,b] \to \mathbb{R}\)</span> satisfying
<span class="math display">\[
\frac{dy}{dx} = f(x)
\]</span>
with initial condition <span class="math inline">\(y(a) = y_0\)</span>.</p>
<p>By the fundamental theorem of calculus, we know that
<span class="math display">\[
y(x) = y_0 + \int_a^x f(t)dt.
\]</span>
There are many cases in which this integral cannot be evaluated explicitly. For example, if <span class="math inline">\(f(x)=e^{-x^2}\)</span> no closed form solution exists. We therefore need to develop a method for computing integrals numerically. Note that we already looked into a method to estimate integrals numerically: Monte Carlo methods! Here we will present deterministic methods to approximate integrals, because Monte Carlo methods would be difficult to apply in the general case where the right hand side of the equations is a function of both <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>.</p>
<p>A common approach to this problem is to find an approximation to <span class="math inline">\(\int_a^b f(t) dt\)</span> which has a small error when <span class="math inline">\(b-a\)</span> is small. If we then need to evaluate an integral on a larger interval <span class="math inline">\([a,b]\)</span>, we can split it into several small intervals and use the approximation on each of these small intervals.</p>
<div id="riemann" class="section level3 hasAnchor" number="10.1.1">
<h3><span class="header-section-number">10.1.1</span> Riemann integration<a href="ode.html#riemann" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>To illustrate the general approach, we will approximate the area under the curve of the function <span class="math inline">\(f:[a,b] \to \mathbb{R}\)</span> by a rectangle with height <span class="math inline">\(f(a)\)</span> and width <span class="math inline">\(b-a\)</span>, so
<span class="math display">\[
\int_a^b f(x) dx \approx f(a)(b-a).
\]</span>
How accurate is this approximation? Let <span class="math inline">\(I = \int_a^b f(x) dx\)</span> and <span class="math inline">\(\hat{I} = f(a)(b-a)\)</span>. We compute the error
<span class="math display">\[\begin{align*}
I-\hat{I} &amp;= \int_a^b (f(x)-f(a)) dx \\
&amp;=\int_0^{b-a} (f(a+h)-f(a)) dh \\
&amp;=\int_0^{b-a} f&#39;(c_h)h dh
\end{align*}\]</span>
for some <span class="math inline">\(c_h \in (a,a+h)\)</span>. Here we have used the mean value theorem. In doing so, we needed to make the assumption that <span class="math inline">\(f\)</span> was differentiable. Throughout the remainder of this chapter we will assume, without explicitly stating it, that <span class="math inline">\(f\)</span> is sufficiently differentiable for our needs.</p>
<p>It follows that
<span class="math display">\[
|I - \hat{I}| \leq \sup_{x \in [a,b]} |f&#39;(x)| \int_0^{b-a} h dh = \frac{(b-a)^2 \sup_{x \in [a,b]}|f&#39;(x)|}{2}.
\]</span>
So <span class="math inline">\(I - \hat{I} = O((b-a)^2)\)</span> when <span class="math inline">\(b-a\)</span> is small. We refer to this as the <em>local truncation error</em>.</p>
<p>Now suppose we wish to evaluate the integral <span class="math inline">\(I=\int_a^b f(x) dx\)</span> when <span class="math inline">\(b-a\)</span> is no longer small. We split <span class="math inline">\([a,b]\)</span> into <span class="math inline">\(N\)</span> smaller intervals, each with length <span class="math inline">\(h=(b-a)/N\)</span>. Let <span class="math inline">\(x_i = a + ih\)</span>, <span class="math inline">\(i=0, \dots, N\)</span>. Then
<span class="math display">\[
I = \sum_{i=1}^N \int_{x_{i-1}}^{x_i} f(x) dx \approx \sum_{i=1}^N f(x_{i-1})(x_{i}-x_{i-1}) = h\sum_{i=1}^N f(x_{i-1}).
\]</span>
Setting
<span class="math display">\[
\hat{I}_N = h\sum_{i=1}^N f(x_{i-1}),
\]</span>
one can easily obtain a bound on the <em>global truncation error</em>
<span class="math display">\[\begin{align*}
|I-\hat{I}_N| &amp;\leq \sum_{i=1}^N \left | \int_{x_{i-1}}^{x_i} f(x) dx - f(x_{i-1})(x_i-x_{i-1}) \right | \\
&amp; \leq \frac{N h^2 \sup_{x \in [a,b]}|f&#39;(x)|}{2} \\
&amp;= \frac{(b-a)^2 \sup_{x \in [a,b]}|f&#39;(x)|}{2N},
\end{align*}\]</span>
so the global truncation error, with <span class="math inline">\(N\)</span> steps, is of size <span class="math inline">\(O(N^{-1})\)</span> for large <span class="math inline">\(N\)</span>. The step size <span class="math inline">\(h\)</span> and the total number of steps <span class="math inline">\(N\)</span> are related by <span class="math inline">\(Nh = b-a\)</span>. So one could equivalently say that the global truncation error with step size <span class="math inline">\(h\)</span> is <span class="math inline">\(O(h)\)</span> for <span class="math inline">\(h\)</span> small.</p>
<p>In order to obtain a global truncation error of less than <span class="math inline">\(\epsilon\)</span>, one would need to take
<span class="math display">\[
N \geq \frac{(b-a)^2 \sup_{x \in [a,b]}|f&#39;(x)|}{2 \epsilon},
\]</span>
so an algorithm which computes a numerical estimate of <span class="math inline">\(\int_a^b f(x) dx\)</span> in this way will have complexity <span class="math inline">\(O(\epsilon^{-1})\)</span> for small <span class="math inline">\(\epsilon\)</span>.</p>
<p>We say that an algorithm of this type is <span class="math inline">\(p^{th}\)</span> order if the global truncation error with step-size <span class="math inline">\(h\)</span> is <span class="math inline">\(O(h^p)\)</span>. The following statements are all equivalent for numerical integration methods of this form.</p>
<ul>
<li>An algorithm is <span class="math inline">\(p^{th}\)</span> order.</li>
<li>The local truncation error on a small interval <span class="math inline">\([a,b]\)</span> is <span class="math inline">\(O((b-a)^{p+1})\)</span>.</li>
<li>The global truncation error with <span class="math inline">\(N\)</span> steps is <span class="math inline">\(O(N^{-p})\)</span>.</li>
<li>The complexity of an algorithm with global truncation error <span class="math inline">\(\epsilon\)</span> is <span class="math inline">\(O(\epsilon^{-1/p})\)</span>.</li>
</ul>
<p>The higher the order, the more accurate (for a given number of steps) or faster (for a given degree of accuracy) the algorithm.</p>
</div>
<div id="midpoint" class="section level3 hasAnchor" number="10.1.2">
<h3><span class="header-section-number">10.1.2</span> Midpoint rule<a href="ode.html#midpoint" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The midpoint rule approximates the area under the curve of the function <span class="math inline">\(f:[a,b] \to \mathbb{R}\)</span> is approximated by a rectangle with height <span class="math inline">\(f((a+b)/2)\)</span> and width <span class="math inline">\(b-a\)</span> i.e. the midpoint of the interval is used to determine the height of the rectangle.</p>
<p>Using Taylor’s Theorem to second order, with Lagrange remainder, this gives the local truncation error
<span class="math display">\[\begin{align*}
I-\hat{I} &amp;= \int_a^b \left (f(x) - f\left(\frac{a+b}{2} \right ) \right ) dx \\
&amp;= \int_{-(a+b)/2}^{(a+b)/2} \left (f\left (\frac{a+b}{2}+h\right ) - f\left (\frac{a+b}{2} \right ) \right ) dh \\
&amp;= \int_{-(a+b)/2}^{(a+b)/2} \left (f&#39;\left(\frac{a+b}{2}\right)h + \frac{1}{2}f&#39;&#39;(c_h)h^2 \right ) dh \\
&amp;= \left [ f&#39;\left(\frac{a+b}{2}\right) \frac{h^2}{2} \right ]_{-(a+b)/2}^{(a+b)/2} + \int_{-(a+b)/2}^{(a+b)/2} \frac{h^2f&#39;&#39;(c_h)}{2} dh \\
&amp;= 0 + \int_{-(a+b)/2}^{(a+b)/2} \frac{h^2f&#39;&#39;(c_h)}{2} dh.
\end{align*}\]</span>
It follows that
<span class="math display">\[
|I-\hat{I}| \leq \sup_{x \in [a,b]}|f&#39;&#39;(x)| \int_0^{(b-a)/2} h^2 dh = \frac{(b-a)^3 \sup_{x \in [a,b]}|f&#39;&#39;(x)|}{24},
\]</span>
so the local truncation error is <span class="math inline">\(O((b-a)^3)\)</span> for small <span class="math inline">\(b-a\)</span>.</p>
<p>To evaluate the integral <span class="math inline">\(I=\int_a^b f(x) dx\)</span> when <span class="math inline">\(b-a\)</span>, we split <span class="math inline">\([a,b]\)</span> into <span class="math inline">\(N\)</span> smaller intervals as before. For <span class="math inline">\(h=(b-a)/N\)</span>, let <span class="math inline">\(x_i = a + ih\)</span>, <span class="math inline">\(i=0, \dots, N\)</span> and define the midpoints <span class="math inline">\(y_i=(x_{i-1}+x_i)/2 = a +(2i-1)h/2\)</span>. Then <span class="math inline">\(I\)</span> is approximated by
<span class="math display">\[
\hat{I}_N = h\sum_{i=1}^N f(y_i)
\]</span>
and the global truncation error
<span class="math display">\[
|I-\hat{I}_N| \leq \frac{N h^3 \sup_{x \in [a,b]}|f&#39;&#39;(x)|}{24} = \frac{(b-a)^3 \sup_{x \in [a,b]}|f&#39;(x)|}{24N^2}.
\]</span>
The global truncation error, with <span class="math inline">\(N\)</span> steps, is therefore of size <span class="math inline">\(O(N^{-2})\)</span> for large <span class="math inline">\(N\)</span> so this is a <span class="math inline">\(2^{nd}\)</span> order algorithm.</p>
</div>
<div id="trapezium" class="section level3 hasAnchor" number="10.1.3">
<h3><span class="header-section-number">10.1.3</span> Trapezium rule<a href="ode.html#trapezium" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The trapezium rule approximates the area under the curve of the function <span class="math inline">\(f:[a,b] \to \mathbb{R}\)</span> by a trapezium with width <span class="math inline">\(b-a\)</span> and parallel sides of length <span class="math inline">\(f(a)\)</span> and <span class="math inline">\(f(b)\)</span>. So
<span class="math display">\[
\int_a^b f(x) dx \approx \frac{1}{2}(f(a)+f(b))(b-a).
\]</span>
It can be shown that the local truncation error is bounded by
<span class="math display">\[
\frac{(b-a)^3 \sup_{x \in [a,b]}|f&#39;&#39;(x)|}{12}.
\]</span>
Now split <span class="math inline">\([a,b]\)</span> into <span class="math inline">\(N\)</span> small intervals. As before, for <span class="math inline">\(h=(b-a)/N\)</span>, let <span class="math inline">\(x_i = a + ih\)</span>, <span class="math inline">\(i=0, \dots, N\)</span>. Then
<span class="math display">\[
I \approx \frac{h}{2}\sum_{i=1}^N (f(x_{i-1})+f(x_{i}))= \frac{h}{2} \left ( f(a) + 2\sum_{i=1}^{N-1} f(x_i) + f(b) \right ).
\]</span>
This algorithm is of <span class="math inline">\(2^{nd}\)</span> order, the same order as the midpoint method.</p>
</div>
<div id="simpson" class="section level3 hasAnchor" number="10.1.4">
<h3><span class="header-section-number">10.1.4</span> Simpson’s rule<a href="ode.html#simpson" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Simpson’s rule approximates the area under the curve of the function <span class="math inline">\(f:[a,b] \to \mathbb{R}\)</span> by the area under a quadratic function which passes through the points <span class="math inline">\((a,f(a))\)</span>, <span class="math inline">\(((a+b)/2, f((a+b)/2))\)</span> and <span class="math inline">\((b,f(b))\)</span>. This quadratic is given by
<span class="math display">\[
q(x) = \frac{2}{(b-a)^2}\left ( (x-b)\left (x-\frac{a+b}{2} \right )f(a) - 2(x-a)(x-b)f\left (\frac{a+b}{2} \right ) + (x-a)\left (x-\frac{a+b}{2} \right )f(b)\right ).
\]</span>
Integrating this expression between <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> gives
<span class="math display">\[
\int_a^b f(x) dx \approx \int_a^b q(x) dx = \frac{b-a}{6}\left(f(a)+4f\left ( \frac{a+b}{2} \right )+ f(b)\right).
\]</span>
It can be shown that the local truncation error is bounded by
<span class="math display">\[
\frac{2(b-a)^5 \sup_{x \in [a,b]}|f^{(4)}(x)|}{45}.
\]</span>
Now split <span class="math inline">\([a,b]\)</span> into <span class="math inline">\(N\)</span> small intervals. As before, for <span class="math inline">\(h=(b-a)/N\)</span>, let <span class="math inline">\(x_i = a + ih\)</span>, <span class="math inline">\(i=0, \dots, N\)</span> and define the midpoints <span class="math inline">\(y_i=(x_{i-1}+x_i)/2 = a +(2i-1)h/2\)</span>. Then
<span class="math display">\[
I \approx \frac{h}{6}\sum_{i=1}^N (f(x_{i-1})+4f(y_i)+f(x_{i})) = \frac{h}{6} \left ( f(a) + 4 \sum_{i=1}^{N} f(y_i) + 2\sum_{i=1}^{N-1} f(x_i) + f(b)\right ).
\]</span>
This is a <span class="math inline">\(4^{th}\)</span> order algorithm, and so is the most accurate of those described above.</p>
<p>In all of these methods we have split <span class="math inline">\([a,b]\)</span> into equal sized intervals. This is not necessary, and in fact many algorithms have adaptive step sizes which use narrow intervals when the function has a steep gradient and wide step sizes when the function is flatter.</p>
</div>
</div>
<div id="ordinary-differential-equations" class="section level2 hasAnchor" number="10.2">
<h2><span class="header-section-number">10.2</span> Ordinary differential equations<a href="ode.html#ordinary-differential-equations" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Suppose now that we need to find <span class="math inline">\(y: [a,b] \to \mathbb{R}\)</span> satisfying the <em>ordinary differential equation (ODE)</em>
<span class="math display">\[\begin{equation}
\frac{dy}{dx} = f(x,y)
\end{equation}\]</span>
with initial condition <span class="math inline">\(y(a) = y_0\)</span>.</p>
<p>As before, the fundamental theorem of calculus tells us that <span class="math inline">\(y\)</span> satisfies
<span class="math display">\[\begin{equation}
y(x) = y_0 + \int_a^x f(t,y(t))dt.
\end{equation}\]</span>
However, as <span class="math inline">\(y\)</span> appears on both sides of the equation, this expression does not give us the function <span class="math inline">\(y(x)\)</span> explicitly. It merely allows us to verify whether a particular function <span class="math inline">\(y:[a,b] \to \mathbb{R}\)</span> is a solution.</p>
<p>Solving ODEs explicitly is generally difficult. In simple cases, for example when <span class="math inline">\(f\)</span> is a linear function of <span class="math inline">\(y\)</span>, methods exist. However, when tackling problems that arise from real-world applications it is often necessary to resort to numerical methods.</p>
<p>Here it becomes clear why a Monte Carlo method for numerical integration would be difficult to apply. In order to evaluate the function <span class="math inline">\(f(t,y(t)\)</span> for samples of <span class="math inline">\(t\)</span> in the interval <span class="math inline">\([a,x]\)</span>, we would need to know <span class="math inline">\(y(t)\)</span>, but we do not have an easy way to write an equation for <span class="math inline">\(y(t)\)</span> with random samples.</p>
<div id="existence-and-uniqueness" class="section level3 hasAnchor" number="10.2.1">
<h3><span class="header-section-number">10.2.1</span> Existence and uniqueness<a href="ode.html#existence-and-uniqueness" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Before we start to explore numerical methods for solving ODEs, it is worth asking whether a solution the equation exists at all, and if so whether it is unique.</p>
<p>Define a function <span class="math inline">\(F:C^0[a,b] \to C^0[a,b]\)</span> by
<span class="math display">\[
(F(g))(x) = y_0 + \int_{a}^x f(t,g(t)) dt.
\]</span>
This is a function on a space of functions i.e. <span class="math inline">\(F\)</span> maps a function <span class="math inline">\(g:[a,b] \to \mathbb{R}\)</span> to another function <span class="math inline">\(F(g) : [a,b] \to \mathbb{R}\)</span>, where <span class="math inline">\(F(g)\)</span> maps each <span class="math inline">\(x \in [a,b]\)</span> to the real value given by the formula for <span class="math inline">\((F(g))(x)\)</span> above.</p>
<p>Observe that <span class="math inline">\(y\)</span> is a solution of the ODE if and only if <span class="math inline">\(F(y)=y\)</span>. So solving the differential equation is equivalent to finding a fixed point for <span class="math inline">\(F\)</span>.</p>
<p>Suppose that <span class="math inline">\(f(t,x)\)</span> is a Lipschitz function in <span class="math inline">\(x\)</span> with a Lipschitz constant that doesn’t depend on <span class="math inline">\(t\)</span> i.e. there exists some <span class="math inline">\(K &gt; 0\)</span> such that, for all <span class="math inline">\(t \in [a,b]\)</span> and <span class="math inline">\(x_1, x_2 \in \mathbb{R}\)</span>,
<span class="math display">\[\begin{equation}
|f(t,x_1) - f(t,x_2)| \leq K|x_1-x_2|.
\end{equation}\]</span>
Then
<span class="math display">\[\begin{align*}
|(F(g_1))(x) - (F(g_2))(x)|
&amp;\leq \int_a^x |f(t,g_1(t))-f(t,g_2(t))| dt \\
&amp;\leq K \int_a^x |g_1(t)-g_2(t)| dt \\
&amp;\leq K(x-a)\|g_1-g_2\|_\infty.
\end{align*}\]</span>
Hence
<span class="math display">\[
\|F(g_1)-F(g_2)\|_\infty \leq K(b-a) \|g_1 - g_2\|_\infty.
\]</span>
It follows that <span class="math inline">\(F\)</span> is a contraction mapping on <span class="math inline">\(C^0[a,b]\)</span> if <span class="math inline">\(K(b-a) &lt; 1\)</span>.</p>
<p>A version of the Contraction Mapping Theorem exists for functions on <span class="math inline">\(C^0[a,b]\)</span>. If <span class="math inline">\(b-a &lt; 1/K\)</span>, one therefore gets that there exists a unique solution satisfying <span class="math inline">\(y(a)=y_0\)</span>.</p>
<p>If <span class="math inline">\(b-a \geq 1/K\)</span>, one still gets that <span class="math inline">\(F\)</span> has a unique fixed point but only by restricting to functions defined on the smaller interval <span class="math inline">\([a,\tilde{b}]\)</span> where <span class="math inline">\(\tilde{b}-a &lt; 1/K\)</span>. Taking <span class="math inline">\(\tilde{b}=a+1/(2K)\)</span>, there exists a unique <span class="math inline">\(y^0:[a,a+1/(2K)]\)</span> satisfying the equation with <span class="math inline">\(y^0(a)=y_0\)</span>. Let <span class="math inline">\(y_1 = y^0(a+1/(2K))\)</span>. An identical argument shows that there exists a unique <span class="math inline">\(y^1:[a+1/(2K), a+1/K]\)</span> satisfying the equation with <span class="math inline">\(y^1(a+1/(2K))=y_1\)</span>. Set
<span class="math display">\[
y(x) = \begin{cases}
y^0(x) \ \mbox{ if } \ x \in [a,a+1/(2K)] \\
y^1(x) \ \mbox{ if } \ x \in (a+1/(2K), a+ 1/K].
\end{cases}
\]</span>
Then <span class="math inline">\(y:[a,a+1/K] \to \mathbb{R}\)</span> is the unique solution to the equation with <span class="math inline">\(y(a)=y_0\)</span>. One can continue to extend the domain of <span class="math inline">\(y\)</span> in this way up to <span class="math inline">\([a,b]\)</span>.</p>
</div>
<div id="eulers-method" class="section level3 hasAnchor" number="10.2.2">
<h3><span class="header-section-number">10.2.2</span> Euler’s method<a href="ode.html#eulers-method" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>Euler’s method is a simple method for obtaining the solution to an ODE numerically. It is based on the <a href="ode.html#riemann">Riemann integration</a> method we discussed above.</p>
<p>Split <span class="math inline">\([a,b]\)</span> into <span class="math inline">\(N\)</span> smaller intervals, each with length <span class="math inline">\(h=(b-a)/N\)</span> and let <span class="math inline">\(x_i = a + ih\)</span>, <span class="math inline">\(i=0, \dots, N\)</span>. We recursively obtain approximations <span class="math inline">\(\hat{y}_i\)</span> to <span class="math inline">\(y(x_i)\)</span> using the Riemann approximation as follows.</p>
<ul>
<li>Set <span class="math inline">\(\hat{y}_0 = y_0 = y(x_0)\)</span>. (At this step, our approximation is exact).</li>
<li>By Riemann approximation,
<span class="math display">\[
y(x_1) = y_0 + \int_{x_{0}}^{x_1} f(t,y(t)) dt \approx y(x_0)+h f(x_0,y(x_0)) = \hat{y}_0 + h f(x_0,     \hat{y}_0).
\]</span>
Set <span class="math inline">\(\hat{y}_1 = \hat{y}_0+h f(x_0, \hat{y}_0)\)</span>.</li>
<li>By Riemann approximation,
<span class="math display">\[\begin{align*}
y(x_2) &amp;= y_0 + \int_{x_{0}}^{x_2} f(t,y(t)) dt \\
&amp;\approx y(x_0) + h \left ( f(x_0,y(x_0)) +     f(x_1,y(x_1))\right ) \\
&amp;\approx \hat{y}_0 + h \left ( f(x_0, \hat{y}_0) + f(x_1,         \hat{y}_1)\right ) \\
&amp;= \hat{y_1} + h f(x_1, \hat{y}_1).
\end{align*}\]</span>
Set <span class="math inline">\(\hat{y}_2 = \hat{y}_1 + h f(x_1, \hat{y}_1)\)</span>.</li>
<li>Continue in this way, at step <span class="math inline">\(i+1\)</span> setting
<span class="math display">\[
\hat{y}_{i+1} = \hat{y}_{i} + hf(x_i, \hat{y}_i).
\]</span></li>
</ul>
<div class="example">
<p><span id="exm:unnamed-chunk-321" class="example"><strong>Example 10.1  </strong></span>Consider the ODE
<span class="math display">\[
\frac{dy}{dx} = x \exp (2 x) - 3 y,  
\]</span>
for <span class="math inline">\(x \in [0,1]\)</span>, with initial condition <span class="math inline">\(y(0)=0\)</span>.</p>
<p>This ODE can be solved exactly using integrating factors to give
<span class="math display">\[
y(x) = \frac{5x-1}{25} \exp (2x) + \frac{1}{25}\exp(-3x),
\]</span>
(check this!), which provides an exact solution to compare our numerical solutions against.</p>
</div>
<p>We next code up Euler’s method:</p>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); grid-column-gap: 10px;">
<div>
<p><strong>R</strong></p>
<div class="sourceCode" id="cb932"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb932-1"><a href="ode.html#cb932-1" aria-hidden="true" tabindex="-1"></a><span class="co"># euler(f, a, b, y0, N) computes the vector hat_y which approximates the </span></span>
<span id="cb932-2"><a href="ode.html#cb932-2" aria-hidden="true" tabindex="-1"></a><span class="co"># solution to the ODE y&#39; = f(x,y) on [a,b] with initial condition y(a)=y0.</span></span>
<span id="cb932-3"><a href="ode.html#cb932-3" aria-hidden="true" tabindex="-1"></a><span class="co"># It uses step-size h=(b-a)/N so hat_y[i] approximates y(a + (i-1)h).</span></span>
<span id="cb932-4"><a href="ode.html#cb932-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb932-5"><a href="ode.html#cb932-5" aria-hidden="true" tabindex="-1"></a>euler <span class="ot">=</span> <span class="cf">function</span>(f, a, b, y0, N){</span>
<span id="cb932-6"><a href="ode.html#cb932-6" aria-hidden="true" tabindex="-1"></a>  h <span class="ot">=</span> (b<span class="sc">-</span>a)<span class="sc">/</span>N</span>
<span id="cb932-7"><a href="ode.html#cb932-7" aria-hidden="true" tabindex="-1"></a>  x_seq <span class="ot">=</span> <span class="fu">seq</span>(a, b, h)</span>
<span id="cb932-8"><a href="ode.html#cb932-8" aria-hidden="true" tabindex="-1"></a>  hat_y <span class="ot">=</span> <span class="fu">rep</span>(y0, N<span class="sc">+</span><span class="dv">1</span>)</span>
<span id="cb932-9"><a href="ode.html#cb932-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N){</span>
<span id="cb932-10"><a href="ode.html#cb932-10" aria-hidden="true" tabindex="-1"></a>    hat_y[i<span class="sc">+</span><span class="dv">1</span>] <span class="ot">=</span> hat_y[i] <span class="sc">+</span> h<span class="sc">*</span><span class="fu">f</span>(x_seq[i], hat_y[i])</span>
<span id="cb932-11"><a href="ode.html#cb932-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb932-12"><a href="ode.html#cb932-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">x=</span>x_seq, <span class="at">y=</span>hat_y))</span>
<span id="cb932-13"><a href="ode.html#cb932-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div>
<p><strong>Python</strong></p>
<div class="sourceCode" id="cb933"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb933-1"><a href="ode.html#cb933-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb933-2"><a href="ode.html#cb933-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> euler(f,a,b,y0,N):</span>
<span id="cb933-3"><a href="ode.html#cb933-3" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> (b<span class="op">-</span>a)<span class="op">/</span>N</span>
<span id="cb933-4"><a href="ode.html#cb933-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb933-5"><a href="ode.html#cb933-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">#from a to b in steps of h </span></span>
<span id="cb933-6"><a href="ode.html#cb933-6" aria-hidden="true" tabindex="-1"></a>    x_seq <span class="op">=</span> np.arange(a,b,h)</span>
<span id="cb933-7"><a href="ode.html#cb933-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb933-8"><a href="ode.html#cb933-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Initial value y0</span></span>
<span id="cb933-9"><a href="ode.html#cb933-9" aria-hidden="true" tabindex="-1"></a>    hat_y <span class="op">=</span> y0<span class="op">*</span>np.ones(N<span class="op">+</span><span class="dv">1</span>) <span class="co">#N+1 values </span></span>
<span id="cb933-10"><a href="ode.html#cb933-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb933-11"><a href="ode.html#cb933-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,N):</span>
<span id="cb933-12"><a href="ode.html#cb933-12" aria-hidden="true" tabindex="-1"></a>        hat_y[i<span class="op">+</span><span class="dv">1</span>] <span class="op">=</span> hat_y[i] <span class="op">+</span> h<span class="op">*</span>f(x_seq[i],hat_y[i])</span>
<span id="cb933-13"><a href="ode.html#cb933-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb933-14"><a href="ode.html#cb933-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x_seq,hat_y</span></code></pre></div>
</div>
</div>
<p>In order to solve the ODE above, we need to implement the Euler method with
<span class="math display">\[
f(x,y) = x \exp (2 x) - 3 y
\]</span>
We compare it with the exact solution, taking <span class="math inline">\(N=2\)</span>.</p>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); grid-column-gap: 10px;">
<div>
<p><strong>R</strong></p>
<div class="sourceCode" id="cb934"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb934-1"><a href="ode.html#cb934-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> <span class="cf">function</span>(x, y){</span>
<span id="cb934-2"><a href="ode.html#cb934-2" aria-hidden="true" tabindex="-1"></a>  x<span class="sc">*</span><span class="fu">exp</span>(<span class="dv">2</span><span class="sc">*</span>x) <span class="sc">-</span> <span class="dv">3</span><span class="sc">*</span>y</span>
<span id="cb934-3"><a href="ode.html#cb934-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb934-4"><a href="ode.html#cb934-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb934-5"><a href="ode.html#cb934-5" aria-hidden="true" tabindex="-1"></a>yexact <span class="ot">=</span> <span class="cf">function</span>(x){</span>
<span id="cb934-6"><a href="ode.html#cb934-6" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">5</span><span class="sc">*</span>x <span class="sc">-</span> <span class="dv">1</span>)<span class="sc">*</span><span class="fu">exp</span>(<span class="dv">2</span><span class="sc">*</span>x)<span class="sc">/</span><span class="dv">25</span> <span class="sc">+</span> <span class="fu">exp</span>(<span class="sc">-</span><span class="dv">3</span><span class="sc">*</span>x)<span class="sc">/</span><span class="dv">25</span></span>
<span id="cb934-7"><a href="ode.html#cb934-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb934-8"><a href="ode.html#cb934-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb934-9"><a href="ode.html#cb934-9" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">euler</span>(f, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">2</span>))</span></code></pre></div>
<pre><code>## $x
## [1] 0.0 0.5 1.0
## 
## $y
## [1] 0.0000000 0.0000000 0.6795705</code></pre>
<div class="sourceCode" id="cb936"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb936-1"><a href="ode.html#cb936-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">yexact</span>(<span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">1</span>)))</span></code></pre></div>
<pre><code>## [1] 0.0000000 0.1720221 1.1842405</code></pre>
</div>
<div>
<p><strong>Python</strong></p>
<div class="sourceCode" id="cb938"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb938-1"><a href="ode.html#cb938-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> f(x,y):</span>
<span id="cb938-2"><a href="ode.html#cb938-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">*</span>np.exp(<span class="dv">2</span><span class="op">*</span>x) <span class="op">-</span> <span class="dv">3</span><span class="op">*</span>y</span>
<span id="cb938-3"><a href="ode.html#cb938-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb938-4"><a href="ode.html#cb938-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> yexact(x):</span>
<span id="cb938-5"><a href="ode.html#cb938-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (<span class="dv">5</span><span class="op">*</span>x<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>np.exp(<span class="dv">2</span><span class="op">*</span>x)<span class="op">/</span><span class="dv">25</span> <span class="op">+</span> np.exp(<span class="op">-</span><span class="dv">3</span><span class="op">*</span>x)<span class="op">/</span><span class="dv">25</span></span>
<span id="cb938-6"><a href="ode.html#cb938-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb938-7"><a href="ode.html#cb938-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(euler(f,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">2</span>))</span></code></pre></div>
<pre><code>## (array([0. , 0.5]), array([0.        , 0.        , 0.67957046]))</code></pre>
<div class="sourceCode" id="cb940"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb940-1"><a href="ode.html#cb940-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>([yexact(x) <span class="cf">for</span> x <span class="kw">in</span> [<span class="dv">0</span>,<span class="fl">0.5</span>,<span class="dv">1</span>]])</span></code></pre></div>
<pre><code>## [0.0, 0.1720221161134799, 1.1842404585636186]</code></pre>
</div>
</div>
<p>As expected, <span class="math inline">\(N=2\)</span> performs badly. The graph below shows that the approximation is more reasonable when taking <span class="math inline">\(N=10\)</span>.</p>
<p><img src="images/unnamed-chunk-326-1.png" width="50%" /></p>
<p>In real-world applications there is often a trade-off between accuracy, complexity, robustness and stability. When deciding between algorithms, and the values of parameters such as the step size, one should always take into consideration what is important for that particular application. Is it essential that it is fast, or is it more important that it is accurate? Do you need to ensure it is stable for many different inputs, or does it just need to work for one specific set of parameters? There is very rarely a single perfect way to do things, but there are lots of ways to do things badly!</p>
</div>
</div>
<div id="higher-order-methods" class="section level2 hasAnchor" number="10.3">
<h2><span class="header-section-number">10.3</span> Higher order methods<a href="ode.html#higher-order-methods" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Euler’s method is an order 1 method for solving ODEs numerically, based on the order 1 <a href="ode.html#riemann">Riemann integration</a> method for doing numerical integration. The low accuracy and poor stability that we saw above means that the Euler method is not used much in practice for solving ODEs. However, we can obtain higher order methods for solving ODEs, by basing them on the corresponding higher order methods for doing numerical integration.</p>
<div id="midpoint-method" class="section level3 hasAnchor" number="10.3.1">
<h3><span class="header-section-number">10.3.1</span> Midpoint method<a href="ode.html#midpoint-method" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The midpoint method is a modification of the Euler method based on the <a href="ode.html#midpoint">midpoint rule</a>. As before, split <span class="math inline">\([a,b]\)</span> into <span class="math inline">\(N\)</span> smaller intervals, each with length <span class="math inline">\(h=(b-a)/N\)</span>. Let <span class="math inline">\(x_i = a + ih\)</span>, <span class="math inline">\(i=0, \dots, N\)</span>, and <span class="math inline">\(t_i=(x_{i-1}+x_i)/2 = a + (2i-1)h/2\)</span> for <span class="math inline">\(i=1, \dots N\)</span>. We would like to recursively obtain approximations <span class="math inline">\(\hat{y}_i\)</span> to <span class="math inline">\(y(x_i)\)</span> using the midpoint rule approximation in the same way as we did for the Euler rule i.e.</p>
<ul>
<li>Set <span class="math inline">\(\hat{y}_0 = y_0 = y(x_0)\)</span>.</li>
<li>By the midpoint rule,
<span class="math display" id="eq:partmid">\[\begin{equation}
y(x_1) = y_0 + \int_{x_{0}}^{x_1} f(t,y(t)) dt \approx y(x_0)+h f(t_1,y(t_1)).   \tag{10.1}
\end{equation}\]</span></li>
</ul>
<p>The trouble is that this time we don’t already have an approximation for <span class="math inline">\(y(t_1)\)</span>. We therefore use the standard Euler method (with step-size <span class="math inline">\(h/2\)</span>) to approximate
<span class="math inline">\(y(t_1) \approx \hat{y}_0 + h f(x_0, \hat{y}_0)/2 = w_1\)</span>. We then substitute this to get
<span class="math display">\[
\hat{y}_1 = \hat{y}_0 + hf\left (t_1, w_1 \right ).
\]</span></p>
<p>Even though it this methods requires two computations at each step, where Euler’s method only needed one, the error decreases much faster as <span class="math inline">\(h \to 0\)</span>, so fewer steps are needed to achieve the same accuracy.</p>
</div>
<div id="modified-euler-method" class="section level3 hasAnchor" number="10.3.2">
<h3><span class="header-section-number">10.3.2</span> Modified Euler method<a href="ode.html#modified-euler-method" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The modified Euler method (also called Heun’s method) is based on the <a href="ode.html#trapezium">Trapezium rule</a>. We would like to approximate <span class="math inline">\(y(x_1)\)</span> by
<span class="math display" id="eq:parttrap">\[\begin{equation}
  y(x_1) = y_0 + \int_{x_{0}}^{x_1} f(t,y(t)) dt \approx y(x_0)+\frac{h}{2} \left ( f(x_0,y(x_0)) + f(x_1,y(x_1)) \right )   \tag{10.2}
  \end{equation}\]</span>
but, as with the midpoint rule, we don’t already have an approximation for <span class="math inline">\(y(x_1)\)</span>. We therefore use the standard Euler method to approximate
<span class="math inline">\(y(x_1) \approx \hat{y}_0 + h f(x_0, \hat{y}_0) = \tilde{y}_1\)</span> and substitute this to get
<span class="math display">\[
\hat{y}_1 = \hat{y}_0 + \frac{h}{2}\left ( f(x_0, \hat{y}_0) +  f(x_1, \tilde{y}_1 ) \right ).
\]</span></p>
<p>This is also an order 2 method.</p>
</div>
<div id="runge-kutta-methods" class="section level3 hasAnchor" number="10.3.3">
<h3><span class="header-section-number">10.3.3</span> Runge-Kutta methods<a href="ode.html#runge-kutta-methods" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The Runge-Kutta method of order 4 (often referred to as “RK4”) is a <span class="math inline">\(4^{th}\)</span> order method. Because of its high accuracy it is one of the most commonly used methods for numerically solving ODEs. It is based on <a href="ode.html#simpson">Simpson’s Rule</a> which
approximates <span class="math inline">\(y(x_1)\)</span> by
<span class="math display">\[
  y(x_1) = y_0 + \int_{x_{0}}^{x_1} f(t,y(t)) dt \approx y(x_0)+\frac{h}{6} \left ( f(x_0,y(x_0)) +4f(t_1, y(t_1))+ f(x_1,y(x_1)) \right ).     
  \]</span></p>
<p>The usual notation when implementing RK4 is:
Note that</p>
<ul>
<li><span class="math inline">\(K_1 = hf(x_i, \hat{y}_i) \approx hf(x_{i}, y(x_i))\)</span>.</li>
<li><span class="math inline">\(K_2 = hf(x_i+h/2, \hat{y}_i+K_1/2) \approx hf(t_i, y(t_i))\)</span>, using the left-point Riemann estimate
<span class="math display">\[
y(t_i) \approx y(x_i) + \frac{h}{2}f(x_i, y(x_i)).
\]</span></li>
<li><span class="math inline">\(K_3 = hf(x_i+h/2, \hat{y}_i+K_2/2) \approx hf(t_i, y(t_i))\)</span>, using the right-point Riemann estimate
<span class="math display">\[
y(t_i) \approx y(x_i) + \frac{h}{2}f(t_i, y(t_i)).
\]</span></li>
<li><span class="math inline">\(K_4 = hf(x_i + h, \hat{y}_i + K_3) \approx hf(x_{i+1}, y(x_{i+1}))\)</span>, using the mid-point Riemann estimate
<span class="math display">\[
y(x_{i+1})\approx y(x_i) + hf(t_i, y(t_i)).
\]</span></li>
</ul>
<p>Therefore,
<span class="math display">\[\begin{align*}
\hat{y}_{i+1} &amp;= \hat{y}_i + \frac{1}{6}(K_1 + 2K_2 + 2K_3 + K_4) \\
&amp;\approx y(x_i) + \frac{h}{6}(f(x_i, y(x_i)) + 4f(t_i,y(t_i)) + f(x_{i+1},y(x_{i+1}))),
\end{align*}\]</span>
which is exactly Simpson’s rule.</p>
</div>
</div>
<div id="systems-of-odes" class="section level2 hasAnchor" number="10.4">
<h2><span class="header-section-number">10.4</span> Systems of ODEs<a href="ode.html#systems-of-odes" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Often we want to solve a <em>system</em> of differential equations of the form
<span class="math display">\[\begin{align*}
\frac{d x_1}{dt} &amp;= f_1(t, x_1, \dots, x_k) \\
\frac{d x_2}{dt} &amp;= f_2(t, x_1, \dots, x_k) \\
\vdots \\
\frac{d x_k}{dt} &amp;= f_k(t, x_1, \dots, x_k)
\end{align*}\]</span>
for <span class="math inline">\(t \in [a,b]\)</span> with initial condition <span class="math inline">\((x_1 (a), x_2 (a), \dots, x_k(a)) =(x_{0,1}, x_{0,2}, \dots, x_{0,k})\)</span>.</p>
<p>We can write this in vector notation as
<span class="math display">\[
\frac{d \mathbf{x}}{dt} = \mathbf{f}(t, \mathbf{x})
\]</span>
for <span class="math inline">\(t \in [a,b]\)</span> with initial condition <span class="math inline">\(\mathbf{x}(a) = \mathbf{x_0}\)</span>. Here <span class="math inline">\(\mathbf{x}: [a,b] \to \mathbb{R}^k\)</span> and <span class="math inline">\(\mathbf{f}:[a,b] \times \mathbb{R}^k \to \mathbb{R}^k\)</span>.</p>
<div class="remark">
<p><span id="unlabeled-div-1" class="remark"><em>Remark</em>. </span>We have changed notation in this section to using <span class="math inline">\(t\)</span> as the <em>independent variable</em> and <span class="math inline">\(x_1, \dots, x_k\)</span> as the <em>dependent variables</em>. The reason for this is that systems of ODEs often originate as physical models in which the independent variable is time, and the dependant variables represent spatial coordinates. In 2-dimensions, we will usually use <span class="math inline">\((x,y)\)</span> in place of <span class="math inline">\((x_1, x_2)\)</span>, and in 3-dimensions we will usually use <span class="math inline">\((x,y,z)\)</span>.</p>
</div>
<p>Similar conditions to those in the 1-dimensional case are needed to ensure the existence and uniqueness of solutions to the ODE, namely for each <span class="math inline">\(i=1, \dots, k\)</span>, there exists some <span class="math inline">\(K&lt;\infty\)</span> such that for all <span class="math inline">\(t \in [a,b]\)</span>,
<span class="math display">\[
|f_i(t,x_1^1, \dots, x_k^1) - f_i(t,x_1^2, \dots, x_k^2)| \leq K\left (|x^1_1 - x^2_1| + \cdots + |x_k^1 - x_k^2| \right ).
\]</span>
We can write an equivalent statement using vector notation:
<span class="math display">\[
\|\mathbf{f}(t, \mathbf{x}_1) - \mathbf{f}(t, \mathbf{x}_2)\|_1 \leq K \|\mathbf{x}_1 - \mathbf{x}_2\|_1,
\]</span>
where <span class="math inline">\(\|\mathbf{x}\|_1 = |x_1| + \cdots + |x_k|\)</span> for any <span class="math inline">\(\mathbf{x}=(x_1, \dots, x_k) \in \mathbb{R}^k\)</span>.</p>
<p>Exactly the same numerical schemes as in the 1-dimensional case can be used. For example, with the Euler method, the step becomes
<span class="math display">\[
\hat{\mathbf{x}}_{n+1} = \hat{\mathbf{x}}_n + h \mathbf{f}(t_n, \hat{\mathbf{x}}_n),
\]</span>
where now (reflecting the change of notation) <span class="math inline">\(t_i = a + ih\)</span> for <span class="math inline">\(i=0, \dots, N\)</span>.</p>
<p>One can use systems of differential equations to obtain numerical solutions to higher order differential equations. We illustrate the approach with the following example.</p>
<div class="example">
<p><span id="exm:unnamed-chunk-328" class="example"><strong>Example 10.2  </strong></span>The vertical displacement of a mass on a spring satisfies simple harmonic motion
if it is given by the solution to the <span class="math inline">\(2^{nd}\)</span> order differential equation
<span class="math display">\[
\frac{d^2x}{dt^2} + \omega^2 x = 0.
\]</span>
Here, we call <span class="math inline">\(\omega\)</span> the angular frequency. We shall use the midpoint method to obtain a numerical approximation to <span class="math inline">\(x(t)\)</span> when <span class="math inline">\(\omega=1\)</span>, for <span class="math inline">\(t \in [0,2 \pi]\)</span>, with initial conditions <span class="math inline">\(x(0)=0\)</span>, <span class="math inline">\(\frac{dx}{dt}(0) = 1\)</span>.</p>
<p>We can solve this particular ODE explicitly to get
<span class="math display">\[
x(t) = \sin(t).
\]</span>
This enables us to evaluate the accuracy of our numerical solution.</p>
</div>
<p>Set <span class="math inline">\(y = \frac{dx}{dt}\)</span>. Then <span class="math inline">\((x,y)\)</span> satisfies the following system of first order differential equations
<span class="math display">\[\begin{align*}
\frac{dx}{dt} &amp;= y \\
\frac{dy}{dt} &amp;= -x
\end{align*}\]</span>
with initial condition <span class="math inline">\((x(0),y(0))=(0,1)\)</span>. So in this case <span class="math inline">\(\mathbf{f}(t,x,y) = (y,-x)\)</span>. We code-up a version of the midpoint method which works with vectors and use it to solve the ODE.</p>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); grid-column-gap: 10px;">
<div>
<p><strong>R</strong></p>
<div class="sourceCode" id="cb942"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb942-1"><a href="ode.html#cb942-1" aria-hidden="true" tabindex="-1"></a><span class="co"># midpoint_system(f, a, b, x0, N) computes the matrix hat_x which approximates</span></span>
<span id="cb942-2"><a href="ode.html#cb942-2" aria-hidden="true" tabindex="-1"></a><span class="co"># the solution to the ODE x&#39; = f(t,x) on [a,b] with initial condition x(a)=x0.</span></span>
<span id="cb942-3"><a href="ode.html#cb942-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Here t is a scalar in [a,b] and x is a vector with the same dimension as f.</span></span>
<span id="cb942-4"><a href="ode.html#cb942-4" aria-hidden="true" tabindex="-1"></a><span class="co"># It uses step-size h=(b-a)/N so hat_x[i,] approximates x(a + (i-1)h).</span></span>
<span id="cb942-5"><a href="ode.html#cb942-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb942-6"><a href="ode.html#cb942-6" aria-hidden="true" tabindex="-1"></a>midpoint_system <span class="ot">=</span> <span class="cf">function</span>(f, a, b, x0, N){</span>
<span id="cb942-7"><a href="ode.html#cb942-7" aria-hidden="true" tabindex="-1"></a>  h <span class="ot">=</span> (b<span class="sc">-</span>a)<span class="sc">/</span>N</span>
<span id="cb942-8"><a href="ode.html#cb942-8" aria-hidden="true" tabindex="-1"></a>  time_seq <span class="ot">=</span> <span class="fu">seq</span>(a, b, h)</span>
<span id="cb942-9"><a href="ode.html#cb942-9" aria-hidden="true" tabindex="-1"></a>  hat_x <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="at">ncol =</span> <span class="fu">length</span>(x0), <span class="at">nrow =</span> (N<span class="sc">+</span><span class="dv">1</span>))</span>
<span id="cb942-10"><a href="ode.html#cb942-10" aria-hidden="true" tabindex="-1"></a>  hat_x[<span class="dv">1</span>,] <span class="ot">=</span> x0</span>
<span id="cb942-11"><a href="ode.html#cb942-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>N){</span>
<span id="cb942-12"><a href="ode.html#cb942-12" aria-hidden="true" tabindex="-1"></a>    w <span class="ot">=</span> hat_x[i,] <span class="sc">+</span> h<span class="sc">*</span><span class="fu">f</span>(time_seq[i], hat_x[i,])<span class="sc">/</span><span class="dv">2</span></span>
<span id="cb942-13"><a href="ode.html#cb942-13" aria-hidden="true" tabindex="-1"></a>    hat_x[i<span class="sc">+</span><span class="dv">1</span>,] <span class="ot">=</span> hat_x[i,] <span class="sc">+</span> h<span class="sc">*</span><span class="fu">f</span>(time_seq[i]<span class="sc">+</span>h<span class="sc">/</span><span class="dv">2</span>, w)</span>
<span id="cb942-14"><a href="ode.html#cb942-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb942-15"><a href="ode.html#cb942-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">t=</span>time_seq, <span class="at">x=</span>hat_x))</span>
<span id="cb942-16"><a href="ode.html#cb942-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb942-17"><a href="ode.html#cb942-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb942-18"><a href="ode.html#cb942-18" aria-hidden="true" tabindex="-1"></a><span class="co"># In this function, t is a scalar and x is a 2-dimensional vector</span></span>
<span id="cb942-19"><a href="ode.html#cb942-19" aria-hidden="true" tabindex="-1"></a>simple_harmonic_f <span class="ot">=</span> <span class="cf">function</span>(t,x){</span>
<span id="cb942-20"><a href="ode.html#cb942-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">c</span>(x[<span class="dv">2</span>],<span class="sc">-</span>x[<span class="dv">1</span>])</span>
<span id="cb942-21"><a href="ode.html#cb942-21" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb942-22"><a href="ode.html#cb942-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb942-23"><a href="ode.html#cb942-23" aria-hidden="true" tabindex="-1"></a>sol <span class="ot">=</span> <span class="fu">midpoint_system</span>(simple_harmonic_f, <span class="dv">0</span>, <span class="dv">2</span><span class="sc">*</span>pi, <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="dv">20</span>)</span></code></pre></div>
</div>
<div>
<p><strong>Python</strong></p>
<div class="sourceCode" id="cb943"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb943-1"><a href="ode.html#cb943-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> midpoint_system(f, a, b, x0, N):</span>
<span id="cb943-2"><a href="ode.html#cb943-2" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> (b<span class="op">-</span>a)<span class="op">/</span>N</span>
<span id="cb943-3"><a href="ode.html#cb943-3" aria-hidden="true" tabindex="-1"></a>    time_seq <span class="op">=</span> np.arange(a, b, h)</span>
<span id="cb943-4"><a href="ode.html#cb943-4" aria-hidden="true" tabindex="-1"></a>    hat_x <span class="op">=</span> np.zeros( (N<span class="op">+</span><span class="dv">1</span>,<span class="bu">len</span>(x0)) )</span>
<span id="cb943-5"><a href="ode.html#cb943-5" aria-hidden="true" tabindex="-1"></a>    hat_x[<span class="dv">0</span>,:] <span class="op">=</span> x0</span>
<span id="cb943-6"><a href="ode.html#cb943-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,N):</span>
<span id="cb943-7"><a href="ode.html#cb943-7" aria-hidden="true" tabindex="-1"></a>        w <span class="op">=</span> hat_x[i,:] <span class="op">+</span> h<span class="op">*</span>f(time_seq[i], hat_x[i,:])<span class="op">/</span><span class="dv">2</span></span>
<span id="cb943-8"><a href="ode.html#cb943-8" aria-hidden="true" tabindex="-1"></a>        hat_x[i<span class="op">+</span><span class="dv">1</span>,:] <span class="op">=</span> hat_x[i,:] <span class="op">+</span> h<span class="op">*</span>f(time_seq[i]<span class="op">+</span>h<span class="op">/</span><span class="dv">2</span>, w)</span>
<span id="cb943-9"><a href="ode.html#cb943-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-10"><a href="ode.html#cb943-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> time_seq,x</span>
<span id="cb943-11"><a href="ode.html#cb943-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-12"><a href="ode.html#cb943-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> simple_harmonic_f(t,x):</span>
<span id="cb943-13"><a href="ode.html#cb943-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array((x[<span class="dv">1</span>],<span class="op">-</span>x[<span class="dv">0</span>]))</span>
<span id="cb943-14"><a href="ode.html#cb943-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-15"><a href="ode.html#cb943-15" aria-hidden="true" tabindex="-1"></a>sol <span class="op">=</span> midpoint_system(simple_harmonic_f, <span class="dv">0</span>, <span class="dv">2</span><span class="op">*</span>np.pi, np.arange(<span class="dv">2</span>), <span class="dv">20</span>)</span></code></pre></div>
</div>
</div>
<p>Here is a plot of the solution:</p>
<p><img src="images/unnamed-chunk-331-1.png" width="50%" /></p>
</div>
<div id="examples-1" class="section level2 hasAnchor" number="10.5">
<h2><span class="header-section-number">10.5</span> Examples<a href="ode.html#examples-1" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The examples we have seen so far have been ODEs with analytical solutions.
However, the real power of numerical methods for solving ODEs is for systems of
equations which do not permit analytical solutions. In this section we finish
with some examples of systems of ODEs which arise from modelling real-world
scenarios. It is here that we really start to see some of the dramatic effects
of instabilities.</p>
<div id="sir-epidemic-model" class="section level3 hasAnchor" number="10.5.1">
<h3><span class="header-section-number">10.5.1</span> SIR epidemic model<a href="ode.html#sir-epidemic-model" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The SIR epidemic model is the most studied mathematical model for epidemics.
At any point in time, the population splits into three categories:</p>
<ul>
<li>Susceptible (S): individuals who have not yet encountered the disease;</li>
<li>Infective (I): individuals who have the disease and are infectious;</li>
<li>Removed (R): individuals who have previously had the disease and have either recovered (and are now immune to further infection), or have died.</li>
</ul>
<p>The model assumes that individuals in the Susceptible category can potentially become infected with the disease by interacting with Infectives at which point they move into the Infective category. Infectives remain infectious for some period of time, the infectious period, before moving into the Removed category by recovering or dying. Once an individual is in the Removed category, they remain there indefinitely. To further simplify, it is assumed that nobody enters or leaves the population during the course of the epidemic. Therefore, if <span class="math inline">\((S(t), I(t), R(t))\)</span> denotes the number of individuals in each category,
<span class="math display">\[
S(t)+I(t)+R(t)=S(0)+I(0)+R(0) = N_0
\]</span>
for all <span class="math inline">\(t \geq 0\)</span>.</p>
<p>Both deterministic and stochastic (random) versions of the model exist. We will focus on the former here.
Let
<span class="math display">\[
(x(t), y(t), z(t)) = (S(t), I(t),R(t))/N_0
\]</span>
denote the density of susceptible, infective and removed individuals at time <span class="math inline">\(t\)</span>, respectively. Since
<span class="math display">\[
x(t)+y(t)+z(t) = x(0)+y(0)+z(0)=1,
\]</span>
one can easily recover <span class="math inline">\(z(t)\)</span> from <span class="math inline">\(x(t)\)</span> and <span class="math inline">\(y(t)\)</span> by
<span class="math display">\[ z(t) = 1- x(t) -y(t). \]</span> Therefore we only need to keep track of the proportions of susceptibles and infectives in the population.</p>
<p>For the deterministic model, We assume that <span class="math inline">\(N_0\)</span> is so large that <span class="math inline">\(x(t),y(t),z(t)\)</span> can be viewed as real valued functions.
For the disease to spread we require infectives to make contact and pass the disease on to susceptibles. Suppose that individuals make contact at rate <span class="math inline">\(\beta\)</span>. The contact rate between infectives and susceptibles at time <span class="math inline">\(t\)</span> is then
<span class="math display">\[ \beta \times y (t) \times x(t). \]</span>
This increases the proportion of the population infected whilst decreasing the proportion of the population susceptible.
Infective individuals are assumed to recover from the disease at rate <span class="math inline">\(\gamma\)</span>, thus the rate at which recoveries are taking place at time <span class="math inline">\(t\)</span> is <span class="math inline">\(\gamma y(t)\)</span>. Therefore <span class="math inline">\((x(t),y(t))\)</span> solve the following ODE system:
<span class="math display">\[\begin{align*}
\frac{dx}{dt} &amp;= - \beta x y =f_1 (t, x,y) \\  
\frac{dy}{dt} &amp;= \beta x y - \gamma y = f_2 (t, x,y).
\end{align*}\]</span></p>
<p>These equations are simple to write down and interpret but have no analytical solution, hence the need to use numerical methods.</p>
</div>
<div id="predator-prey-model" class="section level3 hasAnchor" number="10.5.2">
<h3><span class="header-section-number">10.5.2</span> Predator-prey model<a href="ode.html#predator-prey-model" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The predator-prey model is also known as the Lotka-Volterra model, after Alfred Lotka and Vito Volterra who introduced and first analysed the model. The model equations appear similar to the SIR epidemic model described above but generate rather different dynamics. Again no analytic solution exists.</p>
<p>The motivation for the model is as follows. There are two types of individuals prey (rabbits) and predators (foxes). (Other prey-predator combinations are also used in the literature.) Let <span class="math inline">\(x(t)\)</span> and <span class="math inline">\(y(t)\)</span> denote the density of prey and predators, respectively, at time <span class="math inline">\(t\)</span>. The model assumptions are as follows.</p>
<ul>
<li>There is ample food for the prey and in the absence of predators the prey population grows exponentially. That is, the birth rate of new prey at time <span class="math inline">\(t\)</span> is <span class="math inline">\(\alpha x(t)\)</span> for some parameter <span class="math inline">\(\alpha\)</span>.</li>
<li>The predator lives exclusively on the prey so that its birth rate is related to prey numbers. Therefore the birth rate of new predators at time <span class="math inline">\(t\)</span> is <span class="math inline">\(\delta x(t) y(t)\)</span> for some parameter <span class="math inline">\(\delta\)</span>.
Given that the predator eats the prey, the prey density decreases at rate <span class="math inline">\(\beta x(t) y(t)\)</span> through the prey being eaten for some parameter <span class="math inline">\(\beta\)</span>.</li>
<li>Finally, the predators have a finite lifetime and die at rate <span class="math inline">\(\gamma\)</span> and hence the predator density decreases at rate <span class="math inline">\(\gamma y(t)\)</span>.</li>
</ul>
<p>Note that often the simplifying assumption <span class="math inline">\(\delta =\beta\)</span> is made. This corresponds to a one-to-one replacement of prey by predators.</p>
<p>This gives the Lotka-Volterra ODE system
<span class="math display">\[\begin{align*}
\frac{dx}{dt} &amp;= \alpha x - \beta x y \\
\frac{dy}{dt} &amp;= \delta x y - \gamma y.
\end{align*}\]</span>
Note that if <span class="math inline">\(\alpha =0\)</span> and <span class="math inline">\(\delta =\beta\)</span>, we recover the SIR epidemic model.</p>
<p>We can use our <code>midpoint_system</code> function to solve the Lotka-Volterra system for different choices of parameters. The Runge-Kutta (RK4) method is more accurate. We leave it as an exercise to adapt this program to use RK4.</p>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); grid-column-gap: 10px;">
<div>
<p><strong>R</strong></p>
<div class="sourceCode" id="cb944"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb944-1"><a href="ode.html#cb944-1" aria-hidden="true" tabindex="-1"></a><span class="co"># lotka_volterra(alpha, beta, gamma, delta, initial, time, steps)</span></span>
<span id="cb944-2"><a href="ode.html#cb944-2" aria-hidden="true" tabindex="-1"></a><span class="co"># obtains a numerical solution to the Lotka Volterra equations </span></span>
<span id="cb944-3"><a href="ode.html#cb944-3" aria-hidden="true" tabindex="-1"></a><span class="co"># with given parameters alpha, beta, gamma and delta on the interval</span></span>
<span id="cb944-4"><a href="ode.html#cb944-4" aria-hidden="true" tabindex="-1"></a><span class="co"># [0, time] with initial values given by the 2-dimensional vector initial.</span></span>
<span id="cb944-5"><a href="ode.html#cb944-5" aria-hidden="true" tabindex="-1"></a><span class="co"># steps specifies the number of steps to use in the midpoint method.</span></span>
<span id="cb944-6"><a href="ode.html#cb944-6" aria-hidden="true" tabindex="-1"></a><span class="co"># lotka_volterra(0, 1.5, 1, 1.5, c(0.99,0.01), 0.2, 2)$x[,1] gives the answer</span></span>
<span id="cb944-7"><a href="ode.html#cb944-7" aria-hidden="true" tabindex="-1"></a><span class="co"># c(0.9900000, 0.9884801, 0.9868876)</span></span>
<span id="cb944-8"><a href="ode.html#cb944-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb944-9"><a href="ode.html#cb944-9" aria-hidden="true" tabindex="-1"></a>lotka_volterra <span class="ot">=</span> <span class="cf">function</span>(alpha, beta, gamma, delta, initial, time, steps){</span>
<span id="cb944-10"><a href="ode.html#cb944-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># lv_f is the right-hand side in the Lotka-Volterra ODE </span></span>
<span id="cb944-11"><a href="ode.html#cb944-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># t is a scalar and doesn&#39;t explicitly appear as it is time-homogeneous</span></span>
<span id="cb944-12"><a href="ode.html#cb944-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># x is a 2-dimensional vector</span></span>
<span id="cb944-13"><a href="ode.html#cb944-13" aria-hidden="true" tabindex="-1"></a>  lv_f <span class="ot">=</span> <span class="cf">function</span>(t,x){</span>
<span id="cb944-14"><a href="ode.html#cb944-14" aria-hidden="true" tabindex="-1"></a>    f1 <span class="ot">=</span> alpha<span class="sc">*</span>x[<span class="dv">1</span>] <span class="sc">-</span> beta<span class="sc">*</span>x[<span class="dv">1</span>]<span class="sc">*</span>x[<span class="dv">2</span>]</span>
<span id="cb944-15"><a href="ode.html#cb944-15" aria-hidden="true" tabindex="-1"></a>    f2 <span class="ot">=</span> delta<span class="sc">*</span>x[<span class="dv">1</span>]<span class="sc">*</span>x[<span class="dv">2</span>] <span class="sc">-</span> gamma<span class="sc">*</span>x[<span class="dv">2</span>]</span>
<span id="cb944-16"><a href="ode.html#cb944-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="fu">c</span>(f1,f2))</span>
<span id="cb944-17"><a href="ode.html#cb944-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb944-18"><a href="ode.html#cb944-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">midpoint_system</span>(lv_f, <span class="dv">0</span>, time, initial, steps))</span>
<span id="cb944-19"><a href="ode.html#cb944-19" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div>
<p><strong>Python</strong></p>
<div class="sourceCode" id="cb945"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb945-1"><a href="ode.html#cb945-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lotka_volterra(alpha, beta, gamma, delta, initial, time, steps):</span>
<span id="cb945-2"><a href="ode.html#cb945-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> lv_f(t,x):</span>
<span id="cb945-3"><a href="ode.html#cb945-3" aria-hidden="true" tabindex="-1"></a>        f1 <span class="op">=</span> alpha<span class="op">*</span>x[<span class="dv">0</span>] <span class="op">-</span> beta<span class="op">*</span>x[<span class="dv">0</span>]<span class="op">*</span>x[<span class="dv">1</span>]</span>
<span id="cb945-4"><a href="ode.html#cb945-4" aria-hidden="true" tabindex="-1"></a>        f2 <span class="op">=</span> delta<span class="op">*</span>x[<span class="dv">0</span>]<span class="op">*</span>x[<span class="dv">1</span>] <span class="op">-</span> gamma<span class="op">*</span>x[<span class="dv">1</span>]</span>
<span id="cb945-5"><a href="ode.html#cb945-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.array([f1,f2])</span>
<span id="cb945-6"><a href="ode.html#cb945-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb945-7"><a href="ode.html#cb945-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> midpoint_system(lv_f, <span class="dv">0</span>, time, initial, steps)</span></code></pre></div>
</div>
</div>
<p>Suppose that the initial densities of prey and predator are <span class="math inline">\(x_0 =70\)</span> and <span class="math inline">\(y_0 =80\)</span> and that the parameters are <span class="math inline">\(\alpha =1\)</span>, <span class="math inline">\(\beta =0.01\)</span>, <span class="math inline">\(\gamma =0.6\)</span> and <span class="math inline">\(\delta =0.005\)</span>. We estimate the trajectory of prey and predator over the time interval <span class="math inline">\([0,20]\)</span> using <span class="math inline">\(N=200\)</span> steps (<span class="math inline">\(h=0.1\)</span> step size) with the midpoint method and plot the results.</p>
<p><img src="images/unnamed-chunk-334-1.png" width="50%" /></p>
<p>Observe how the densities of predators and prey follow a periodic pattern. One can plot the number of predators against the number of prey so better understand the relationship between the two populations.</p>
<p><img src="images/unnamed-chunk-335-1.png" width="50%" /></p>
<p>We call this shape of trajectory a <em>periodic orbit</em>.
We can plot <span class="math inline">\(y(t)\)</span> against <span class="math inline">\(x(t)\)</span> for several different starting points. This is called a <em>phase portrait</em>. We illustrate this, taking <span class="math inline">\((x_0, y_0) = (120,100), (100,50)\)</span> and <span class="math inline">\((100,80)\)</span>, in addition to <span class="math inline">\((70,80)\)</span> (in all cases for <span class="math inline">\(t\)</span> on the interval <span class="math inline">\([0,20]\)</span>, using the midpoint method with <span class="math inline">\(200\)</span> steps). The initial points are marked with dots.</p>
<p><img src="images/unnamed-chunk-336-1.png" width="50%" /></p>
<p>It is straightforward to see that <span class="math inline">\((x, y) = (\gamma/\delta,\alpha/\beta)\)</span> is a <em>fixed point (equilibrium)</em> of the Lotka-Volterra equations. That is, if <span class="math inline">\((x_0, y_0) = (\gamma/\delta,\alpha/\beta)\)</span> then for all <span class="math inline">\(t \geq 0\)</span>, <span class="math inline">\((x(t), y(t)) = (x_0,y_0)\)</span>. For the chosen parameter values, this situation arises with <span class="math inline">\((x_0, y_0) = (120,100)\)</span>. The trajectories from the other starting points form cycles around the fixed point <span class="math inline">\((120,100)\)</span>.</p>
<p>By changing the values of <span class="math inline">\(\alpha, \beta, \gamma\)</span> and <span class="math inline">\(\delta\)</span>, one can obtain different behaviour around the fixed point <span class="math inline">\((\gamma/\delta,\alpha/\beta)\)</span>: the fixed point is a <em>sink</em> if the trajectories from the other starting points converge to it as <span class="math inline">\(t \to \infty\)</span>; it is a <em>source</em> if they diverge from it; and it is a <em>saddle-point</em> if some trajectories converge to it and others diverge from it.</p>
<p>One can also easily check that <span class="math inline">\((0,0)\)</span> is a fixed point. This is a saddle point. If we start nearby at <span class="math inline">\((x_0, 0)\)</span>, then <span class="math inline">\((x(t),y(t))=(x_0 e^{\alpha t},0) \to (\infty,0)\)</span> as <span class="math inline">\(t \to \infty\)</span> i.e. this trajectory diverges from <span class="math inline">\((0,0)\)</span>. Whereas, if we start at <span class="math inline">\((0,y_0)\)</span>, then <span class="math inline">\((x(t),y(t))=(0, y_0 e^{- \gamma t}) \to (0,0)\)</span> as <span class="math inline">\(t \to \infty\)</span> i.e. this trajectory converges to <span class="math inline">\((0,0)\)</span>.</p>
<p>The nature of the fixed points has implications for the stability of the system of the differential equations. If a fixed point is a sink, then solutions with nearby initial points are stable; if it is a source then they are unstable. For other types of fixed points, more information is needed in order to decide stability. When solving an ODE near an unstable point, even using a stable algorithm will result in errors being amplified.</p>
</div>
<div id="the-butterfly-effect" class="section level3 hasAnchor" number="10.5.3">
<h3><span class="header-section-number">10.5.3</span> The butterfly effect<a href="ode.html#the-butterfly-effect" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<p>The term <em>butterfly effect</em> is used in chaos theory to describe the sensitive dependence of non-linear dynamical systems (systems of ODEs) on initial conditions whereby a small change in the initial condition can result in a very large difference at a later time. The phrase is associated with the mathematician Edward Lorenz who gave a talk entitled “Does the flap of a butterfly’s wings in Brazil set off a tornado in Texas?” after he observed that when he rounded the initial data for his weather model, he got significantly different results to when he used unrounded initial data. He entered the initial condition 0.506 from the printout instead of entering the full precision 0.506127 value. The result was a completely different weather scenario.</p>
<p>Lorenz proposed the following model for atmospheric convection, now known as the Lorenz equations
<span class="math display">\[\begin{align*}
\frac{dx}{dt} &amp;= \sigma (y-x) \\
\frac{dy}{dt} &amp;= x (\rho -z) -y \\
\frac{dz}{dt} &amp;= xy -\beta z.
\end{align*}\]</span></p>
<p>By setting the right-hand side to zero, one can easily check that when <span class="math inline">\(\rho &lt; 1\)</span>, there is only one fixed point, at the origin. For <span class="math inline">\(\rho &gt; 1\)</span>, two additional fixed points appear, at
<span class="math display">\[
\left (\pm \sqrt{\beta(\rho-1)}, \pm \sqrt{\beta(\rho-1)}, \rho -1 \right ).
\]</span>
For sufficiently small values of <span class="math inline">\(\rho\)</span> (dependent on <span class="math inline">\(\sigma\)</span> and <span class="math inline">\(\beta\)</span>), these points are stable and the trajectories of any non-zero initial values converge to one of them.</p>
<p>Take <span class="math inline">\(\sigma=10\)</span>, <span class="math inline">\(\beta=8/3\)</span> and <span class="math inline">\(\rho=14\)</span> with initial condition <span class="math inline">\((x_0,y_0, z_0)=(-10,-8,29)\)</span>. We plot an approximate trajectory of <span class="math inline">\(z(t)\)</span> against <span class="math inline">\(x(t)\)</span> for <span class="math inline">\(t \in [0,100]\)</span> using the midpoint method with step size <span class="math inline">\(h=0.01\)</span> <span class="math inline">\((N=10000\)</span> steps). The colours cycle through the rainbow spectrum as <span class="math inline">\(t\)</span> increases, starting with red when <span class="math inline">\(t=0\)</span> and changing colour every unit of time.</p>
<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); grid-column-gap: 10px;">
<div>
<p><strong>R</strong></p>
<div class="sourceCode" id="cb946"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb946-1"><a href="ode.html#cb946-1" aria-hidden="true" tabindex="-1"></a>lorenz_solver <span class="ot">=</span> <span class="cf">function</span>(sigma, beta, rho, initial, time, steps){</span>
<span id="cb946-2"><a href="ode.html#cb946-2" aria-hidden="true" tabindex="-1"></a>  lorenz_f <span class="ot">=</span> <span class="cf">function</span>(t,x){</span>
<span id="cb946-3"><a href="ode.html#cb946-3" aria-hidden="true" tabindex="-1"></a>    f1 <span class="ot">=</span> sigma<span class="sc">*</span>(x[<span class="dv">2</span>] <span class="sc">-</span> x[<span class="dv">1</span>])</span>
<span id="cb946-4"><a href="ode.html#cb946-4" aria-hidden="true" tabindex="-1"></a>    f2 <span class="ot">=</span> x[<span class="dv">1</span>]<span class="sc">*</span>(rho <span class="sc">-</span> x[<span class="dv">3</span>]) <span class="sc">-</span> x[<span class="dv">2</span>]</span>
<span id="cb946-5"><a href="ode.html#cb946-5" aria-hidden="true" tabindex="-1"></a>    f3 <span class="ot">=</span> x[<span class="dv">1</span>]<span class="sc">*</span>x[<span class="dv">2</span>] <span class="sc">-</span> beta<span class="sc">*</span>x[<span class="dv">3</span>]</span>
<span id="cb946-6"><a href="ode.html#cb946-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="fu">c</span>(f1,f2,f3))</span>
<span id="cb946-7"><a href="ode.html#cb946-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb946-8"><a href="ode.html#cb946-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">midpoint_system</span>(lorenz_f, <span class="dv">0</span>, time, initial, steps))</span>
<span id="cb946-9"><a href="ode.html#cb946-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb946-10"><a href="ode.html#cb946-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb946-11"><a href="ode.html#cb946-11" aria-hidden="true" tabindex="-1"></a>sol <span class="ot">=</span> <span class="fu">lorenz_solver</span>(<span class="dv">10</span>, <span class="dv">8</span><span class="sc">/</span><span class="dv">3</span>, <span class="dv">14</span>, <span class="fu">c</span>(<span class="sc">-</span><span class="dv">10</span>,<span class="sc">-</span><span class="dv">8</span>,<span class="dv">29</span>), <span class="dv">100</span>, <span class="dv">10000</span>)</span></code></pre></div>
</div>
<div>
<p><strong>Python</strong></p>
<div class="sourceCode" id="cb947"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb947-1"><a href="ode.html#cb947-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lorenz_solver(sigma, beta, rho, initial, time, steps):</span>
<span id="cb947-2"><a href="ode.html#cb947-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> lorenz_f(t,x):</span>
<span id="cb947-3"><a href="ode.html#cb947-3" aria-hidden="true" tabindex="-1"></a>        f1 <span class="op">=</span> sigma<span class="op">*</span>(x[<span class="dv">1</span>] <span class="op">-</span> x[<span class="dv">0</span>])</span>
<span id="cb947-4"><a href="ode.html#cb947-4" aria-hidden="true" tabindex="-1"></a>        f2 <span class="op">=</span> x[<span class="dv">0</span>]<span class="op">*</span>(rho <span class="op">-</span> x[<span class="dv">2</span>]) <span class="op">-</span> x[<span class="dv">1</span>]</span>
<span id="cb947-5"><a href="ode.html#cb947-5" aria-hidden="true" tabindex="-1"></a>        f3 <span class="op">=</span> x[<span class="dv">0</span>]<span class="op">*</span>x[<span class="dv">1</span>] <span class="op">-</span> beta<span class="op">*</span>x[<span class="dv">2</span>]</span>
<span id="cb947-6"><a href="ode.html#cb947-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array((f1,f2,f3))</span>
<span id="cb947-7"><a href="ode.html#cb947-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb947-8"><a href="ode.html#cb947-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> midpoint_system(lorenz_f, <span class="dv">0</span>, time, initial, steps))</span>
<span id="cb947-9"><a href="ode.html#cb947-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb947-10"><a href="ode.html#cb947-10" aria-hidden="true" tabindex="-1"></a>sol <span class="op">=</span> lorenz_solver(<span class="dv">10</span>, <span class="dv">8</span><span class="op">/</span><span class="dv">3</span>, <span class="dv">14</span>, np.array((<span class="op">-</span><span class="dv">10</span>,<span class="op">-</span><span class="dv">8</span>,<span class="dv">29</span>)), <span class="dv">100</span>, <span class="dv">10000</span>)</span></code></pre></div>
</div>
</div>
<p>Here is a plot of the solutions:</p>
<p><img src="images/unnamed-chunk-339-1.png" width="50%" /></p>
<p>When <span class="math inline">\(\rho\)</span> gets large enough, the two points become unstable and the trajectory is repelled by them in a very complex way. Taking the parameters <span class="math inline">\(\sigma=10\)</span>, <span class="math inline">\(\beta=8/3\)</span> and <span class="math inline">\(\rho=28\)</span> (which were the parameters that Lorenz used) with initial condition <span class="math inline">\((x_0,y_0, z_0)=(-10,-8,29)\)</span>, we plot an approximate trajectory on <span class="math inline">\([0,100]\)</span>. As before, we use the midpoint method with step size <span class="math inline">\(h=0.01\)</span> <span class="math inline">\((N=10000\)</span> steps). Plotting <span class="math inline">\(z(t)\)</span> against <span class="math inline">\(x(t)\)</span> reveals … a butterfly!</p>
<p><img src="images/unnamed-chunk-340-1.png" width="50%" /></p>
<style type="text/css">
.book .book-body .page-wrapper .page-inner {
  max-width: 1200px !important;
}
</style>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="mc.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="challenge.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>

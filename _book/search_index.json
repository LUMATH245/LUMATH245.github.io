[["index.html", "Lancaster University MATH245 Computational Mathematics Preface", " Lancaster University MATH245 Computational Mathematics Lecturers: Dr Eduard Campillo-Funollet and Dr Gaetano Romano 2023/2024 Preface These are the R programming notes for MATH245 Computational Mathematics. They were written by Gaetano Romano (Chapter 1-5) and Eduard Campillo-Funollet (Chapters 6-10). The module will introduce you to scientific computing (with a bit of functional programming), and algorithms. The first 5 Chapters will be focusing on scientific computing. Specifically, we’ll cover: Intro to computing, variables and saving to file Logic and Vectors Functions and Loops Functional Programming and Linear Algebra Data Frames and Plotting Chapters 6 to 10 will be focusing on algorithms. We’ll cover: Fixed Points Root finding Gradient Descent Monte Carlo and Integration ODEs solvers All contents are still subject to change. The notes are both in Python and R. You are expected to only learn one programming language. However, these notes could be used also as a reference to go from one language to the other! Please access them from a wide screen machine, as they were not optimized for mobile. Every week, you are expected to follow one lecture and one lab. Over the lecture, an overview of the contents of the week will be given. But during the lab, you should give it a go at the notes at your own pace, and follow the contents by copy and pasting commands from the notes onto your pc, and completing the exercises. Solutions to the exercises will be uploaded on Moodle after all labs of the week end. Sources This notes are heavily inspired from the materials of including: Debbie Costain, Clement Lee, Chris Nemeth, Tom Palmer, Florian Pein, Gaetano Romano, Stuart Sharples. “Lancaster University MATH550/SCC.461 R Programming”, https://www.lancaster.ac.uk/~romano/teaching/2324MATH550/ Some of the structure of the notes, some example and exercises are from: Hadley Wickham: “Advanced R.” 2nd Edition. https://adv-r.hadley.nz/index.html. Azalee Bostroem, Trevor Bekolay, and Valentina Staneva (eds): “Software Carpentry: Programming with Python.” Version 2016.06, June 2016, https://github.com/swcarpentry/python-novice-inflammation, 10.5281/zenodo.57492. Gabriel A. Devenyi (Ed.), Gerard Capes (Ed.), Colin Morris (Ed.), Will Pitchers (Ed.), Greg Wilson, Gerard Capes, Gabriel A. Devenyi, Christina Koch, Raniere Silva, Ashwin Srinath, … Vikram Chhatre. (2019, July). swcarpentry/shell-novice: Software Carpentry: the UNIX shell, June 2019 (Version v2019.06.1). Zenodo. http://doi.org/10.5281/zenodo.3266823 "],["intro_prog.html", "1 Introduction to Computational Mathematics 1.1 What is a Computer? 1.2 Computing, Accessing Memory and Storing", " 1 Introduction to Computational Mathematics The boss was passing by, so they minimized the browser with the useless Instagram tab and found themselves staring at an Excel window. They had spent hours working on this spreadsheet, crunching pointless numbers and averages. They felt exhausted and bored. They looked at the grid of the spreadsheet, and felt like they were behind the bars of a prison. They wondered if this was what computing was supposed to be like. They had loved mathematics once, and wanted to learn how to use it in creative and exciting ways. They wanted to explore new and emerging fields, such as data science, machine learning, AI, cryptography and to share their code and results online. Well, too late now. They wished that back in uni there was a course that could teach them the basics and fundamentals of programming, and show them how to use two of the most popular and powerful languages for scientific computing: R and Python. Oh, what… Welcome to MATH245, Computational Mathematics! In this course, you will learn how to use two of the most popular and powerful programming languages for scientific computing: R and Python. You will also learn a bunch of cool algorithms and how to apply them to various mathematical problems. Why should you learn programming in mathematics? Well, there are many reasons, but a few that could be of interest to you are: This is a mandatory module. You need to learn how to program to pass. Sometimes life is harsh, we know. Sometimes you fill face problems that are simply too hard to solve by hand. Can’t digest that integral? That ODE is beating up your little brother in school for lunch money? Well, with a computer those will not be a problem anymore. You will learn how to perform complex and large-scale calculations and simulations that would be impossible or impractical by hand or with a calculator. Programming is the butter to the bread of emerging fields of mathematics such as, machine learning, statistical learning, data science and artificial intelligence. Do you want to convert your grandma into a robot? Gottcha, you’ll need to know what a neural network is. And likely what stochastic gradient descent is, we will cover that. Oh, and you need to know how to program. Ooh, nice statistical model for Covid-19 modelling you’ve got there. It would be a shame if there was not a closed form… What? Your data set has three-thousand features? Well, modern statistics is done behind a computer, in R or Python or (if you choose) both. In short, programming can make mathematics more fun, more useful, and more relevant to the modern world. As a mathematician in the 21st century, you need to be able to work with a computer and use it as a tool for discovery and innovation. And well, don’t worry if you have no prior knowledge of programming. We will start from the basics, like really the basics basics, as you can see from the next section header. We will then guide you through the fundamentals and concepts of programming, and then will follow through the basics of Computational Mathematics and Algorithms. We will also give you plenty of examples and exercises to practice and test your skills. By the end of this course, you will be able to write and run your own code in both R and Python, which are two of the most popular programming languages for scientific computing, and learn very useful algorithms that you will apply to various mathematical problems. 1.1 What is a Computer? Few years ago Apple came up with yet another iPad. And with that, another one of their ads. In one specifically, a kid would do a bunch of things with an iPad pro, like working on Word, reading comics or drawing silly things. Then, at the end, a peeping neighbor, perhaps too curious, would ask them: “Wattcha doing on your computer?”. To which the kid, holding the iPad, replies: “What’s a computer?”. Here, look for yourself: Well, you silly! Your iPad is a computer. So it’s your smartphone. And your smartwatch, probably your TV, your Fridge and your car - if you have a fancy electric car. We’re living in a world of computers. There are many kinds of computers, but you have probably interacted mostly with smartphones and desktop or laptop computers. As a student of in this module, you will likely use a desktop (the university machine) or your own laptop for programming. Theoretically, however, you can also program on other devices, such as tablets (or smartwatches, even!), obviously with some caveats and limitations. Also, computers will have different architectures, such as x86, ARM, or RISC-V, that determine how they processes the instructions and data. You might not know it, but your laptop could have a mobile processor, like the such as Snapdragon, Exynos, or Apple M-series. This could impact your learning experience in this module, so, if you are not familiar with the concept above stick to the university machines. More formally, a computer is a device that can perform calculations and manipulate data, all by following a set of instructions known as a program. It has the ability to process a variety of data types, including numbers, text, images, sound, and video, and can produce a range of outputs. This could be anything from displaying information on a screen, playing audio, or transmitting information over the internet (which, in its simplest form, is just two computers exchanging text). Let’s delve a bit deeper into the main components of a computer: Central Processing Unit (CPU): Often referred to as the ‘brain’ of the computer, the CPU is responsible for executing the program’s instructions. Memory: This is the computer’s short-term memory, sometimes known as RAM (Random Access Memory). It stores the data that the CPU needs to access quickly and frequently. RAM is volatile, which means that its contents are lost when the computer is turned off or restarted. Storage: This is the computer’s long-term memory. It holds data that isn’t required immediately or frequently by the CPU. This could include the program itself or files created by the user. Hard drives are non-volatile, meaning their contents persist even when the computer is turned off. To illustrate how these components interact, let’s consider what happens when you run a program e.g. a series of instruction that make sense to your CPU: Say that your program and your data are saved on your hard drive (a type of storage). The program, along with any necessary data, is then loaded from the hard drive into the memory. This allows the CPU to access it. The CPU then carries out the program’s instructions, performing calculations and operations on the data stored in the memory. The results of these operations remain in the memory and can be displayed on the screen, saved back to the hard drive, or sent to another device. This process highlights the integral role each component plays in the functioning of a computer. 1.1.1 Computer Programs and Programming Languages We have mentioned a program earlier, but what is a program? A program is a sequence of instructions that tells the computer what to do. A program can be written in different ways, depending on the level of abstraction and the intended audience. For example, a program can be written in natural language, such as English, or in a formal language, such as mathematics. However, the computer cannot understand these languages directly. It can only understand a very low-level language, called machine code, which consists of binary digits (0s and 1s) that represent the basic operations of the CPU. Something that is ultimately rendered into a set of binary instructions to feed to the CPU is a computer program. Therefore, to make the computer execute a program, we need to translate it from a higher-level language to a lower-level language. This is where programming languages come in. A programming language is a formal language that defines the syntax and semantics of a program. A programming language allows us to write programs in a more human-readable and expressive way. Then another computer program (called interpreter), translate our programs to machine code that the computer can understand and execute. There are many programming languages, and they have different features and purposes. Some programming languages are designed for specific domains or tasks, such as web development, data analysis, or game design, whilst others are more general-purpose and can be used for a variety of applications. In this course, we will focus on two of the most popular and versatile programming languages for scientific computing: R and Python. Both of these languages are high-level, interpreted, and general-purpose languages: High-level means that the programming language is closer to natural language and more abstracted from the details of the machine code. This makes the language easier to read, write, and understand, but also requires more translation and processing by the interpreter or the compiler. But don’t worry about this… Fortunately most of the heavy lifting is done by the compiler, which is the interpreter that converts the code from human readable to machine readable. Machine code is the lowest level and all programming languages we actually use are at an higher level. This was not always the case: programming used to be extremely low level. In your own time, take a look at this Sonic 3D renderer video! Interpreted means that the programming language does not need to be compiled (i.e. translated to a machine code sequence of 0s and 1s) before execution, but rather is translated and executed line by line by our interpreter. This allows the language to be more dynamic and flexible, but also slower and less efficient than compiled languages. One of the advantages of interpreted languages is that you can execute commands directly in the console, in addition to writing and saving these in a script. This is useful for testing and debugging your code, or for performing quick calculations and operations. Non-interpreted languages, on the other hand, have to be fully written and compiled top-to-bottom before execution. General-purpose means that the programming language can be used for a variety of applications and domains, and is not limited to a specific purpose or task. This makes the language more versatile and adaptable, but also less specialized and optimized than domain-specific languages. General-purpose languages can be used for web development, video game engineering, automation, and… scientific computing, among other things. 1.1.2 R and Python Well, finally it’s time to introduce our two friends. And as with any good introduction, we give a bit of history. R is an high-level, interpreted language for statistical computing and graphics. It was created by Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand, in 1993. It is based on the S language, which was developed at Bell Laboratories by John Chambers and others in the 1970s. R is free and open source, and has a large and active community of users and developers. R is especially popular among statisticians, data scientists, and researchers in various fields. Python is a high-level, interpreted, general-purpose programming language. It was created by Max Verstappen in the Netherlands 5 years ago. Nah, just kidding… It was made though in the Netherlands in 1991 by Guido van Rossum, at Centrum Wiskunde &amp; Informatica (CWI). It is named after the comedy group Monty Python, and has a philosophy of simplicity, readability, and elegance. Python is also free and open source, and has a huge and diverse community of users and developers. Python is widely used for a variety of tasks and it’s getting more and more popular in statistics and for scientific computing. Both R and Python have many advantages and features that make them suitable for mathematical applications, such as: They are easy to learn and use, with clear and consistent syntax and semantics. They allow you to write concise and elegant code that can handle complex problems, without getting too lost in complicated syntax (have a look at some C or Fortran code for instance). They are extensible and modular, supporting multiple paradigms and styles of programming, such as functional, object-oriented, and procedural. For this course, we will be focusing on functional programming. In functional programming, functions are first-class citizens, as we will learn, and this goes well with mathematics and scientific computing. They have rich and comprehensive libraries and packages that provide a wide range of functions and tools for various domains and tasks, such as linear algebra, optimization, machine learning, visualization, and web scraping. They have interactive and user-friendly environments and interfaces that facilitate development and debugging, such as the console, the editor, and the notebook. For this module, for both programming languages, we will be using R Studio. You should have installed R Studio with either R or Python at this point. You will find how to do this in the first part of the lab. Do not continue unless you have R Studio installed and ready. 1.2 Computing, Accessing Memory and Storing We covered the three components of the computer: the CPU, the memory and the storage. Well, a programming language is a powerful tool that allows you to build a set of instructions that use all three of these components. By the end of this chapter, we won’t be able to write a full program, but we will show how these three interact. Before we proceed, a quick rundown on how to read the lines of code in these notes. Every once in a while you will see a chunk of code, and sometimes a result of what the chunk of code does. For example: # Hi, I am a chunk of R code that prints to output &quot;Beep bop beep&quot; print(&quot;Beep bop beep&quot;) ## [1] &quot;Beep bop beep&quot; As the comment (that bit in that starts with the #), suggests, what you saw is a chunk of R code that prints to output the text “Beep bop beep”. On top you will find the code, and on the bottom the result, i.e. the output. The comment does not get executed, so it’s just an explanation of what you are seeing. The actual code statement, print(\"Beep bop beep\"), is the one that does all the job, and, as the comments suggests, prints the text “Beep bop beep”. Wait, but I thought we would have learned Python in this module? Well, patience, my dear friend. The Python equivalent of that statement would be: # Hi, I am a chunk of Python code that prints to output &quot;Beep bop beep&quot; print(&quot;Beep bop beep&quot;) ## Beep bop beep Wait, they’re basically the same? Well, yes, that’s the point, and the reason why we teach them both simultaneously. Despite the current culture war in Statistics and Data Science, we believe that there’s no such thing as a best programming language: for each task the expert worker should use the most appropriate of the available tools. Right now, Python and R are almost equivalent for scientific computing; and, given recent developments they can be used together, in tandem. Now that you are learning, pick one, based off your future modules. Don’t worry, for your project you will have to pick either one, or the other so it’s not a requirement to learn both R and Python. But if you feel confident enough, feel to learn both, you’re more than welcome. As a matter of fact, for all the these notes, we will always try to display code in both languages side by side. On the left you will always an R code chunk, and on the right you will find the Python equivalent: R print(&quot;R chunk on the left.&quot;) ## [1] &quot;R chunk on the left.&quot; python print(&quot;Python chunk on the right.&quot;) ## Python chunk on the right. If for formatting reasons we aren’t able to show the code side to side, you can always tell which is which by the bold text immediately above the chunk, e.g. R or python. 1.2.1 A glorified calculator That’s it, the CPU is a glorified calculator, end of the Section. Nothing more to it, even if sometimes you might have heard complex codes and names like i7, i5, A4, Pentium 5, Neural Pre-processor, Snapdragon, Qbits, SmartBpprop, Bombastic, Mr fantastic, etc. Anyway, let us not worry about this now, but open up a new script, either an R or Python script. Copy and paste the following code snippets into it. Then, placing your cursor next to each snippet, press ctrl + enter on your keyboard, you will see the result popping up in the console. What’s going to happen under the hood once you are sending a command to R or Python, is that process I mentioned earlier. The interpreter, will convert your command into machine code, and pass it down to the processor. The processor is going to crunch the numbers, and send back an output, that will then be displayed on your screen. This is how we do additions: R 3 + 5 ## [1] 8 python 3 + 5 ## 8 The result is automatically printed back to the user. Now, this is how we do subtractions: R 3 - 5 ## [1] -2 python 3 - 5 ## -2 And this is how we do additions and subtractions, and multiplications, and algebra in general: R 3 + 5 * 2 ## [1] 13 python 3 + 5 * 2 ## 13 The order of the operations comes from algebra, so in that snippet, we will first have 5 * 2, that gives us 10, and then we will do 3 + 10. Of course we can do much more then simple additions of subtractions and multiplications. Here I have a list of basic operations we can do with both the languages. Note that the syntax will not always be the same: Operation R Example Python Example Add 2 + 3 2 + 3 Subtract 2 - 3 2 - 3 Multiply 2 * 3 2 * 3 Divide 2 / 3 2 / 3 Modulus 2 %% 3 2 % 3 Square root sqrt(2) math.sqrt(2) Power 2^3 2 ** 3 Cosine cos(2 * pi) math.cos(2 * math.pi) Sine sin(pi / 2) math.sin(math.pi / 2) Tangent tan(pi / 4) math.tan(math.pi / 4) Natural log log(2) math.log(2) Expontential exp(2) math.exp(2) Please note that in Python, you need to import the math library to use mathematical functions like sqrt, cos, sin, tan, log, and exp. Also, pi is accessed as math.pi in Python. We will see what a library is in details in the next chapter. At the start of your python script, just add the following: Python import math Don’t worry too much about this for now. 1.2.1.1 Exercise Using numbers of your own, try the other basic mathematical operations listed below. Split a £10 bill across 3 people, check if 91 is a prime number using the modulus with the first 5 primes or get the Euler number. Play around, be wild. 1.2.1.2 Putting an order to operations Once you’re happy, try stringing some of these calculations all into one command, for example: R 3 + 7 * 5 / 3 - 2 ## [1] 12.66667 (3 + 7) * 5 / (3 - 2) ## [1] 50 Python 3 + 7 * 5 / 3 - 2 ## 12.666666666666666 (3 + 7) * 5 / (3 - 2) ## 50.0 The multiplication and division calculations are performed first (* and /), followed by addition and subtraction (+ and -), going from left to right. You may remember this from School as BODMAS/BEDMAS: Brackets, Orders (Exponential, powers and square roots), Division, Multiplication, Addition, Subtraction This can be overridden by using putting the calculations we want to perform first in brackets. For instance, there’s this formula that has been really bothering me. It popped up this morning at 4am, and kept me awake. What is the square root of three fourth, over a third minus 2 divided by pi squared? A hunted seagull of chalk flying around the vast sea of obsidian that is the blackboard of my mind, over and over and over again: \\[ \\frac{\\sqrt{3/4}}{\\frac{1}{3} - \\frac{2}{\\pi^2}}. \\] Here you go, be free, little bird: R sqrt(3 / 4) / (1 / 3 - 2 / pi^2) ## [1] 6.626513 Python math.sqrt(3 / 4) / (1 / 3 - 2 / math.pi**2) ## 6.626513139875386 1.2.2 What if modern calculators can remember? Yeah, what if? Well, that’s what the memory is for, keeping things in mind. You can think of the memory as a bookshelf, filled with boxes. Or if you’re one fan of that Henry Popper, the Magician Kid of Hogtwarz, (I do not wish to pay for the rights to Warner Bros) it’s like that room filled with shelves and bottles of thoughts and spells. Yes, that’s a better image. So the CPU is the Ministerium of Evil Magicians and can access each shelf whenever it feels or needs. Now, in a computer, of course, instead of bottles, you have areas of the memory, and instead of spells, you have numbers, or vectors, or strings (text, e.g. a series of characters). Now, the Ministerium, to access the spells and the thoughts in the bottles, has a bunch of Evil Magicians, that walk in the archive, and that can claim these bottles by putting labels onto them. Those magicians are, in the computer, our programs. Putting a label on an area of memory is called creating a variable. Here’s the thing: when a magician grabs a bottle, they can either look at which thought or spell is in it, or put a new thought into it. An existing thought in a bottle cannot be modified. If they wish to keep the same bottle with the same label, but change the content, they open it, get rid of the old content, and simply put a new one. To give an example, Prof. Sinsinius Snap, to kill that guy that kinda of looks like Gandalf, needs to store two spells. In one he needs to store the formula of the spell that causes the victim to feel a lot of pain (this was in a children’s book, by the way), and in the other, the formula that makes the victim’s heart stop. To do so, it creates two labels, spell_to_torture and spell_to_kill, so it won’t loose the bottles in the archive,and in each it puts the evil spell: R spell_to_torture &lt;- &quot;porcosus&quot; spell_to_kill &lt;- &quot;avada kebaba&quot; python spell_to_torture = &quot;porcosus&quot; spell_to_kill = &quot;avada kebaba&quot; What did we do? We assigned two strings (sequences of text), \"porcosus\" and \"avada kebaba\", indicative of our spells, in two variables, called spell_to_torture and spell_to_kill (the labels). You can read the code above as assign “porcosus” to spell_to_torture, and assign “avada kebaba” to spell_to_kill. This can be done with the &lt;- sign in R and with the = sign in Python. What we did reserved an area of memory where now our two strings are stored and are accessible to our program. Note for R users It is worth pointing out that you can use the = for assignment in R just like with Python. Try to change above in R spell_to_torture = \"porcosus\": the result won’t change. However, the &lt;-, meaning “gets”, and is a more intuitive symbol in my opinion when referring to assignment. So we’ll be using this where we can in R. Feel free to use whichever you prefer. Our dear Prof. Sinsinius Snap, to access the spells again, all he needs to do, is to recall the labels he used, e.g. the variable names, and the archive will remind him of the content of the bottles: R spell_to_torture ## [1] &quot;porcosus&quot; spell_to_kill ## [1] &quot;avada kebaba&quot; python spell_to_torture ## &#39;porcosus&#39; spell_to_kill ## &#39;avada kebaba&#39; Ouch! He realizes he putted the wrong spell in the spell_to_torture bottle. Well, no problem, as mentioned above, he can re-bottle the correct one. To do so, he simply reassigns the correct spell \"cruccio\" to the bottle labelled spell_to_torture: R spell_to_torture &lt;- &quot;cruccio&quot; python spell_to_torture = &quot;cruccio&quot; Note that now, the old spell \"porcosus\" is lost. In fact, when he looks at the spell_to_torture bottle, he sees: R spell_to_torture ## [1] &quot;cruccio&quot; python spell_to_torture ## &#39;cruccio&#39; “Well done Sinsinius!” he says, patting himself on the shoulder. 1.2.2.1 Doing maths with variables Now of course, this is a university, not a school of magic and divination, so we ultimately need to do some maths. In programming, we often need to store the results of our calculations for later use. This is where variables come in handy. We mentioned you can think of a variable as a bottle where you can store a value. You can give this bottle a label (a name), and use this label to refer to the bottled value later on. For example, let’s say we want to perform some calculations: R x &lt;- 20 - 16 y &lt;- 4 + 5 x - y ## [1] -5 Python x = 20 - 16 y = 4 + 5 x - y ## -5 Here, x and y are variables. We’ve assigned them the results of some calculations. Now, whenever we refer to x or y, we’re actually referring to the results of these calculations. We can check the values stored in x and y by simply typing their names: R x ## [1] 4 y ## [1] 9 Python x ## 4 y ## 9 Remember, R and Python are case-sensitive, so x is different from X. If you try to access X, you’ll get an error because we haven’t assigned anything to X: R X ## Error in eval(expr, envir, enclos): object &#39;X&#39; not found Python X ## name &#39;X&#39; is not defined Also, if you assign a new value to a variable, the old value will be overwritten without any warning: R x &lt;- -100 x ## [1] -100 Python x = -100 x ## -100 Now, here’s something cool. In maths, an equation like \\(x = x + 1\\) doesn’t make much sense. But in programming, it’s perfectly valid. It means “take the current value of x, add 1 to it, and store the result back in x”. This is a common way to increment a variable: R x &lt;- x + 1 x ## [1] -99 Python x = x + 1 x ## -99 In fact, you can use all mathematical operations in this way. You should use variables as much as you can to keep the code as clean and readable as possible. Let’s revisit the example above: R numerator &lt;- sqrt(3 / 4) denominator &lt;- (1 / 3 - 2 / pi^2) result &lt;- numerator / denominator result ## [1] 6.626513 Python numerator = math.sqrt(3 / 4) denominator = (1 / 3 - 2 / math.pi**2) result = numerator / denominator result ## 6.626513139875386 In this refactored code, we first calculate the numerator and the denominator separately and store them in variables. Then, we perform the division operation and store the result in another variable. This makes the code easier to read and understand. It also allows us to reuse the numerator and denominator calculations if needed elsewhere in the code. This is a good practice in programming. It not only makes the code cleaner but also more efficient. 1.2.3 Storing Data on the Hard Drive When you’re working with a programming language like R or Python, any variables you create are stored in your computer’s memory (the RAM). This is a type of storage that’s fast and easy for your computer to access, which is why it’s used for tasks that are currently running. However, memory is volatile, which means that once the power is turned off or your program finishes running, any data stored in memory is lost. Sometimes, you might want your program to produce something tangible that doesn’t get lost when the power is turned off or your program stops running. This could be a report, a graph, or even just a set of numbers. To do this, you can write this data to a file on your hard drive. Unlike memory, data stored on your hard drive remains there until it’s deleted, so you can access it again later. Let’s look at how you can write data to a file in R and Python. R # Create some data data &lt;- c(1, 2, 3, 4, 5) # Write the data to a file write.csv(data, file = &quot;data.csv&quot;, row.names = FALSE) Python # Import the pandas library import pandas as pd # Create some data data = [1, 2, 3, 4, 5] # Convert the data to a DataFrame df = pd.DataFrame(data) # Write the data to a file df.to_csv(&quot;data.csv&quot;, index=False) In both of these examples, we’re creating a set of data (the numbers 1 through 5), and then writing this data to a file called “data.csv”. The write.csv function in R and the to_csv function in Python are used to write the data to a file. In R, when you see c(1, 2, 3), we’re making a vector. As in maths, this is a collection of numbers that you’ve bundled together in a specific order: first 1, then 2, then 3. In Python, when you see [1, 2, 3], it’s very similar. This in python is called a list. We’ll learn more about these collections (vectors in R and lists in Python) in the next chapter. For now, just remember that they are a way to keep your items organized and in a specific order. It’s like having a container where you can keep your things neatly instead of having them scattered all over the place. This makes it easier to find what you need later on. Moreover, in the Python example, you might have noticed the pd.DataFrame statement. This is a way to create a DataFrame, which is a kind of table, using the pandas library. This, as maths above, is another collection of functions, and you will usually refer to these functions via pd.FUNCNAME. Again, don’t worry! We’ll cover these topics in more detail later on. For now, just know that we’re using a DataFrame to store our information in a structured way that can be easily written to a file. We will refer to this information as data. Data, in a broader sense, can be a lot of things: the image from a satellite in space, some medical information from a clinical trial, the output from an ODE solver or a long list of prime numbers that the computer has worked out. Now, let’s talk about CSV files. CSV stands for “Comma-Separated Values”. It’s a simple file format used to store tabular data, such as a spreadsheet or database. Each line of the file is a data record, and each record consists of one or more fields, separated by commas. This is why it’s called a “comma-separated values” file. When we write our data to a CSV file, each item of data goes into its own field, and each set of data (like a row from a table) goes into its own record. This makes CSV files a great way to store tabular data, because it’s easy to input the data into a spreadsheet or database program later on. I encourage you to open the “data.csv” file we created in a text editor or spreadsheet program. You’ll see that the data is stored in a structured, easy-to-read format. Each number is in its own field, and each set of numbers is in its own record. Remember, storing data on your hard drive is a great way to preserve your data for later use. It’s also a great way to share your data with others, or to move your data between different programs. So don’t be afraid to use file input and output in your own programs. It’s a powerful tool that can help you do more with your data. 1.2.3.1 Reading back your data Now, let’s say we want to access this data at a later time. We can do this by reading the file back into our program. Here’s how you can do it in R and Python: R # Read the data from the file data_from_file &lt;- read.csv(&quot;data.csv&quot;) # Print the data print(data_from_file) ## X0 ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 Python # Read the data from the file data_from_file = pd.read_csv(&quot;data.csv&quot;) # Print the data print(data_from_file) ## 0 ## 0 1 ## 1 2 ## 2 3 ## 3 4 ## 4 5 In these examples, we’re using the read.csv function in R and the read_csv function in Python to read the data from the file back into our program. When we print these data, we can see that the content of the output is the same as the data we originally wrote to the file. This is just a basic introduction to storing data on your hard drive using R and Python. There’s a lot more you can do with file input and output, but this should give you a good starting point. Remember, the key is to use variables to store your data in memory while your program is running, and then write this data to a file on your hard drive if you want to keep it for later. 1.2.4 Working Directory and File Structures But where have we stored our data.csv? Well, in the working directory. The working directory is the folder on your computer where R or Python is currently operating. When you run a script, it’s as if you’re standing in your working directory. Any files you read or write will be searched for or created within this directory. But what is a directory? Well, you can think of a directory as a folder, in a filing cabinet, where you can organise your files more easily. In R, you can learn about your current working directory with getwd() and set it with setwd(\"your/directory/path\"). In Python, you can use os.getcwd() to get the current working directory and os.chdir(\"your/directory/path\") to change it. Note, that as above, you will need to import the os module with import os. Try to run the getwd() or os.getcwd() command in your script, and this should print the location where you will find your file data.csv as this was the directory you were working in. Now what you might wonder, what is a file path? What on earth is a location?. Well, a file path is a string that tells us the location of a file on our computer. You may familiar with this concept already, but if you’re not, don’t worry, you will find what you need below. The idea is that files are stored on your hard drive, and, to access these, at user level, you’ll need to navigate a file structure. A file structure is how files are organized on your computer. You can think of it like a tree, where each folder (also known as a directory) is a branch that can hold more folders or files (the leaves): A file structure in unix: you can see how from the root directory \"/\", you have some sub-directories, and sub-directories, e.g. \"/bin\" or \"/Users\". In turn, those directories have other sub-directories, e.g. \"/Users/larry\". In Windows or Mac you’d find a slightly different structure, but the concept is the same. If you’ve ever used a file explorer or finder on your computer, you’ve navigated a file structure. It’s like having a series of nested folders, each containing more folders or files. And this structure helps us keep our files organised and easily accessible. A file path is the specific location of a file or folder in the file structure. It’s like a list of directions to get to the file. In our previous examples, \"data.csv\" is a file path. Because it doesn’t include any directory names, it refers to a file in the current working directory. This is similar to saying, “the report on my desk,” where the report is the file and the desk is the current working directory. You can also specify files in directories below the working directory in your file path. For example, \"subdirectory/data.csv\" would refer to a file in a folder named “subdirectory” within the current working directory. This is like saying, “the report in the top drawer of my desk.” To go up to a parent directory, you can use \"..\". So \"../data.csv\" would refer to a file in the parent directory of the current working directory. This is like saying, “the report on my colleague’s desk next to mine.” Let’s see how this works in R and Python: R # Write data to a file in a subdirectory write.csv(data, file = &quot;subdirectory/data1.csv&quot;) # Write data to a file in the parent directory write.csv(data, file = &quot;../data2.csv&quot;) Python # Write data to a file in a subdirectory df.to_csv(&quot;subdirectory/data1.csv&quot;, index=False) # Write data to a file in the parent directory df.to_csv(&quot;../data2.csv&quot;, index=False) In both of these examples, we’re writing the same data to a file in a subdirectory and a file in the parent directory of the current working directory. See if you can locate (and delete, please), the files you just created! NOTE: if you didn’t create a directory named (literally) subdirectory under your working directory path, then the first write statement will give you an error! Try to create the directory and see if the error still pops up. .book .book-body .page-wrapper .page-inner { max-width: 1200px !important; } "],["log_vec.html", "2 Logic and Vectors 2.1 Comparisons 2.2 Logical Arithmetic 2.3 Flow 2.4 Vectors 2.5 Accessing vectors", " 2 Logic and Vectors In this chapter, we will introduce you to the basics of logic in a computer. Computer Logic is related in its own way to the branch of mathematical logic, in particular with the branch of Boolean algebra. And if truth is something elusive in the philosophical discourse, in Boolean algebra it is well defined, as the \\(\\land, \\ \\lor, \\lnot\\) logic operators are. If you’re used to these, for the rest of this chapter, we will use a different notation for these three symbols: AND, OR and NOT. In programming, logic is essential, as it allows us to create and manipulate expressions and statements that can be evaluated as true or false. In this way logic enables us to control the flow and structure of our programs, and to perform various operations and calculations on data. 2.1 Comparisons Before we start with logic, we should cover what comparison is. I mean, we can again philosophize about it, but pulling out the Oxford English Dictionary, “[Comparison is ] the action, or an act, of comparing, likening, or representing as similar: see compare.” If we pull out the definition of compare, we simply get “To liken”. The concept of comparison is inherit in human existence, as it’s the concept of what TRUE is, (Kierkegaard lost his mind finding out that there’s not a way that two things are the same, that truth is subjective, and that please do not compare people, that is not nice). Anyway, in programming, comparison is the process of examining two or more objects or values and determining their relationship or difference. Comparison can be used for various purposes, such as checking the validity of an input, showing that two variables contain the same item, or most importantly to control the flow of a program (later with this). For now, let’s focus on how to compare objects and values in both R and Python, and how to use the results of comparison in your programs. First, let’s see how to check for equality in R and Python. Equality means that two objects or values are exactly the same in every aspect. To check for equality, we use the operator ==, which returns TRUE if the objects or values are equal, and FALSE if they are not. As you will see, R uses uppercase letters for TRUE and FALSE, while Python starts with a capital letter and uses lower case for the remaining letters, e.g. True and False. For example, we can compare two strings, two integers, or two doubles, as shown below: R # Comparing two strings &quot;Hello&quot; == &quot;Hello&quot; ## [1] TRUE &quot;Hello&quot; == &quot;hello&quot; ## [1] FALSE # Comparing two integers 2 == 2 ## [1] TRUE 2 == 3 ## [1] FALSE # Comparing two reals 3.14 == 3.14 ## [1] TRUE 3.14 == 3.1415 ## [1] FALSE python # Comparing two strings &quot;Hello&quot; == &quot;Hello&quot; ## True &quot;Hello&quot; == &quot;hello&quot; ## False # Comparing two integers 2 == 2 ## True 2 == 3 ## False # Comparing two reals 3.14 == 3.14 ## True 3.14 == 3.1415 ## False From these examples, we can notice how the computer is, indeed, very strict with the definition of equality. Two things might seem similar, or likely to be the same, but they are not. Note that the comparison is case-sensitive, meaning that uppercase and lowercase letters are considered different. Also note that the comparison is precise, meaning that even a small difference in the decimal places can make two numbers unequal. Numbers with decimal places and fractional numbers, in computing are called floating precision numbers (floats). Floats are a way of representing real numbers in computer systems. They are designed to handle a wide range of values, from extremely small to extremely large, with fractional components. Try adding more decimals to the above examples, and see how far you can get until you get two same numbers! The amount of decimal places in floats is at the basis of precision and how comparisons of floats are made will affect your programs. The precision of a floating-point number is determined by the number of significant digits that it can represent: double-precision floats, the defaults in R and python, can represent about 16 decimal digits of precision. Albeit systems are in place to avoid numerical errors for smaller numbers, be careful when you compare two floats and try to avoid comparing two floating point numbers to see if they are equal. Instead you could see if the discrepancy between them is less than some small, positive number (see later to how to check less than). 2.1.0.1 Exercise Try to run the comparison 1e5/(1e5 + 1e-16) == 1 and see what happens. The expression 0.1 + 0.3 == 0.4 gives TRUE, but 0.1 + 0.2 + 0.3 == 0.6 evaluates to FALSE. Why? Similar to equality, we can check for inequality. Inequality means that two objects or values are not exactly the same in every aspect. To check for inequality, we use the operator !=, which returns TRUE if the objects or values are not equal, and FALSE if they are. As earlier: R # Comparing two strings &quot;Hello&quot; != &quot;Hello&quot; ## [1] FALSE &quot;Hello&quot; != &quot;hello&quot; ## [1] TRUE # Comparing two integers 2 != 2 ## [1] FALSE 2 != 3 ## [1] TRUE # Comparing two doubles 3.14 != 3.14 ## [1] FALSE 3.14 != 3.1415 ## [1] TRUE python # Comparing two strings &quot;Hello&quot; != &quot;Hello&quot; ## False &quot;Hello&quot; != &quot;hello&quot; ## True # Comparing two integers 2 != 2 ## False 2 != 3 ## True # Comparing two doubles 3.14 != 3.14 ## False 3.14 != 3.1415 ## True As mentioned above, we can also compare the content of variables. As we learned last week, a variable is a name that refers to a value or an object that is stored in the memory, so by comparing variables we compare the value they refer to. For example, we can assign the string \"Hello\" to the variable x in both languages, as shown below: R # Assigning a string to a variable x &lt;- &quot;Hello&quot; python # Assigning a string to a variable x = &quot;Hello&quot; And we can then use the same operators as before, == for equality and != for inequality. For example, we can compare the variable x with another string, another variable, or itself, as shown below: R # Comparing a variable with a string x == &quot;Hello&quot; ## [1] TRUE x == &quot;hello&quot; ## [1] FALSE # Comparing a variable with another variable y &lt;- &quot;World&quot; x == y ## [1] FALSE y &lt;- &quot;Hello&quot; x == y ## [1] TRUE # Comparing a variable with itself x == x ## [1] TRUE python # Comparing a variable with a string x == &quot;Hello&quot; ## True x == &quot;hello&quot; ## False # Comparing a variable with another variable y = &quot;World&quot; x == y ## False y = &quot;Hello&quot; x == y ## True # Comparing a variable with itself x == x ## True In addition to equality and inequality, we can also compare the magnitude or the order of two values or objects. This is especially useful in computational maths, as we often need to check if a value is within a certain range, or if a value satisfies a certain condition. To compare the magnitude or the order of two values or objects, we use the following operators: Greater than (&gt;): This operator returns TRUE if the left operand is larger than the right operand, and FALSE otherwise. For example, 3 &gt; 2 returns TRUE, but 2 &gt; 3 returns FALSE. Less than (&lt;): This operator returns TRUE if the left operand is smaller than the right operand, and FALSE otherwise. Greater than or equal to (&gt;=): This operator returns TRUE if the left operand is larger than or equal to the right operand, and FALSE otherwise. For example, 3 &gt;= 2 and 3 &gt;= 3 both return TRUE, but 2 &gt;= 3 returns FALSE. Less than or equal to (&lt;=): As above, this operator returns TRUE if the left operand is smaller than or equal to the right operand, and FALSE otherwise. The comparison is going to be consistent with the equality and inequality operators, meaning that if x == y, then x &gt;= y and x &lt;= y are both TRUE, and if x != y, then either x &gt; y or x &lt; y is TRUE. As an exercise, try to compare two integers, two doubles, or two variables, as done above, but with the inequality operators, and see the result. In the next section, we will introduce you to another important aspect of logic: logical arithmetic. Logical arithmetic is the process of combining and manipulating logical values, such as TRUE and FALSE, using logical operators, such as AND and OR. Logical arithmetic can be used for various purposes, such as creating complex conditions, testing multiple hypotheses, or performing set operations. 2.2 Logical Arithmetic This might seem easy if you already have a background in logic, but even if you haven’t, the following paragraphs should cover all the necessary concepts that you will need for programming. Logical arithmetic is the process of combining and manipulating logical values, TRUE and FALSE, which are logic operands, using the logical operators AND and OR or NOT. Let’s start from AND and OR: The AND operator returns TRUE if both operands are TRUE, and FALSE otherwise. The OR operator returns TRUE if either or both operands are TRUE, and FALSE otherwise. The NOT operator returns the opposite of the operand, e.g. NOT TRUE gives FALSE. We can use the AND and OR operators to combine two logical values, such as TRUE and FALSE, as shown below: R # Using the AND operator TRUE &amp; TRUE ## [1] TRUE TRUE &amp; FALSE ## [1] FALSE FALSE &amp; TRUE ## [1] FALSE FALSE &amp; FALSE ## [1] FALSE # Using the OR operator TRUE | TRUE ## [1] TRUE TRUE | FALSE ## [1] TRUE FALSE | TRUE ## [1] TRUE FALSE | FALSE ## [1] FALSE python # Using the AND operator True and True ## True True and False ## False False and True ## False False and False ## False # Using the OR operator True or True ## True True or False ## True False or True ## True False or False ## False The syntax and the output are very similar in both languages, except that R uses AND and OR for AND and OR, while Python uses and and or. More formally, we can use a table to show all the possible outcomes of the AND and OR operators. Let’s say that \\(a, \\ b\\) are our operands, then: \\(a\\) \\(b\\) \\(a\\) AND \\(b\\) \\(a\\) OR \\(b\\) TRUE TRUE TRUE TRUE TRUE FALSE FALSE TRUE FALSE TRUE FALSE TRUE FALSE FALSE FALSE FALSE The table has four rows, corresponding to the four possible combinations of the operands a and b. Again, the table is easy to build, as it shows a AND b is only TRUE when both a and b are TRUE, a OR b is only FALSE when both a and b are FALSE. 2.2.1 Precendence of operators In logical operations, as in general algebra, the precedence of operators determines the order in which operations are performed: Logical NOT: This operator has the highest precedence and is performed first Logical AND: This operator has the next highest precedence after Logical NOT Logical OR: This operator has lower precedence than Logical AND So, in an expression without parentheses, the NOT operation is performed first, followed by the AND operation, and finally the OR operation. For example, in the expression p or NOT q AND r is p OR ((NOT q) AND r), the operations would be performed in the following order: NOT q is performed first due to the highest precedence of NOT. Then, (NOT q) AND r is performed due to the next highest precedence of AND. Finally, ((NOT q) AND r) OR p is performed due to the lowest precedence of OR. Parentheses can be used to change this order. For example, in the expression p AND (q OR r), the operation q OR r is performed first due to the parentheses, even though AND has lower precedence than OR. For example, consider the following expression: TRUE OR TRUE AND FALSE Without parentheses, in this expression the AND operator has higher precedence than the OR operator, so it is evaluated first. The result is then combined with the OR operator. The expression is equivalent to: TRUE OR (TRUE AND FALSE) However, if we use parentheses to group the operands differently, we can change the order of evaluation and the result of the expression. If we use parentheses to group the first and the last operands, we get: (TRUE OR TRUE) AND FALSE The value of this expression is in fact FALSE. Now, the OR operator is evaluated first, giving TRUE and the result is then combined with the AND operator, giving FALSE. 2.2.1.1 Exercise To test your understanding of logical arithmetic, try to find what is the value of: TRUE OR TRUE AND FALSE? FALSE OR FALSE AND TRUE? (TRUE AND FALSE) OR (FALSE AND TRUE)? (TRUE OR TRUE) AND FALSE? (TRUE OR FALSE) AND (FALSE OR TRUE)? You should use the console in R or Python to check your answers. You can review the table and the examples above, and try to understand the logic behind each expression. 2.3 Flow Another important aspect of logic is flow. Flow is the order and direction in which the instructions of a program are executed and is at the base of an algorithm. Normally, a computer program, has a start, it will do something, and then terminate (return an output). This is called the flow of a program. Now, of course, to control the flow, you need a mechanism that checks on the state of your program, and performs an action based on the state in which you are. Surprisingly enough, we run programs in every day tasks too. When driving down from Glasgow to London, we need to check where we are, and turn the steering wheel accordingly in such a way that our car points towards South. When doing the laundry in a laundrette, we first check the amounts of money we have, and then, if we have enough, load up the washing machine, if we don’t, well, we need to get some more. Or say, for example, that you need to code something, maybe for an assignment :) What you might end up doing, is the following: I have to remark that this was a joke: remember that if you cheat at this stage with programming you are just cheating yourself. More formally, in computer programs, flow can be controlled by using conditional statements, such as if - else if - else. Conditional statements allow us to execute different blocks of code depending on the result of a logical expression or condition. For example, we can use conditional statements to perform different actions based on the value of a variable, the input of the user, or the outcome of a calculation. 2.3.1 The if-then-else statement The simplest form of a conditional statement is the if statement. The if statement checks a single condition, and executes a block of code if the condition is true. For example, we can use an if statement to print a message if a variable is positive, as shown below: R # Assigning a value to a variable x &lt;- 10 # Using an if statement if (x &gt; 0) { print(&quot;x is positive&quot;) } ## [1] &quot;x is positive&quot; python # Assigning a value to a variable x = 10 # Using an if statement if x &gt; 0: print(&quot;x is positive&quot;) # add a new line below without indentation ## x is positive Concerning syntax, e.g. the way we write the code: To enclose the condition that is checked by the if statement, e.g. where your logic expression goes (e.g. the block of code that evaluates either to TRUE or FALSE): R uses an if followed by parentheses (), where the condition goes Python has no parentheses, but has a : symbol to indicate that the condition has ended and the block of code to execute has started To denote the block of code to execute if the condition is true: R uses curly braces {} to enclose the block of code that is executed if the condition is true. All code that is relative to the if condition needs to be within these brackets Python, uses indentation to delimit the block of execution. All code that needs to execute needs to be indented at the same level. Indentation in Python is achieved either with a tab (recommended), or with 4 spaces. NOTE: An additional empty line without identation (e.g. a simple white space) is needed below the if- block, otherwise Python won’t be able to understand that the block has ended. Generally, for this reason, it’s a good habit to save your Python scripts always with an empty line at the end The if statement only executes the block of code if the condition is true, and does nothing otherwise. This means, that if the condition is FALSE, the program will simply skip the code within the block, as if it never existed. Sometimes, we may want to check more than one condition, and execute different blocks of code for each condition. For this, we can use the if - else if - else statement. The if - else if - else statement checks multiple conditions in order, and executes the first block of code that corresponds to a true condition. If none of the conditions are true, the else block of code is executed. For example, we can use an if - else if - else statement to print a message based on the sign of a variable, as shown below: R # Assigning a value to a variable x &lt;- 10 # Using an if - else if - else statement if (x &lt; 0) { print(&quot;x is negative&quot;) } else if (x == 0) { print(&quot;x is zero&quot;) } else { print(&quot;x is positive&quot;) } ## [1] &quot;x is positive&quot; # x is positive python # Assigning a value to a variable x = 10 # Using an if - else if - else statement if x &lt; 0: print(&quot;x is negative&quot;) elif x == 0: print(&quot;x is zero&quot;) else: print(&quot;x is positive&quot;) ## x is positive # x is positive Concerning syntax, R uses else if and Python uses elif for the second condition. The order of the conditions is important, as only the first condition that is true is executed. If none of the conditions are true, the else block is executed. Sometimes, we may want to check two or more independent conditions, and execute different blocks of code for each condition. For this, we can use two or more if statements one after another. This is different from using an if - else if - else statement, as each if statement is evaluated separately, and more than one block of code can be executed. For example, we can use two if statements to print a message based on the divisibility of a variable by 2 and 3, as shown below: R # Assigning a value to a variable n &lt;- 12 # Using two if statements if (n %% 2 == 0) { print(&quot;n is divisible by 2&quot;) } ## [1] &quot;n is divisible by 2&quot; if (n %% 3 == 0) { print(&quot;n is divisible by 3&quot;) } ## [1] &quot;n is divisible by 3&quot; # n is divisible by 2 # n is divisible by 3 python # Assigning a value to a variable n = 12 # Using two if statements if n % 2 == 0: print(&quot;n is divisible by 2&quot;) ## n is divisible by 2 if n % 3 == 0: print(&quot;n is divisible by 3&quot;) ## n is divisible by 3 # n is divisible by 2 # n is divisible by 3 In R the modulo operator is %%, while Python uses %. Both if statements are executed, as both conditions are true. If we used an if - else if - else statement instead, only the first condition would be executed, and the second condition would be ignored. 2.3.2 Nesting if-statements Sometimes, we may want to check a condition within another condition, and execute different blocks of code for each combination. For this, we can use a nested if statement. A nested if statement is an if statement inside another if statement. A nested if statement can have multiple levels of nesting, and can also include else if and else blocks. For example, we can use a nested if statement to print a message based on the value and the sign of a variable, as shown below: R # Assigning a value to a variable x &lt;- -10 # Using a nested if statement if (x &gt; 0) { if (x &gt; 10) { print(&quot;x is positive and greater than 10&quot;) } else { print(&quot;x is positive and less than or equal to 10&quot;) } } else { if (x &lt; -10) { print(&quot;x is negative and less than -10&quot;) } else { print(&quot;x is negative and greater than or equal to -10&quot;) } } ## [1] &quot;x is negative and greater than or equal to -10&quot; python # Assigning a value to a variable x = -10 # Using a nested if statement if x &gt; 0: if x &gt; 10: print(&quot;x is positive and greater than 10&quot;) else: print(&quot;x is positive and less than or equal to 10&quot;) else: if x &lt; -10: print(&quot;x is negative and less than -10&quot;) else: print(&quot;x is negative and greater than or equal to -10&quot;) ## x is negative and greater than or equal to -10 Concerning syntax, you can now see the double indentation in the python code. The nested if statement checks the outer condition first (x being positive), and then checks the inner condition if the outer condition is true (x being greater then 10). Note also that the nested if statement can have multiple levels of nesting, and can also include else if and else blocks. In the next section, we will introduce you to a fun and popular game that involves logic and flow: FizzBuzz. 2.3.3 FizzBuzz FizzBuzz is a game that tests your ability to use logic and flow in programming. The rules of the game are simple: given a number, print “Fizz” if the number is divisible by 3, print “Buzz” if the number is divisible by 5, print “FizzBuzz” if the number is divisible by both 3 and 5, and print the number itself otherwise. For example, given the number 15, print “FizzBuzz”, given the number 9, print “Fizz”, given the number 10, print “Buzz”, and given the number 7, print 7. To play FizzBuzz in R or Python, we can use a variable to store the number, and then use an if - else if - else statement to check the conditions and print the output, as shown below: R # Assigning a value to a variable n &lt;- 15 # Playing FizzBuzz if (n %% 3 == 0 &amp; n %% 5 == 0) { print(&quot;FizzBuzz&quot;) } else if (n %% 3 == 0) { print(&quot;Fizz&quot;) } else if (n %% 5 == 0) { print(&quot;Buzz&quot;) } else { print(n) } ## [1] &quot;FizzBuzz&quot; python # Assigning a value to a variable n = 15 # Playing FizzBuzz if n % 3 == 0 and n % 5 == 0: print(&quot;FizzBuzz&quot;) elif n % 3 == 0: print(&quot;Fizz&quot;) elif n % 5 == 0: print(&quot;Buzz&quot;) else: print(n) ## FizzBuzz The Fizzbuzz condition uses the modulo %% (% in Python) operator. This, recall, returns the remainder of the division. The logical and operator returns true if both operands are true. Note also that the order of the conditions is important, as we need to check the divisibility by both 3 and 5 first, and then we check the divisibility by 3 or 5 separately. To see how FizzBuzz works, try to replace the value of the variable n with different numbers, and see what the output is. For example, try n &lt;- 45 in R, or n = 45 in Python, and see what happens! 2.3.3.1 Exercise: Skibbidifizzbuzz As an exercise, try to write a variation of FizzBuzz, called Skibbidifizzbuzz, where the rules are the same as above, but now you have to add “Skibbidi” if the number is divisible by 2. For example, given the number 12, print “SkibbidiFizz”, given the number 20, print “SkibbidiBuzz”, given the number 30, print “SkibbidiFizzBuzz”, and given the number 8, print “Skibbidi”. HINT To write a quick solution, you will need to collate strings. This means that if we have the strings \"a\", \"b\", collated those will be \"ab\", and if we have \"a\", \"b\", \"b\", \"a\", collated they will read \"abba\" (mammamia). To collate strings in R and python: R # collate strings paste0(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;) ## [1] &quot;abbc&quot; # you can also collate strings saved in variables string_in_a_variable &lt;- &quot;mia&quot; paste0(&quot;mamma&quot;, string_in_a_variable) ## [1] &quot;mammamia&quot; python # collate strings &quot;a&quot; + &quot;b&quot; + &quot;b&quot; + &quot;c&quot; ## &#39;abbc&#39; # you can also collate strings saved in variables string_in_a_variable = &quot;mia&quot; &quot;mamma&quot; + string_in_a_variable ## &#39;mammamia&#39; Which strings could you collate for “SkibbidiFizzBuzz”? 2.4 Vectors We now introduce the first (and the most fundamental!) data structures in programming: vectors. Vectors, as in maths, are ordered collections of values that can be manipulated as a single unit. All elements in a vector need to be homogeneous, e.g. of the same type, for example we cannot have a vector with a string and an integer together. Later on, when we will introduce matrices, we will find out that these are nothing but a collection of vectors (vectors of vectors). And we, in maths, know how powerful linear algebra is: through vectors, we can store, process, and analyze large amounts of numerical data efficiently and elegantly. 2.4.1 Creating vectors We will now see how to create and use vectors in R and Python, and how to perform element wise operations on vectors. To create a vector in R, we use the c function, which stands for concatenate. The c function takes one or more values as arguments, and returns a vector that contains those values. For example, we can create a vector that contains the numbers 1, 2, and 3, as shown below: # Creating a vector in R x &lt;- c(1, 2, 3) x ## [1] 1 2 3 To create a vector in Python, we use the array function from the numpy module, which stands for numerical Python. While technically the Python array is not the same of an R vector (as you can have arrays of arrays, which is a similar structure to a matrix), we will use the Python array interchangeably for now, as they behave very similar and they fulfill similar roles. The first thing to use arrays in python, is to import the numpy array. The numpy module is a library that provides various tools and functions for working with numerical data and scientific computing. The array function takes a list as an argument, and returns an array that contains the elements of the list. A list, in Python, is another, built-in structure to represent and ordered set of data, but it comes from the original python, was designed with different aims, and comes with a lot less powers then the numpy array. So for now, please stick to the following when you create vectors in python. We can create an array that contains the numbers 1, 2, and 3, as shown below: # Importing the numpy module import numpy as np # This is a simple python list [1, 2, 3] ## [1, 2, 3] # Creating an array in Python x = np.array([1, 2, 3]) x ## array([1, 2, 3]) We need to import the numpy library before using the array function, and we use the alias np to refer to the module. Therefore, before we proceed it is probably a good time to introduce what a library is. 2.4.1.1 Libraries A library is a collection of code that provides predefined functions, classes, variables, and other resources that can be used by other programs. Libraries can save time and effort by allowing programmers to reuse existing code and avoid writing everything from scratch. Libraries can also enhance the functionality and the performance of a programming language by offering specialized tools and features that are not built-in. For example, the numpy library is a library that provides various tools and functions for working with numerical data and scientific computing. The numpy library is not part of the standard Python language, but it can be installed and imported by using the import statement. The import statement tells Python to load the library and make it available for use. The import statement can also assign an alias or a nickname to the library, such as np, to make it easier to refer to the library in the code. Normally, one has to reference import numpy as np only at the beginning of the script, before using any of the functions or resources from the numpy library: python # this is the math library from past week! import math # Importing the numpy library and assigning an alias import numpy as np # rest of your script! # # ~~~~~~~~~~~~~~~~~~~~~~~~~~~ # This way, Python knows where to find the functions that is needed, and the programmer does not have to repeat the import statement every time. R has libraries too, those are imported via the command library. For example, at one point, we will be calling the tidyverse library, that is a collection of functions for modern R: R library(tidyverse) ## ── Attaching core tidyverse packages ─────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse 2.0.0 ── ## ✔ dplyr 1.1.2 ✔ readr 2.1.4 ## ✔ forcats 1.0.0 ✔ stringr 1.5.0 ## ✔ ggplot2 3.4.2 ✔ tibble 3.2.1 ## ✔ lubridate 1.9.2 ✔ tidyr 1.3.0 ## ✔ purrr 1.0.1 ## ── Conflicts ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() ## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors We call these at a later time as R has already plenty of scientific computing functions and structures built in. 2.4.1.2 Creating sequences One of the common ways to create vectors or arrays is to use sequences. Sequences are ordered collections of values that follow a certain pattern or rule. Sequences can be useful for generating data, plotting, or creating loops, as we will see later on. As you will see, here the syntax is going to be a bit different in each language, as R uses functions such : or seq and Python uses np.arange or np.linspace to create and initialize vectors. We will see how to create sequences of integers, any sequence of equally spaced numbers, and finally, how to initialize an empty vectors with all same values. To create a sequence of integers in R, we can use the colon operator :, in Python, we can use the arange function from numpy. Both take two integers as arguments, and returns a vector or an array that contains all the integers from the first argument to the second argument, with a step size of 1. For example, we can create a sequence of integers from -5 to 10, as shown below: R # Creating a sequence of integers from -5 to 10 x &lt;- -5:10 x ## [1] -5 -4 -3 -2 -1 0 1 2 3 4 5 6 7 8 9 10 python # Creating a sequence of integers from -5 to 10 x = np.arange(-5, 11) x ## array([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) Differently from R, arange requires the second argument to be one step more than the desired end point of the sequence, so if we want to go up to 10, we need to have the second argument to be 11. To create any sequence, we can use the seq function in R, and the arange or linspace functions in Python. For example, we can create a sequence of numbers from 0 to 1, with a step size of 0.1, or with a length of 11, as shown below: R The seq function in R can take named arguments, such as from, to, by, or length.out, to specify the parameters of the sequence. # Creating a sequence of numbers from 0 to 1, with a step size of 0.1 x &lt;- seq(from = 0, to = 1, by = 0.1) x ## [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 # Creating a sequence of numbers from 0 to 1, with a length of 11 y &lt;- seq(from = 0, to = 1, length.out = 11) y ## [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 python The np.arange function in Python, with an additional argument, will indicate the step size. Again, in this case, arange requires the second argument to be one step more than the desired end point of the sequence. The np.linspace function, instead, will create a vector of a desired length (11 elements) of equally spaced elements. It requires the third argument to be the desired length of the sequence. # Creating a sequence of numbers from 0 to 1, with a step size of 0.1 x = np.arange(0, 1.1, 0.1) x ## array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ]) # Creating a sequence of numbers from 0 to 1, with a length of 11 y = np.linspace(0, 1, 11) y ## array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ]) Empty vectors. Lastly, there might be some cases where we have to create an empty vector or array in R and Python. An empty vector or array can be useful for initializing a vector or array that will be filled with values later, as we will see in the next chapters. For this, we can use the vector or array function, respectively, and specify the type and the length of the vector or array. An empty vector or array is a vector or array that contains no values, but has a predefined type and length. For example, we can create an empty vector or array of type numeric and length 5, as shown below: R # Creating an empty vector of type numeric and length 5 x &lt;- vector(mode = &quot;numeric&quot;, length = 5) x ## [1] 0 0 0 0 0 python # Creating an empty array of type numeric and length 5 x = np.empty(5, dtype = &quot;float&quot;) x ## array([4.9e-324, 9.9e-324, 1.5e-323, 2.0e-323, 2.5e-323]) Note that the vector function in R takes the mode argument to specify the type of the vector, and the length argument to specify the length of the vector. The np.empty function in Python takes the the length of the array as the first argument, and the dtype argument to specify the type of the array, e.g. integer, float, Python object, etc. 2.4.2 Modifying vectors One of the main advantages of using vectors or arrays is that we can perform elementwise operations on them. Elementwise operations are operations that are applied to each element of the vector or the array individually, and return a new vector or array that contains the results. Elementwise operations preserve the shape and the length of the vector or the array, meaning that the resulting vector or array has the same number of elements as the original vector or array. For example, we can add, subtract, multiply, or divide a vector or an array by a scalar (which is a single value): R x &lt;- 1:5 # Raw vector x ## [1] 1 2 3 4 5 # Adding a scalar to a vector x + 1 ## [1] 2 3 4 5 6 # Subtracting a scalar from a vector x - 1 ## [1] 0 1 2 3 4 # Multiplying a vector by a scalar x * 2 ## [1] 2 4 6 8 10 # Dividing a vector by a scalar x / 2 ## [1] 0.5 1.0 1.5 2.0 2.5 python x = np.arange(1, 6) # Raw vector x ## array([1, 2, 3, 4, 5]) # Adding a scalar to an array x + 1 ## array([2, 3, 4, 5, 6]) # Subtracting a scalar from an array x - 1 ## array([0, 1, 2, 3, 4]) # Multiplying an array by a scalar x * 2 ## array([ 2, 4, 6, 8, 10]) # Dividing an array by a scalar x / 2 ## array([0.5, 1. , 1.5, 2. , 2.5]) The element wise operations are performed by using the same arithmetic operators as the past chapter, such as +, -, *, and /. 2.4.2.1 Functions and algebra with vectors But we can do more! One of the benefits of using vectors or arrays is that we can apply a whole function, such as sin(.) or log(.), on the entire vector elementwise. This means that the function is applied to each element of the vector individually, and returns a new vector that contains the results. For example, let’s apply the sin(.) function, which calculates the sine of an angle in radians, on a vector that contains the angles \\(0\\), \\(\\pi/2\\), \\(\\pi\\), and \\(3 \\pi/2\\): R # Creating a vector of angles in radians x &lt;- c(0, pi/2, pi, 3*pi/2) x ## [1] 0.000000 1.570796 3.141593 4.712389 # Applying the sin function on the vector elementwise sin(x) ## [1] 0.000000e+00 1.000000e+00 1.224647e-16 -1.000000e+00 python # Creating an array of angles in radians x = np.array([0, np.pi/2, np.pi, 3*np.pi/2]) x ## array([0. , 1.57079633, 3.14159265, 4.71238898]) # Applying the sin function on the array elementwise np.sin(x) ## array([ 0.0000000e+00, 1.0000000e+00, 1.2246468e-16, -1.0000000e+00]) The function is applied to each element of the vector or the array individually, and returns a new vector or array that contains the results. Note also that by default the results are in scientific notation. We can also apply many other functions! Go back to last week introduction and see how many of the functions we introduced already, such as log(), run elementwise on vectors. And as we can sum two scalars, another benefit of using vectors or arrays is that we can do elementwise product and sum of two vectors. If two vectors or arrays are the same length, this will return a new vector or array that contains the elementwise results of your desired operation: R # Creating two vectors of the same length x &lt;- 1:4 y &lt;- 5:8 # Doing elementwise product of two vectors x * y ## [1] 5 12 21 32 # Doing elementwise sum of two vectors x + y ## [1] 6 8 10 12 python # Creating two arrays of the same length x = np.arange(1, 5) y = np.arange(5, 9) # Doing elementwise product of two arrays x * y ## array([ 5, 12, 21, 32]) # Doing elementwise sum of two arrays x + y ## array([ 6, 8, 10, 12]) The elementwise product and sum are performed by using the same arithmetic operators as before, such as * and +. Note also that the elementwise product and sum preserve the shape and the length of the vectors or the arrays, meaning that the resulting vector or array has the same number of elements as the input vectors or arrays. 2.4.2.2 Doing the dot product of two vectors Lastly, one important operation that we can do with vectors or arrays is the dot product, and this will be super useful to you in the future as you will deal with applications in linear algebra, geometry, and machine learning. Recall that the dot product takes two vectors or arrays of the same length, and returns a single number that is the sum of the elementwise products of the vectors or arrays. For example, the dot product of the vectors [1, 2, 3, 4] and [5, 6, 7, 8] is 1*5 + 2*6 + 3*7 + 4*8 = 70. To calculate the dot product of two vectors or arrays in R and Python, we use the following functions: In R, we use the %*% operator, which performs matrix multiplication. If the input vectors are one-dimensional, the matrix multiplication is equivalent to the dot product. For example, we can calculate the dot product of two vectors, as shown below: # Doing the dot product of two vectors x %*% y ## [,1] ## [1,] 70 In Python, we use the dot function from the numpy module, which performs the dot product of two arrays. For example, we can calculate the dot product of two arrays, as shown below: # Doing the dot product of two arrays np.dot(x, y) ## 70 The syntax are quite different in both languages, as R uses a special operator and Python uses a function from numpy. Note also that the dot product requires the input vectors or arrays to have the same length, otherwise it will produce an error. We will cover how to do algebra with Python and R in the next chapters. 2.5 Accessing vectors We will see now how to access the elements of a vector. Accessing the elements of a vector or an array is important as it allows us to select, extract and even modify specific values or subsets of values from a vector. 2.5.1 Checking the size and dimension of a vector Before we access the elements of a vector or an array, it is useful to know the size and the dimension of the vector or the array. The size of a vector or an array is the number of elements that it contains. The dimension, on the other hand, is the number of axes or directions that it has. For example, a one-dimensional vector or array has only one axis or direction, and a two-dimensional vector or a matrix will have two axes or directions, such as rows and columns. To check the size and the dimension of a vector or an array in R and Python, we can use the following functions: In R, we can use the length function to get the size of a vector, and the dim function to get the dimension of a vector. R # Creating a vector of numbers x &lt;- 1:4 # Checking the size of the vector length(x) ## [1] 4 # Checking the dimension of the vector dim(x) ## NULL The length function returns the number of elements in the vector, which is 4, and the dim function returns NULL, which means that the vector has no dimension. This is because a vector in R is always one-dimensional, and the dim function is more useful for higher-dimensional objects, such as matrices or data frames. We will learn about these structures later on, so do not worry about it for now. In Python, we can use the size attribute or the len function to get the size of an array, and the shape attribute or the ndim attribute to get the dimension of an array. python # Creating an array of numbers x = np.arange(1, 4) # Checking the size of the array x.size ## 3 # 4 len(x) ## 3 # 4 # Checking the dimension of the array x.shape ## (3,) # (4,) x.ndim ## 1 # 1 The size attribute and the len function both return the number of elements in the array, which is 4, and the shape attribute and the ndim attribute both return the dimension of the array, which is 1. The shape attribute returns a tuple, that contains the length of each axis of the array, and the ndim attribute returns an integer that represents the number of axes of the array. Note that a one-dimensional array in Python has a shape of (n,), where n is the size of the array, and a comma is needed to indicate that it is a tuple. A tuple is another one dimentional structure in Python, but for now you can treat it as just a couple of numbers. 2.5.2 Accessing Vector Elements We can access the elements of the vector or the array by using indexing. Indexing is a way of referring to a specific element or a subset of elements of a vector or an array by using their position or location. Every element of a vector, in fact, has an index, that is a number that indicates its order in the vector. Indexing the elements of a vector or an array in R and Python has a fundamental difference that you need to be extremely careful about. R uses what is called one-based indexing, while Python uses zero-based indexing. This means that R starts counting the elements of a vector or an array from 1, e.g. the first element starts at one, while Python starts counting the elements of a vector or an array from 0. This difference can cause confusion and errors if you are not aware of it, so you need to pay attention to the indexing system of each language: R # The index will be # 1 2 3 4 x &lt;- c(1, 2, 3, 4) python # The index will be: # 0 1 2 3 x = np.array([1, 2, 3, 4]) Let’s see how to practically access the single elements by using indexing. In R, the elements of a vector are indexed from 1 to the size of the vector, and we can use the square brackets [ ] to access them by using their index. # Accessing the first element of the vector x[1] ## [1] 1 # Accessing the last element of the vector x[length(x)] ## [1] 4 # Accessing any element of the vector x[3] ## [1] 3 The first element of the vector has an index of 1, the last element of the vector has an index of the size of the vector, which is 4. The square brackets [ ] are used to access the elements of the vector: therefore the index must be an integer between 1 and the size of the vector, otherwise it will produce an error or a missing value. In Python, the elements of an array are indexed from 0 to the size of the array minus 1, and we can use the square brackets [ ] to access them by using their index. # Accessing the first element of the array x[0] ## 1 # Accessing the last element of the array x[len(x) - 1] ## 4 # Accessing any element of the array x[2] ## 3 In Python, the first element of the array has an index of 0, the last element of the array has an index of the size of the array minus 1, which in our case is 3. The square brackets [ ] are used to access the elements of the array by using their index, and that the index must be an integer between 0 and the size of the array minus 1, otherwise it will produce an error or an out of bounds exception. Differently from R, in Python, however we can access the arrays from the back, using negative integers. Try: # Accessing the last element of the array x[-1] ## 4 # Accessing the second last element of the array x[-2] ## 3 # Accessing the first element of the array x[-len(x)] ## 1 2.5.2.1 Accessing multiple elements at once In addition to accessing a single element of a vector or an array, we can also access multiple elements at once by using indexing. This can be useful for selecting, modifying, or extracting specific values or subsets of values from a vector or an array. There are different ways to access multiple elements at once, depending on the criteria or the pattern that we want to use. To access any sequence of elements of a vector or an array, we can use sequences of integers as indices. This means we can use the colon operator : to create sequences of integers in R and Python, as we saw in the previous section, and use these to access and splice the first three elements, the last three elements, or even the even-indexed elements of a vector or an array (pun not intended). R # Creating a vector of the first 6 integers x &lt;- 1:6 # Accessing the first three elements of the vector x[1:3] ## [1] 1 2 3 # Accessing the last three elements of the vector # index is 4, 5, 6 x[(length(x) - 2):length(x)] ## [1] 4 5 6 # Accessing the even-indexed elements of the vector x[seq(from = 2, to = length(x), by = 2)] ## [1] 2 4 6 python # Creating an array of the first 6 integers x = np.arange(1, 7) # Accessing the first three elements of the array x[0:3] ## array([1, 2, 3]) # Accessing the last three elements of the array # index is 3, 4, 5 x[(len(x) - 3):len(x)] ## array([4, 5, 6]) # Accessing the even-indexed elements of the array x[np.arange(1, len(x), 2)] ## array([2, 4, 6]) Recall that R uses one-based indexing and Python uses zero-based indexing. The sequences of integers for accesing the indeces are created by using the colon operator : or the seq function in R, and the np.arange function in Python. The sequences of integers can have different start, end, or step values, depending on the desired subset of elements. Try to experiment a bit with the start and end values of the subsets introduced above! Similarly, we can use vectors or arrays of integers as indices to access multiple elements at every location. To do so, we will first create some vectors, and then use those vectors to access the elements of other vectors respectively. For example, we can access three elements at random of a vector or an array, as shown below: R # Accessing element 2, 5 and 6 of the vector x[c(2, 5, 6)] ## [1] 2 5 6 # note how in this way we can shuffle order! x[c(2, 6, 5)] ## [1] 2 6 5 python # Accessing element 2, 5 and 6 of the vector x[[1, 4, 5]] ## array([2, 5, 6]) # note how in this way we can shuffle order! x[[1, 5, 4]] ## array([2, 6, 5]) To access multiple elements at random of a vector or an array, we can also use vectors or arrays of booleans as indices. Vectors or arrays of booleans are collections of logical values, as introduced above, e.g. either TRUE or FALSE. In this case, it is important that the vectors or arrays of booleans have the same length as the vector or the array, and that only the elements that correspond to TRUE (in R) or True (in Python) values are selected. R # boolean index vector: # 2 5 6 index &lt;- c(FALSE, TRUE, FALSE, FALSE, TRUE, TRUE) # Accessing element 2, 5 and 6 of the vector x[index] ## [1] 2 5 6 python # boolean index vector: # 1 4 5 index = [False, True, False, False, True, True] # Accessing element 2, 5 and 6 of the vector x[index] ## array([2, 5, 6]) Why is this useful? Well, with this trick, we can use logical operators obtained by logical arithmetic to create vectors or arrays of booleans in R and Python. For example, we can access the elements that are greater than 3 of a vector or an array, as shown below: R # Creating a vector of numbers x &lt;- c(1, 2, 3, 4, 5, 6) # Accessing the elements that are greater than 3 of the vector x[x &gt; 3] ## [1] 4 5 6 # Accessing even elements x[x %% 2 == 0] ## [1] 2 4 6 python # Creating an array of numbers x = np.array([1, 2, 3, 4, 5, 6]) # Accessing the elements that are greater than 3 of the array x[x &gt; 3] ## array([4, 5, 6]) # Accessing even elements x[x % 2 == 0] ## array([2, 4, 6]) 2.5.2.2 Overwriting elements of vectors Finally, as we can overwrite variables, we can overwrite single (or multiple!) elements of a vector without modifying the entire vector. This is essentially achieved by selecting the elements of interest, and then assigning new elements to those. The replacement, of course needs to be of the same length of the elements we wish to replace. If the new values are not compatible with the type and the length of the vector, both languages will produce an error or a warning. In R, we can use the square brackets [ ] to access the elements of the vector by using their index, and the left arrow &lt;- to assign new values to them. For example, to overwrite the first element, the last element, and the third element: R # Creating a vector of numbers x &lt;- c(1, 2, 3, 4) # Overwriting the first element of the vector x[1] &lt;- 10 x ## [1] 10 2 3 4 # Overwriting the last element of the vector x[length(x)] &lt;- 20 x ## [1] 10 2 3 20 # Overwriting any element of the vector x[3] &lt;- 30 x ## [1] 10 2 30 20 In Python, we can use the square brackets [ ] to access the elements of the array by using their index, and the equal sign = to assign new values to them. For example, to overwrite the first element, the last element, and third element: python # Creating an array of numbers x = np.array([1, 2, 3, 4]) # Overwriting the first element of the array x[0] = 10 x ## array([10, 2, 3, 4]) # Overwriting the last element of the array x[len(x) - 1] = 20 x ## array([10, 2, 3, 20]) # Overwriting any element of the array x[2] = 30 x ## array([10, 2, 30, 20]) In this code, the square brackets [ ] are used to access the elements of the array by using their index, and the equal sign = is used to assign new values to them Note that the final vector has the three elements we accessed all changed. As mentioned, we can select and replace multiple elements simultaneously in a single command, look for instance at the code below. 2.5.2.3 Exercise: vector fizzbuzz You are ready to see your first complex program. Can you tell what it does? Break down, comment and describe the following code, and adapt it do perform Skibbidifizzbuzz. R x &lt;- 1:100 fizz_index &lt;- x %% 3 == 0 buzz_index &lt;- x %% 5 == 0 x[fizz_index] &lt;- &quot;fizz&quot; x[buzz_index] &lt;- &quot;buzz&quot; x[fizz_index &amp; buzz_index] &lt;- &quot;fizzbuzz&quot; x ## [1] &quot;1&quot; &quot;2&quot; &quot;fizz&quot; &quot;4&quot; &quot;buzz&quot; ## [6] &quot;fizz&quot; &quot;7&quot; &quot;8&quot; &quot;fizz&quot; &quot;buzz&quot; ## [11] &quot;11&quot; &quot;fizz&quot; &quot;13&quot; &quot;14&quot; &quot;fizzbuzz&quot; ## [16] &quot;16&quot; &quot;17&quot; &quot;fizz&quot; &quot;19&quot; &quot;buzz&quot; ## [21] &quot;fizz&quot; &quot;22&quot; &quot;23&quot; &quot;fizz&quot; &quot;buzz&quot; ## [26] &quot;26&quot; &quot;fizz&quot; &quot;28&quot; &quot;29&quot; &quot;fizzbuzz&quot; ## [31] &quot;31&quot; &quot;32&quot; &quot;fizz&quot; &quot;34&quot; &quot;buzz&quot; ## [36] &quot;fizz&quot; &quot;37&quot; &quot;38&quot; &quot;fizz&quot; &quot;buzz&quot; ## [41] &quot;41&quot; &quot;fizz&quot; &quot;43&quot; &quot;44&quot; &quot;fizzbuzz&quot; ## [46] &quot;46&quot; &quot;47&quot; &quot;fizz&quot; &quot;49&quot; &quot;buzz&quot; ## [51] &quot;fizz&quot; &quot;52&quot; &quot;53&quot; &quot;fizz&quot; &quot;buzz&quot; ## [56] &quot;56&quot; &quot;fizz&quot; &quot;58&quot; &quot;59&quot; &quot;fizzbuzz&quot; ## [61] &quot;61&quot; &quot;62&quot; &quot;fizz&quot; &quot;64&quot; &quot;buzz&quot; ## [66] &quot;fizz&quot; &quot;67&quot; &quot;68&quot; &quot;fizz&quot; &quot;buzz&quot; ## [71] &quot;71&quot; &quot;fizz&quot; &quot;73&quot; &quot;74&quot; &quot;fizzbuzz&quot; ## [76] &quot;76&quot; &quot;77&quot; &quot;fizz&quot; &quot;79&quot; &quot;buzz&quot; ## [81] &quot;fizz&quot; &quot;82&quot; &quot;83&quot; &quot;fizz&quot; &quot;buzz&quot; ## [86] &quot;86&quot; &quot;fizz&quot; &quot;88&quot; &quot;89&quot; &quot;fizzbuzz&quot; ## [91] &quot;91&quot; &quot;92&quot; &quot;fizz&quot; &quot;94&quot; &quot;buzz&quot; ## [96] &quot;fizz&quot; &quot;97&quot; &quot;98&quot; &quot;fizz&quot; &quot;buzz&quot; python x = np.arange(1, 101, dtype=object) fizz_index = x % 3 == 0 buzz_index = x % 5 == 0 x[fizz_index] = &quot;fizz&quot; x[buzz_index] = &quot;buzz&quot; x[np.logical_and(fizz_index, buzz_index)] = &quot;fizzbuzz&quot; x ## array([1, 2, &#39;fizz&#39;, 4, &#39;buzz&#39;, &#39;fizz&#39;, 7, 8, &#39;fizz&#39;, &#39;buzz&#39;, 11, &#39;fizz&#39;, ## 13, 14, &#39;fizzbuzz&#39;, 16, 17, &#39;fizz&#39;, 19, &#39;buzz&#39;, &#39;fizz&#39;, 22, 23, ## &#39;fizz&#39;, &#39;buzz&#39;, 26, &#39;fizz&#39;, 28, 29, &#39;fizzbuzz&#39;, 31, 32, &#39;fizz&#39;, 34, ## &#39;buzz&#39;, &#39;fizz&#39;, 37, 38, &#39;fizz&#39;, &#39;buzz&#39;, 41, &#39;fizz&#39;, 43, 44, ## &#39;fizzbuzz&#39;, 46, 47, &#39;fizz&#39;, 49, &#39;buzz&#39;, &#39;fizz&#39;, 52, 53, &#39;fizz&#39;, ## &#39;buzz&#39;, 56, &#39;fizz&#39;, 58, 59, &#39;fizzbuzz&#39;, 61, 62, &#39;fizz&#39;, 64, &#39;buzz&#39;, ## &#39;fizz&#39;, 67, 68, &#39;fizz&#39;, &#39;buzz&#39;, 71, &#39;fizz&#39;, 73, 74, &#39;fizzbuzz&#39;, 76, ## 77, &#39;fizz&#39;, 79, &#39;buzz&#39;, &#39;fizz&#39;, 82, 83, &#39;fizz&#39;, &#39;buzz&#39;, 86, &#39;fizz&#39;, ## 88, 89, &#39;fizzbuzz&#39;, 91, 92, &#39;fizz&#39;, 94, &#39;buzz&#39;, &#39;fizz&#39;, 97, 98, ## &#39;fizz&#39;, &#39;buzz&#39;], dtype=object) Small hint: You should be careful about the type of output vector in R. You’ll notice now it’s a character vector. Python does not convert the type of vector automatically, the dtype argument is needed to ensure the vector can contain both integers and strings. Remove the dtype argument from the first line and see what happens. 2.5.3 Some Useful Functions We finish this chapter with few useful functions that work with vectors. Those will come in handy in your scientific computing endeavors, in particular towards the second part of the module, as they’re all functions that are necessary to extract useful information from our vectors. Let’s start with considering a very simple quadratic function: \\[ y = x^2 - x \\] Now, let’s say we want to evaluate this function over a sequence of values between -5 and 5 (those values plotted). To code this, we learned we can do simply some algebra with vector: R # Create a sequence of numbers # from -5 to 5 with increments of 0.1 x &lt;- seq(-5, 5, by = 0.1) # Compute the value of x^2 - x for each # element of x and assign it to y y &lt;- x^2 - x python # Create a sequence of numbers # from -5 to 5 with increments of 0.1 x = np.arange(-5, 5.1, 0.1) # Compute the value of x^2 - x for each # element of x and assign it to y y = x**2 - x Now that we have our \\(y\\) values, let’s see what we can get from it! See if what you see in the output matches what you see in the plot! R # Find the maximum value of y max(y) ## [1] 30 # Find the minimum value of y min(y) ## [1] -0.25 # Find the index of the element # in y that has the maximum value which.max(y) ## [1] 1 # Find the index of the element # in y that has the minimum value which.min(y) ## [1] 56 # Find the minimum value of y # (equivalent to above, why?) y[which.min(y)] ## [1] -0.25 # Check which elements of y are # less than 0 and return a logical vector neg_index &lt;- y &lt; 0 # Find the indices of the elements # in y that are less than 0 which(neg_index) ## [1] 52 53 54 55 56 57 58 59 60 # print the elements in y that are less than 0 y[which(neg_index)] ## [1] -0.09 -0.16 -0.21 -0.24 -0.25 -0.24 -0.21 -0.16 -0.09 python # Find the maximum value of y np.max(y) ## 30.0 # Find the minimum value of y np.min(y) ## -0.25 # Find the index of the element # in y that has the maximum value np.argmax(y) ## 0 # Find the index of the element # in y that has the minimum value np.argmin(y) ## 55 # Find the minimum value of y # (equivalent to above, why?) y[np.argmin(y)] ## -0.25 # Check which elements of y are # less than 0 and return a logical vector neg_index = y &lt; 0 # Find the indices of the elements # in y that are less than 0 np.where(neg_index) ## (array([51, 52, 53, 54, 55, 56, 57, 58, 59, 60]),) # print the elements in y that are less than 0 y[np.where(neg_index)] ## array([-9.00000000e-02, -1.60000000e-01, -2.10000000e-01, -2.40000000e-01, ## -2.50000000e-01, -2.40000000e-01, -2.10000000e-01, -1.60000000e-01, ## -9.00000000e-02, -2.13162821e-14]) .book .book-body .page-wrapper .page-inner { max-width: 1200px !important; } "],["func_loop.html", "3 Functions and Loops 3.1 Functions 3.2 State and For Loop 3.3 More about looping", " 3 Functions and Loops 3.1 Functions Functions in mathematics, is an assignment of an element from a set to a different set. Here we give a more “practical” definition. In the realm of programming, a function is a reusable piece of code that performs a specific task. Think of it as a mini-program within your program, a tool you create to do a job so you don’t have to. And as a program does, you give it an input, it will do some voudou magic, and it will spit an output. What’s the point of a function you might ask? Well, in programming, we use functions when we have tasks that must be performed again and again. When we notice a repetitive task occurring, it is a good idea to write a function that performs this task. If you find yourself copying and pasting the same piece of code more than three times, it’s time to stop and think: “Should I write a function for this?” Remember, in the world of coding, being lazy is often a good thing! We aim for efficiency, not repetitive strain injury. Imagine if every time you need to compute the square root, you need to write the code to compute the square root over and over again. Well, but in practice, you don’t have to! There’s a function that does the job for you already: sqrt In fact, it won’t come as a surprise that we’ve already encountered many functions in the past weeks. For instance: Mathematical functions like sqrt() or sin() in R, and math.sqrt() or math.sin() in Python. Functions like np.array() or c() to create vectors. Functions like length() in R or len() in Python to get information about our data structures. Again, each function I mentioned, has an input, and an output: sqrt takes a number as input and returns the square root of such number, length or len take a whole vector as input, and return the length of it… Another incredibly useful function is the help() function, available in both R and Python. This function takes a function as an input, and provides us with information said function as output! For example: R help(sqrt) python help(math.sqrt) Whenever you will meet a built-in function, or a function from a documented external library you can call the help on the function to have an explanation about it! Documentation is a requirement in R libraries, so pretty much all the functions you will meet are documented! Unfortunately this is not the case for Python, where documenting functions is not a requirement, so not always the help will return something. 3.1.1 Writing new functions The real power of functions comes when we start creating our own. We can write new functions that perform specific tasks, tailored to our needs. This allows us to do more complex, interesting, and fun things with our code. So let’s dive in and learn how to create our own functions! We can wrap our code in a function, and every time the function is called, this code is run. This is incredibly useful for tasks we need to perform multiple times. Let’s build for example a simple function that converts pounds (lbs) to grams (g). Mathematically, this is simply done by the formula: \\[ g = 453.5924 * lbs \\] In R, we define a function using the function() command. The arguments of the function are placed within the parentheses. Here’s how we can create a function in R: lbs_to_grams &lt;- function(lbs) { grams &lt;- 453.5924 * lbs return(grams) } In this function, lbs is the input (or argument), and the function returns the equivalent weight in grams. In R, we create a new function with the function statement, and then we assign it to a variable, which is going to be containing our function. The return() statement is used to specify the result that the function should output. In Python, we define a function using the def keyword. The arguments of the function are placed within the parentheses. Again we need to use indentation: this is crucial in Python as it determines the code blocks. Here’s how we can create a function in Python: def lbs_to_grams(lbs): grams = 453.5924 * lbs return grams In this function, lbs is the input (or argument), and the function returns the equivalent weight in grams: following the def keyword we need both the function name, followed by the argument. The return statement is used to specify the result that the function should output. Now, once we have made the new function, we can call it with: R lbs_to_grams(lbs=2) ## [1] 907.1848 lbs_to_grams(lbs=3) ## [1] 1360.777 # when calling we can also omit # the argument name for brevity lbs_to_grams(3) ## [1] 1360.777 python lbs_to_grams(lbs=2) ## 907.1848 lbs_to_grams(lbs=3) ## 1360.7772 # when calling we can also omit # the argument name for brevity lbs_to_grams(3) ## 1360.7772 By creating functions like these, we can make our code more efficient and easier to read. Plus, it saves us from having to remember the conversion rate each time we want to convert pounds to grams! The name of the function lbs_to_grams and its argument lbs are just names that I chose. There are a few guidelines that could be useful when naming functions: - Names should be lowercase. - Use an underscore, _, to separate words within a name. - Strive for names that are concise and meaningful (this is not easy!). - Avoid existing function names in R and python, such as length() or len(). Also, you might have noticed we made a variable within the function code, grams. But what does it mean to have variables within functions? The variables used inside a function are local to that function. Think of your function as a guarded sandbox, where no child leaves unless you specifically tell them to. This sandbox is called and enviroment. Let’s cover this concept formally! 3.1.1.1 Enviroments In programming, an environment refers to a structure that holds variables. When you create a variable in a program, the environment is where this variable lives. The environment keeps track of the variable’s name and its current value. There are two types of environments: global and local. The global environment is the default environment where your variables live unless you specify otherwise. When you create a variable at the top level of your script, it’s stored in the global environment. A local environment is created when you call a function. Each time a function is called, a new local environment is created for that function call. This environment holds the variables that are created within the function. These variables are only accessible within the function call and cease to exist once the function call is over. Let’s consider the lbs_to_grams function we made: R lbs_to_grams &lt;- function(lbs) { grams = 453.5924 * lbs return(grams) } # Create a variable in the global environment glo_grams &lt;- 2 # Try to access the local variable &quot;grams&quot; print(grams) ## Error in eval(expr, envir, enclos): object &#39;grams&#39; not found # Try to access the global variable &quot;glo_grams&quot; print(glo_grams) ## [1] 2 python def lbs_to_grams(lbs): grams = 453.5924 * lbs return grams # Create a variable in the global environment glo_grams = 2 # Try to access the local variable &quot;grams&quot; print(grams) ## name &#39;grams&#39; is not defined # Try to access the global variable &quot;glo_grams&quot; print(glo_grams) ## 2 In these functions, lbs and grams are variables in the local environment of the function. They are created when the function is called and cease to exist when the function call is over. If you try to access grams outside of the function, you’ll get an error because grams is not in the global environment. On the other hand, glo_grams is in the global environment because it’s created at the top level of the script, not within a function. You can access glo_grams anywhere in your script even within a function. This distinction between global and local variables helps keep our code clean and reduces the chance of errors. It ensures that the function does its job without interfering with the rest of our script! However, it can be prone to errors too. Say for instance, I make a typo in the argument name of my function above, and, for whatever reason I created a lbs variable in the global… Like for instance: R # I specified in the global lbs at some point lbs &lt;- 3 # and here I made a typo! # V bug_lbs_to_grams &lt;- function(lb) { grams = 453.5924 * lbs return(grams) } # Then, no matter what I call, I will always get the same result! # e.g.: 453.5924 * 3 bug_lbs_to_grams(2) ## [1] 1360.777 bug_lbs_to_grams(10) ## [1] 1360.777 bug_lbs_to_grams(42) ## [1] 1360.777 python # I specified in the global lbs at some point lbs = 3 # and here I made a typo! # V def bug_lbs_to_grams(lb): grams = 453.5924 * lbs return grams # Then, no matter what I call, I will always get the same result! # e.g.: 453.5924 * 3 bug_lbs_to_grams(2) ## 1360.7772 bug_lbs_to_grams(10) ## 1360.7772 bug_lbs_to_grams(42) ## 1360.7772 What happened above, is that I pass down as an input the lb argument (without the s) but this is nowhere used in the function as inside the code, at grams = 453.5924 * lbs I call the lbs. Now since the compiler can’t find any lbs within the local enviroment, it will just assume that this is the lbs I specified in the global. Hence, no matter what I feed to the function, it will return the evaluation with the global lbs. For this reason try not to name the variables inside your functions as those outside it, in the rest of your script. What happens if I do name a local variable and global variable in the same way? Well, in this case, the function will use the local lbs variable, and the global will use the global lbs variable but this is still risky and prone to bugs. R # global lbs lbs &lt;- 3 # but this does not affect the &quot;lbs&quot; of the function argument lbs_to_grams(2) ## [1] 907.1848 lbs_to_grams(10) ## [1] 4535.924 lbs_to_grams(42) ## [1] 19050.88 python # global lbs lbs = 3 # but this does not affect the &quot;lbs&quot; of the function argument lbs_to_grams(2) ## 907.1848 lbs_to_grams(10) ## 4535.924 lbs_to_grams(42) ## 19050.8808 3.1.1.2 Multiple arguments Say we want now to convert pounds to milliliters. To convert from mass to volume, we will need an additional information, the specific mass. In physics, the specific mass (also known as the volumetric mass density) of a substance is the mass per unit volume. Fortunately for us, functions can take multiple arguments, allowing us to give more elements to the local environment of the function. This means we can customize the function’s behavior based on these inputs. Let’s see how we can add more arguments to a function. We’ll create a new function to convert pounds to milliliters. This function will take a second argument: specific_mass. We’ll use the function we created earlier to convert pounds to grams, and then, using the specific_mass, we’ll convert grams to liters. Here’s how we can do this in both R and Python: R lbs_to_ml &lt;- function(lbs, specific_mass) { grams &lt;- lbs_to_grams(lbs) ml &lt;- grams / specific_mass return(ml) } # Specific mass of water and oil water_mass = 1 oil_mass = 0.92 # Convert 2 lbs of water and oil to ml lbs_to_ml(2, water_mass) ## [1] 907.1848 lbs_to_ml(2, oil_mass) ## [1] 986.0704 python def lbs_to_ml(lbs, specific_mass): grams = lbs_to_grams(lbs) ml = grams / specific_mass return ml # Specific mass of water and oil water_mass = 1 oil_mass = 0.92 # Convert 2 lbs of water and oil to ml lbs_to_ml(2, water_mass) ## 907.1848 lbs_to_ml(2, oil_mass) ## 986.0704347826087 To run the functions we just made: R # Specific mass of water and oil water_mass = 1 oil_mass = 0.92 # Convert 2 lbs of water and oil to ml lbs_to_ml(2, specific_mass=water_mass) ## [1] 907.1848 lbs_to_ml(2, specific_mass=oil_mass) ## [1] 986.0704 python # Specific mass of water and oil water_mass = 1 oil_mass = 0.92 # Convert 2 lbs of water and oil to ml lbs_to_ml(2, specific_mass=water_mass) ## 907.1848 lbs_to_ml(2, specific_mass=oil_mass) ## 986.0704347826087 Let’s say that 90% of the time when we are doing these calculations, they are relative to using water. Then, to be more efficient, rather than continuously having to give the mass of water, we could set the arguments to have these as default values. This is where default arguments in functions come into play. They are incredibly useful for several reasons: They allow us to make certain parameters optional, which can make the function easier to use. They can provide sensible defaults for a function, allowing it to be used without requiring the user to specify every single parameter. They can make the code more readable by clearly stating what the default behavior of the function is. Here’s how we can do this in both R and Python: R lbs_to_ml &lt;- function(lbs, specific_weight = 1) { grams &lt;- lbs_to_grams(lbs) ml &lt;- grams / specific_weight return(ml) } # Convert 2 lbs of water to ml (default behavior) lbs_to_ml(2) ## [1] 907.1848 # Convert 2 lbs of oil to ml (specific behavior) lbs_to_ml(2, 0.92) ## [1] 986.0704 python def lbs_to_ml(lbs, specific_weight=1): grams = lbs_to_grams(lbs) ml = grams / specific_weight return ml # Convert 2 lbs of water to ml (default behavior) lbs_to_ml(2) ## 907.1848 # Convert 2 lbs of oil to ml (specific behavior) lbs_to_ml(2, 0.92) ## 986.0704347826087 As you can see, default arguments make our function more flexible and easier to use. They allow the function to handle a wider range of scenarios while keeping the code clean and readable. 3.1.2 Exercise: cups to grams converter So I once watched this movie with a small rat chef named Remy. Like it’s a very popular one, but I can’t say the title for copyright reasons. Anyway, let’s say that one day, Remy decides to leave his home in France and set sail for the culinary world of the United States. But as soon as Remy gets onto American soil, and he starts to explore American recipes, he encounters a problem. All the measurements are in cups! Back in France, he was used to grams and liters. “Mon Dieu!” he exclaimed, “How am I supposed to cook with these cup measurements?” [Imagine this phrase with a French accent]. But Remy is not a rat to be easily defeated: To make his life easier, he decides to hire a programmer on Fiverr to convert cups to grams. You are that programmer. As we did with the functions we created before, you should: Create a new function cups_to_ml that takes as input the number of cups and returns as output the corresponding value in milliliters. Use the relation \\[ cps = 236.588 * ml \\] Create a new function called ml_to_grams. This function, as above, will need the specific weight, but now the relation is given by the inverse: \\[ g = ml * \\rho, \\] where \\(\\rho\\) is the specific weight. Create a last function called cups_to_ml. This function should: Take as input two arguments: the number of cups, and a string that specifies an ingredient, e.g. \"flour\" or \"water\". Default this second argument to water. Convert the amount of cups in milliliters using the function cups_to_ml. With an if-if else-else statement, it should check the argument ingredient, and set a specific_weight variable based on the ingredient. You can find the values in the table below: Ingredient Specific Weight (g/ml) water 1 flour 0.53 oil 0.92 oat Milk 1.03 Call the ml_to_grams function with the relative ml and specific weight computed above, and return the result. Run the function to convert the following: 2 cups of water Half a cup of oil 3 cups of oat milk 2 cups of flour plus one cup of water 3.2 State and For Loop Normally, if you have to run some operations on multiple objects, you would store these objects in a vector, and then work with the vector directly. This is what we’ve been doing in the past weeks, and what works for most of the times. For instance, let’s say we have a vector called measurements in lbs and we want to convert all these measurements to grams. Then, we can simply take our function lbs_to_grams we made above, and run it on the measurements vector: R # Create a vector of measurements in lbs measurements &lt;- c(1, 2, 3) # Convert measurements to grams lbs_to_grams(measurements) ## [1] 453.5924 907.1848 1360.7772 python # importing numpy import numpy as np # Create a list of measurements in lbs measurements = np.array([1, 2, 3]) # Convert measurements to grams lbs_to_grams(measurements) ## array([ 453.5924, 907.1848, 1360.7772]) This will run the function on each element of the vector independently. More formally: in the first two weeks, we learned how to work with vectors and vectorised functions, designed to operate on whole vectors directly. Technically, we say that vectorised functions are trivially parallelizable because there’s no dependency between elements (the value of an element of the output vector does not depend on any other element). However, while you should use vectorised functions as much as you can, they are not suitable for all programming tasks, particularly when the computation of an element depends on the previous ones, i.e., when there is a state involved. A state is a scenario where certain steps in your code must be executed in a specific order because the output of one step is the input to the next step. In these circumstances, we find an answer in looping. Loops allow us to execute a block of code multiple times, which is exactly what we want in these scenarios. The Fibonacci sequence is a classic example of a state. If you’re not familiar with it, the Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. The first 10 values in the series will be: This table shows the first 10 numbers of the Fibonacci sequence, starting from \\(r_{0}\\) to \\(r_{9}\\). \\(r_{i}\\) \\(r_{0}\\) \\(r_{1}\\) \\(r_{2}\\) \\(r_{3}\\) \\(r_{4}\\) \\(r_{5}\\) \\(r_{6}\\) \\(r_{7}\\) \\(r_{8}\\) \\(r_{9}\\) Value 0 1 1 2 3 5 8 13 21 34 More formally, the Fibonacci sequence is defined by the recurrence relation: \\[ r_{i} = r_{i - 1} + r_{i - 2} \\quad \\text{for}\\quad i &gt; 2, \\] with initial conditions \\(r_{1} = 0\\) and \\(r_{2} = 1\\). Well, unsurprisingly, in mathematics, you have already met the “for” statements! As in mathematics a “for” allows to build a relation, a “for” loop is a control flow statement that allows code to be executed repeatedly. Therefore, to generate the Fibonacci sequence using a “for” loop, we could use the following algorithm: Start by defining the first two numbers in the sequence, 0 and 1. For a given number of iterations, do the following: Calculate the next number in the sequence as the sum of the previous two numbers. Update the previous two numbers to be the last number and the newly calculated number. We will return to the Fibonacci example after having introduced the for loop syntax. 3.2.1 The syntax As the syntax in R and python for looping is quite different, R and python chunks will be separate. You should be able to read each language independently. We can code a for loop as following. In R: for (i in 1:10) { print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 In this R code, to explain the syntax: for (i in 1:10) is the start of the for loop. The iterator i goes from 1 to 10. 1:10 creates a vector: this is the sequence of values we want to iterate over. print(i) is the code chunk that we want to repeat. In this case it prints the current value of i. i is the object that stores our current index. It gets updated at each step over the sequence of values for 1 to 10. The for loop ends when it has exhausted the sequence, i.e., when i has taken all values from 1 to 10. We can also use the for loop to iterate over the elements of a vector directly, rather than their indices. For example, a for loop that prints the elements of a vector: vec &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) for (fruit in vec) { print(fruit) } ## [1] &quot;apple&quot; ## [1] &quot;banana&quot; ## [1] &quot;cherry&quot; In this case, fruit is the iterator that gets updated at each step over the sequence with the current element of the sequence. The for loop ends when it has exhausted the sequence. Try to edit both code chunks above, by adding a new variable called iter_counts. Initialize this variable at 0, e.g. iter_counts &lt;- 0, and update it in the cycle with iter_counts &lt;- iter_counts + 1. Print it at the end: what’s the value for the first cycle? And for the second? In Python: In Python, we can print the numbers from 1 to 10 using a for loop as follows: for i in range(1, 11): print(i) ## 1 ## 2 ## 3 ## 4 ## 5 ## 6 ## 7 ## 8 ## 9 ## 10 In this Python code, to explain the syntax: for i in range(1, 11) is the start of the for loop. The iterator i goes from 1 to 10. This is the sequence we want to iterate over. We use range function to generate this figure: this function is analogue to np.arange from numpy, but generates a different object called “range” that is specific to iterators print(i) is the code chunk that we want to repeat. It prints the current value of i. i is the object that stores our current index. It gets updated at each step over the sequence. The for loop ends when it has exhausted the sequence, i.e., when i has taken all values from 1 to 10. We can also use the for loop to iterate over the elements of a numpy array directly, rather than their indices. For example, a for loop that prints the elements of a numpy array: arr = np.array([&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]) for fruit in arr: print(fruit) ## apple ## banana ## cherry In this Python code: arr = np.array([\"apple\", \"banana\", \"cherry\"]) creates a numpy array with the elements “apple”, “banana”, and “cherry”. for fruit in arr: is the start of the for loop. The iterator fruit goes over each element in the numpy array arr. print(fruit) is the code chunk that we want to repeat. It prints the current value of fruit. fruit is the object that stores the current element of the array. It gets updated at each step over the sequence. The for loop ends when it has exhausted the sequence, i.e., when fruit has taken all values in the numpy array arr. Try to edit both code chunks above, by adding a new variable called iter_counts. Initialize this variable at 0, e.g. iter_counts = 0, and update it in the cycle with iter_counts = iter_counts + 1. Print it at the end: what’s the value for the first cycle? And for the second? 3.2.2 Coding The Fibonacci sequence Having covered how to write a for cycle, we come back to our Fibonacci example. Differently from the loop above, in order to implement our algorithm, we will need to update a variable within our loop. In our case, this variable, is going to be a vector storing our Fibonacci sequence, called fibonacci. At iteration 1, the vector will be 2 elements long (the first two number of the sequence), but as we go through the loop, we will be adding more and more elements to the vector. R # Initialize the first two numbers in the sequence fibonacci &lt;- c(0, 1) # Generate the next 18 numbers in the sequence for (i in 3:20) { fibonacci[i] &lt;- fibonacci[i - 1] + fibonacci[i - 2] } Python # Initialize the first two numbers in the sequence fibonacci = [0, 1] # Generate the next 18 numbers in the sequence for i in range(2, 20): fibonacci.append(fibonacci[i - 1] + fibonacci[i - 2]) # converting the list into a numpy array # (useful if we want to use vectorised operations later!) fibonacci = np.array(fibonacci) In the R code: fibonacci &lt;- c(0, 1) initializes the first two numbers in the Fibonacci sequence. for (i in 3:20) is the start of the for loop. The iterator i goes from 3 to 20. This is the sequence we want to iterate over. fibonacci[i] &lt;- fibonacci[i - 1] + fibonacci[i - 2] is the code chunk that we want to repeat. It calculates the ith number in the Fibonacci sequence as the sum of the two preceding numbers and appends it to the fibonacci vector. Given that at iteration i we have no element i in the vector yet (this is still i-1 long), R will automatically extend the vector of one extra element. In the Python code: fibonacci = [0, 1] initializes the first two numbers in the Fibonacci sequence. for i in range(2, 20) is the start of the for loop. The iterator i goes from 2 to 19. This is the sequence we want to iterate over. fibonacci.append(fibonacci[i - 1] + fibonacci[i - 2]) is the code chunk that we want to repeat. It calculates the ith number in the Fibonacci sequence as the sum of the two preceding numbers and appends it to the fibonacci list using the append() method. The append method extends our vector, adding a new element at the end of the existing one. Our vectors, where we stored our results at every iteration, should be 20 elements long, containing the sequence. R # Print the Fibonacci sequence fibonacci ## [1] 0 1 1 2 3 5 8 13 21 34 55 ## [12] 89 144 233 377 610 987 1597 2584 4181 Python # Print the Fibonacci sequence fibonacci ## array([ 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ## 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]) Before you proceed make sure you understand what’s going on inside the for loop. Add extra print statements to understand what’s happening at every iteration, e.g. try to add: print(i), print(fibonacci[i]) and print(fibonacci[i-1]) before the computation, or print(fibonacci) after the computation has been done. print statements are extremely useful for debugging for cycles! 3.2.3 Exercise Write now a new function my_cusum to compute the cumulative sum of a list of numbers, using a for loop. Use the function to calculate the cumulative sum of the first 10 elements of the Fibonacci sequence. The function should: Take as input a vector Initialize a new vector to store the cumulative sum Then, in a cycle, update this vector with the cumulative sum of the elements of the input vector The output vector should be of the same length of the input vector The first element of the output vector should be the same first element of the input vector Using the code above, generate a Fibonacci sequence of 10 numbers Run the function my_cusum(fibonacci) to obtain the cumulative sum of the first then numbers of the Fibonacci sequence. Compare the output of my_cusum with the built in function cumsum (in R) or numpy’s np.cumsum (in Python). 3.3 More about looping In this section we will be giving few extra details and concepts you should know about looping. If you got familiar with the for cycle above, they should be fairly straightforward to understand! 3.3.1 Nested loops Nested loops are useful when we have to repeat a block of code for each combination of elements from two or more sequences. This can be incredibly useful in many situations, such as when we want to perform an operation for each pair of elements in two lists or vectors. A simple example, for instance, could be a nested loop that prints the multiplication table from 1 to 4. R for (i in 1:4) { for (j in 1:4) { print(paste(i, &quot;x&quot;, j, &quot;=&quot;, i*j)) } } ## [1] &quot;1 x 1 = 1&quot; ## [1] &quot;1 x 2 = 2&quot; ## [1] &quot;1 x 3 = 3&quot; ## [1] &quot;1 x 4 = 4&quot; ## [1] &quot;2 x 1 = 2&quot; ## [1] &quot;2 x 2 = 4&quot; ## [1] &quot;2 x 3 = 6&quot; ## [1] &quot;2 x 4 = 8&quot; ## [1] &quot;3 x 1 = 3&quot; ## [1] &quot;3 x 2 = 6&quot; ## [1] &quot;3 x 3 = 9&quot; ## [1] &quot;3 x 4 = 12&quot; ## [1] &quot;4 x 1 = 4&quot; ## [1] &quot;4 x 2 = 8&quot; ## [1] &quot;4 x 3 = 12&quot; ## [1] &quot;4 x 4 = 16&quot; Python for i in range(1, 5): for j in range(1, 5): print(f&quot;{i} x {j} = {i*j}&quot;) ## 1 x 1 = 1 ## 1 x 2 = 2 ## 1 x 3 = 3 ## 1 x 4 = 4 ## 2 x 1 = 2 ## 2 x 2 = 4 ## 2 x 3 = 6 ## 2 x 4 = 8 ## 3 x 1 = 3 ## 3 x 2 = 6 ## 3 x 3 = 9 ## 3 x 4 = 12 ## 4 x 1 = 4 ## 4 x 2 = 8 ## 4 x 3 = 12 ## 4 x 4 = 16 NOTE for Python users In the print statement print(f\"{i} x {j} = {i*j}\") we used f-string formatting, which was introduced in Python 3.6 (the code above will break on previous versions). It’s a way to embed expressions (like i*j) inside strings, using curly braces {}. The expressions will be replaced with their values when the string is created. The letter f at the beginning of the string tells Python to allow these embedded expressions. In our example {i} and {j} will be replaced by the values of the variables i and j, and {i*j} will be replaced by the result of the expression i*j. So if i is 2 and j is 3, the string would become \"2 x 3 = 6\". F-string formatting can be very useful for debugging because it allows you to easily insert the values of variables into strings, which you can then print to see what’s happening in your loops! 3.3.2 While loops Similarly to for loops, we have the while loops. They allow us to repeat a block of code until a certain condition is met. This can be incredibly useful in many situations, such as when we want to perform an operation until a certain threshold is reached. We can see how a while loop works below: R i &lt;- 1 while (i &lt;= 10) { print(i) i &lt;- i + 1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Python i = 1 while i &lt;= 10: print(i) i += 1 ## 1 ## 2 ## 3 ## 4 ## 5 ## 6 ## 7 ## 8 ## 9 ## 10 In these codes: i &lt;- 1 and i = 1 initialize the counter at 1. while (i &lt;= 10) and while i &lt;= 10: start the while loop. The condition i &lt;= 10 is what we check at each step. If it’s true, we execute the code chunk inside the loop. print(i) and print(i) are the code chunks that we want to repeat. They print the current value of i. i &lt;- i + 1 and i += 1 are crucial. They update i at each step, ensuring that our condition will eventually be false. Without these lines, i would always be 1, the condition would always be true, and the while loop would run indefinitely. The while loop ends when the condition i &lt;= 10 is no longer met, i.e., when i is greater than 10. We are missing one last ingredient to looping! Break and next. 3.3.3 Break and next/continue Break and next/continue are control flow statements that can be used to alter the flow of a loop. They can be used when we want to stop a loop if a certain condition is met or skip an iteration if a certain condition is met. To see how they work, we write a loop that prints the numbers from 1 to 10, but skips the number 5 and stops after the number 8. R for (i in 1:10) { if (i == 5) { next # Skip the rest of the iteration # and continue with the next iteration } if (i &gt; 8) { break # Immediately terminate the loop } print(i) # Print the current value of i } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 6 ## [1] 7 ## [1] 8 Python for i in range(1, 11): if i == 5: continue # Skip the rest of the iteration # and continue with the next iteration if i &gt; 8: break # Immediately terminate the loop print(i) # Print the current value of i ## 1 ## 2 ## 3 ## 4 ## 6 ## 7 ## 8 Let’s break it down: if (i == 5) { next } (R) and if i == 5: continue (python) are the next/continue statements. If i is equal to 5, they skip the rest of the loop and continue with the next iteration. 5 won’t be printed! if (i &gt; 8) { break } and if i &gt; 8: break are the break statements. If i is greater than 8, they immediately terminate the loop, regardless of the loop condition. As a result, we stop at 8, and don’t continue to up to 10. break could be an alternative stopping condition to a while loop. Using break and next (or continue in Python) statements in loops can sometimes make the code harder to understand and debug, because they can lead to unexpected jumps in the control flow. This is especially true in more complex loops where it’s not immediately clear when or if the loop will be prematurely terminated or skipped. Usually, there’s always alternatives to breaks. Let’s consider a simple example where we want to find the first number in a list that is divisible by a certain number. Using break: R numbers &lt;- c(15, 18, 21, 24, 27, 30) divisor &lt;- 4 for (num in numbers) { if (num %% divisor == 0) { print(paste(num, &quot;is the first number divisible by&quot;, divisor)) break } } ## [1] &quot;24 is the first number divisible by 4&quot; Python numbers = [15, 18, 21, 24, 27, 30] divisor = 4 for num in numbers: if num % divisor == 0: print(f&quot;{num} is the first number divisible by {divisor}&quot;) break ## 24 is the first number divisible by 4 In this case, as soon as we find a number that meets our condition, we break out of the loop. However, if we want to avoid using break, we could rewrite the loop with a while to use a boolean flag that indicates whether we’ve found a suitable number: R numbers &lt;- c(15, 18, 21, 24, 27, 30) divisor &lt;- 4 found &lt;- FALSE i &lt;- 1 while (!found &amp;&amp; i &lt;= length(numbers)) { if (numbers[i] %% divisor == 0) { print(paste(numbers[i], &quot;is the first number divisible by&quot;, divisor)) found &lt;- TRUE } i &lt;- i + 1 } ## [1] &quot;24 is the first number divisible by 4&quot; Python numbers = [15, 18, 21, 24, 27, 30] divisor = 4 found = False i = 0 while not found and i &lt; len(numbers): if numbers[i] % divisor == 0: print(f&quot;{numbers[i]} is the first number divisible by {divisor}&quot;) found = True i = i + 1 ## 24 is the first number divisible by 4 In this version, instead of breaking out of the loop, we use the found variable to keep track of whether we’ve found a number that meets our condition. If we have, we skip the rest of the loop iterations without explicitly using a break statement. .book .book-body .page-wrapper .page-inner { max-width: 1200px !important; } "],["maps_alg.html", "4 Functional Programming and Linear Algebra 4.1 An intro to Functional Programming 4.2 Doing Linear Algebra 4.3 An end note to this chapter", " 4 Functional Programming and Linear Algebra 4.1 An intro to Functional Programming We have seen so far two concepts from past week on how to run functions over collections of objects (in our case vectors). From this section we learned how to run a function on a vector, whilst last week, we learned how to implement looping, with for or while cycle, changing things as you go. We learned, most importantly, that we should use the for cycle if and only if we have state. Well, this is not my personal opinion only, as a matter of fact, there’s a programming philosophy called functional programming. Hadley, in his Advanced R book (sources in the index), gives a beautiful definition that sums up the properties of a functional programming language: Functional languages have first class functions. This means that functions are the primary building blocks. In this style, you can do a lot with functions. For example, you can treat functions just like vectors: you can assign them to variables, store them in lists, pass them as arguments to other functions, create them inside functions, and even return them as the result of a function. In functional languages functions are pure. This means that there two properties to follow: The output of a function depends only on its inputs. This means if you call a function with the same inputs, you’ll always get the same output. A function doesn’t change anything outside of it, like a global variable (from the global enviroment), or do something like writing to disk or displaying to the screen. These are called side-effects. Funny enough, he quotes Stroustroup, the father of C++: “To become significantly more reliable, code must become more transparent. In particular, nested conditions and loops must be viewed with great suspicion. Complicated control flows confuse programmers. Messy code often hides bugs.” — Bjarne Stroustrup The father of c++ In a way you have already written in a functional programming way from the beginning of this module, with the exception of the loops in the past chapter. However, in this chapter, we will be introducing a couple of more concepts that should get rid of for cycles for most of the times! 4.1.1 Lambda Functions and Function Factories A lambda function, also known as an anonymous function, is a function that is defined without a name, e.g. a function assigned to a variable. Lambda functions can have any number of arguments but only one expression, which is immediately evaluated and returned. In R, we assign functions to variables by default (one of the reasons I prefer it as a language). Hence the only difference between a function and a lambda function (as you will see), is that a lambda function is only one expression long, so we don’t need to use the brackets {}. Recently from version 4.1, the lambda notation has been replaced by the \\ keyword, e.g. function() is equivalent to \\(). In Python lambda functions are defined using the lambda keyword, whilst normal functions are defined using the def keyword. These will need to be one line long, and can be assigned to a variable. In both languages we can avoid the return statement, which makes them very easy and compact to write. For example: R # Define a lambda function in R add_two_numbers &lt;- function(x, y) x + y # equivalently, from R 4.1.0 add_two_numbers &lt;- \\(x, y) x + y # Use the lambda function add_two_numbers(1, 2) ## [1] 3 Python # Define a lambda function in Python add_two_numbers = lambda x, y: x + y # Use the lambda function add_two_numbers(1, 2) ## 3 In the above examples, we’ve defined a lambda function add_two_numbers in both R and Python that takes two arguments x and y, and returns their sum. When we call this function with 1 and 2, as we would expect from any regular function, it returns 3. Now the cool stuff, as mentioned above, is that you can have a function that takes a number (or vector) as an input and return a function as output. This is often referred to as a function factory. To do so, we have to define functions inside functions, and then return those newly defined functions. Well, lambda functions, being compact, are the perfect candidate for this task. Here is an example: R # Define a function factory in R make_power &lt;- function(exponent) { # lambda here pow &lt;- \\(x) x^exponent return(pow) } # Use the function factory cube &lt;- make_power(3) cube(2) # Outputs 8 ## [1] 8 to_the_tenth &lt;- make_power(10) to_the_tenth(2) # Outputs 1024 ## [1] 1024 Python # Define a function factory in Python def make_power(exponent): # lambda here pow = lambda x: x ** exponent return pow # Use the function factory cube = make_power(3) cube(2) # Outputs 8 ## 8 to_the_tenth = make_power(10) to_the_tenth(2) # Outputs 1024 ## 1024 In the above examples, we’ve defined a function factory make_power in both R and Python that takes a number exponent as input (the exponent of our exponentiation function we want to built) and returns a function pow that raises its input x to the power of exponent. When we call this function factory with the argument 3, it returns a function cube that cubes its input. When we call this cube function with the argument 2, it returns 8. Similarly, we create a function to_the_tent that returns a function capable of doing the power of 10 of an input number. 4.1.1.1 Fizzbuzz v10299384 We’re about to create a weird overly-engineered version of FizzBuzz: fizzbuzz_v10299384 (the vector solution we had in Chapter 2 was pretty elegant already, so use that in coding interviews). What will follow is an example for you to break to illustrate the possibilities of functional programming. R # A lambda that prints a message # given a remainder remainder_printer &lt;- \\(p, q, message) if (p %% q == 0) message else &quot;&quot; fizzbuzz_v10299384 &lt;- function(x) { f &lt;- \\(printer) \\(x) paste0(printer(x, 3, &quot;fizz&quot;), printer(x, 5, &quot;buzz&quot;)) # creating a new function and calling it directly! out &lt;- f(remainder_printer)(x) if (nchar(out) == 0) out &lt;- x out } fizzbuzz_v10299384(15) ## [1] &quot;fizzbuzz&quot; fizzbuzz_v10299384(7) ## [1] 7 Python # A lambda that prints a message given a remainder remainder_printer = lambda p, q, message: message if p % q == 0 else &quot;&quot; def fizzbuzz_v10299384(x): f = lambda printer: lambda x: printer(x, 3, &quot;fizz&quot;) + printer(x, 5, &quot;buzz&quot;) # creating a new function and calling it directly! out = f(remainder_printer)(x) if len(out) == 0: out = str(x) return out fizzbuzz_v10299384(15) ## &#39;fizzbuzz&#39; fizzbuzz_v10299384(7) ## &#39;7&#39; What on earth is going on? Well, let’s try to break it down: remainder_printer is a lambda function that takes three arguments: p, q, and message. It checks if p is divisible by q (i.e., p modulo q equals 0), and if so, it returns message; otherwise, it returns an empty string. fizzbuzz_v10299384 is a function that takes one argument: x, our number, and returns the FizzBuzz string. It defines a lambda function f that takes one argument: printer (which is expected to be a function). It returns a new lambda function that takes one argument x, our number to check. Recall, that a function can take another function as input and return a new function by overloading its arguments. The function returned by f, is another lambda: this returns the concatenation of the results of calling printer with x, 3, and \"fizz\", and with x, 5, and \"buzz\". We we then call f with remainder_printer as the argument, this will return a lambda that, as described above, will concatenate the fizz and buzz strings. The first step is done with f(remainder_printer). This new unnassigned function is then immediately called with x via f(remainder_printer)(x). If the result of this operation is an empty string, we return x instead. The condition on the length of the string is checked with nchar in R and len in Python. This could have been shortened of at least a couple of statements (try it yourself!). In the next exercise, we are going to use some of these concepts to build the ultimate FizzBuzz program (not underselling). Before doing that, however, we need to introduce the map and reduce operations. 4.1.2 The map operation The map operation is a function that takes a function and a vector as input, and returns a vector. Each element of the output vector is the result of applying the input function to the corresponding element of the input vector: This allows us to apply a function to each element of a vector without having to write a loop. We have already done this when running a function on a vector, however, as we are going to see in a moment, map is a much more general statement. In fact, there are many functions in R and python that are not vectorized, meaning they don’t naturally handle vector inputs. If you try to apply a non-vectorized function directly to a vector, you might get a bug or unexpected results. Let’s consider a simple function that squares a number. We will apply this function to a vector of numbers using the map operation in both R and Python: R # import the purrr library library(purrr) # this is how we import libraries in R! # Define a function that squares a number using the factory above square &lt;- make_power(2) # Create a vector of numbers numbers &lt;- 1:5 # Use the map function to apply the square function to the vector squares &lt;- map_dbl(numbers, square) squares ## [1] 1 4 9 16 25 Python # Define a function that squares a number square = make_power(2) # Create a list of numbers numbers = np.arange(1, 6) # Use the map function to apply the square function to the list squares = list(map(square, numbers)) squares ## [1, 4, 9, 16, 25] In the above examples, we’ve defined a function square that squares its input using the make_power function. We then created a vector (or list in Python) numbers with the numbers from 1 to 5. We used the map function to apply square to each element of numbers, resulting in a new vector squares that contains the squares of the numbers. NOTE: For R Users: The map function is part of the purrr package, so you need to import it with library(purrr); you can have this code at the start of the script. The map function in R takes as argument the vector first, and then the function. The map function in R returns a list by default. A list in R is similar to a vector, but unlike a vector, a list can contain elements of different types. This means a list can be a collection of numbers, vectors, matrices, characters, functions, potatoes, onions, parupzluplups and so on. The map function defaults to a list, as, a priori, does not know what the output of a function could be. If you want a vector as output, you should use the type-specific map functions like map_lgl, map_int, map_dbl, and map_chr. For this reason, above, we used the map_dbl, as we wanted a vector of double precision numbers. Try to swap the function map_dbl for map_chr and see what happens. Also, note that map is implemented natively in R using the apply family of functions, see help(apply) for more details. The code above would have been: squares = sapply(numbers, square) Where now the function and the vector are swapped in the argument. Also, we are using sapply as this returns a vector, whilst the simple apply function returns a list. NOTE: For Python Users: The map function in Python takes as argument the function first, and then the vector. In Python, the map function returns a map object, which is an iterator that yields results on demand. This means that the map function doesn’t actually compute the results until you iterate over the map object. This can be very efficient for large inputs, as it allows the computation to be spread out over time. However, if you want to see all the results at once, you need to convert the map object to a list, which is what the list function does. So when you see list(map(...)) in Python, it means “apply this function to each element of this iterable, and give me a list of the results right away”. The map operation in Python can also be achieved with list comprehensions, which provide a more “Pythonic” way to create lists based on existing lists. Here’s how you can rewrite the previous example using a list comprehension: # Use a list comprehension to apply the square function to the list squares = [square(x) for x in numbers] squares ## [1, 4, 9, 16, 25] In this example, square(x) for x in numbers is a list comprehension that applies square to each element of numbers. You can read it as: “Run square of x for every x in numbers”, which is very similar to writing in maths \\(x^2 \\ \\text{for} \\ x \\in N\\). The result is a new list squares that contains the squares of the numbers. Equivalent Shorter Statements Of course, the advantage is that you can write very compact code with maps, lambdas and function factories! So far, I have been expanding lines upon lines, to make sure that everything is clear, however you could have done the above tasks with a one liner: R squares &lt;- map_dbl(1:5, make_power(2)) squares ## [1] 1 4 9 16 25 Python squares = list(map(make_power(2), np.arange(1, 6))) squares ## [1, 4, 9, 16, 25] 4.1.2.1 Exercise Create a vector of the first 15 natural numbers. Run the fizzbuzz_v10299384 function on the vector above and see what happens. It should work, right? No? Now, run fizzbuzz_v10299384 with map on the same vector, and see the result. Lastly, research the two function factories Vectorised and np.vectorise, try to vectorise fizzbuzz_v10299384 and run it as you did in point 1. Did you fix the issue? 4.1.2.2 Map 2 There’s a lot of examples in cinema where the sequel is arguably better then the first one, like Shrek 2, Cars 2, Jaws 2, The second Star Wars trilogy, The Hangover 2, Bee Movie 2, Karate Kid 2… the list is endless! Well, even in programming map2 is better then map. You might be in fact wondering: what’s the point of having map when we already have vectorised functions? Well, map2 is the answer. The map2 operation is a function that takes two vectors and a function as input, and returns a vector. Each element of the output vector is the result of applying the input function to the corresponding elements of the input vectors. In a vectorized function, on the other hand, there’s no straightforward way of passing two arguments to a function. Let’s consider a simple function that adds two numbers. We will apply this function to two vectors using the map2 operation (in R) and the map operation (in Python it can take as many arguments as necessary by default): R # Define a lambda that adds two numbers add &lt;- \\(x, y) x + y # Create two vectors of numbers numbers1 &lt;- c(1, 2, 3) numbers2 &lt;- c(10, 11, 12) # Use the map2 function to apply the add function to the vectors sums &lt;- map2_dbl(numbers1, numbers2, add) sums ## [1] 11 13 15 Python # Define a lambda that adds two numbers add = lambda x, y: x + y # Create two lists of numbers numbers1 = [1, 2, 3] numbers2 = [10, 11, 12] # Use the map function to apply the add function to the lists sums = list(map(add, numbers1, numbers2)) sums ## [11, 13, 15] In the above examples, we’ve defined a function add that adds its two inputs. We then created two vectors (or lists in Python) numbers1 and numbers2. We used the map2/map function to apply add to each pair of elements from numbers1 and numbers2, resulting in a new vector sums that contains the sums of the numbers. Shorter statements. We can write the map2 statements above in a very compact way again: R sums &lt;- map2_dbl( c(1, 2, 3), c(10, 11, 12), \\(x, y) x+y) sums ## [1] 11 13 15 Python sums = list(map(lambda x, y: x + y, [1, 2, 3], [10, 11, 12])) sums ## [11, 13, 15] Note for Python Users: The map operation with two arguments can also be achieved in a more “Pythonic way” with list comprehensions. Here’s how you can rewrite the previous example: # Use a list comprehension to apply the add function to the lists sums = [add(x, y) for x, y in zip(numbers1, numbers2)] sums ## [11, 13, 15] In this example, the list comprehension statement relies on the zip function. zip is used to pair up the elements from numbers1 and numbers2. Try to run zip(numbers1, numbers2) alone to see the output! I personally find that the map function is more readable, however you should be familiar with both ways as you will be encountering both if you keep programming with Python. One other advantage is that the map function is inherently flexible and can take as many arguments as necessary. This is because it’s designed to apply a function to multiple iterables in parallel. If you pass more than one iterable to map, it will pass corresponding elements from each iterable to the function. This allows you to easily apply a function to multiple arguments. Note for R Users map2 is limited to two arguments, however in purr, we do have a map function that can take as many arguments as necessary: the pmap function. The pmap function has a slightly different notation, as it takes a list of vectors (or a list of lists) and a function as input, and returns a list. Each element of the output list is the result of applying the input function with the corresponding elements of the input vectors as arguments. Here’s an example: # Define a function that adds two numbers add &lt;- \\(x, y) x + y # Create a list of two vectors of numbers numbers &lt;- list(c(1, 2, 3), c(10, 11, 12)) # Use the pmap function to apply the add function to the vectors sums &lt;- pmap_dbl(numbers, add) sums ## [1] 11 13 15 It’s important to note that all vectors in the list passed to pmap should be the same length, as pmap will recycle shorter vectors to match the length of the longest vector, which can lead to unexpected results. If the vectors are not the same length, you should adjust them to be the same length before using pmap. 4.1.3 Reduce Operation The reduce operation is a function that takes a binary function (a function that takes two arguments) and a list or vector as input, and returns a single value. It works by applying the function to the first two elements of the list, then applying the function to the result and the next element, and so on, until it has processed all the elements of the list. This operation is called reduce because it reduces a list of values down to a single value. It’s also known as fold, accumulate, compress, or inject in other programming languages. To give an example, let’s use the reduce operation to compute the dot product of two vectors. We have seen this already in Chapter 2.4, however, this time, we will implement the function ourselves! We can compute this using the map2 operation to multiply the components and the reduce operation to sum the results: R # Define two vectors v1 &lt;- c(1, 2, 3) v2 &lt;- c(10, 11, 12) # Use the map2 function to multiply the components of the vectors products &lt;- map2_dbl(v1, v2, `*`) # Use the reduce function to sum the products dot_product &lt;- reduce(products, `+`) print(dot_product) ## [1] 68 Python from functools import reduce # Define two lists v1 = [1, 2, 3] v2 = [10, 11, 12] # Use the map function to multiply the components of the lists products = list(map(lambda x, y: x * y, v1, v2)) # Use the reduce function to sum the products dot_product = reduce(lambda x, y: x + y, products) print(dot_product) ## 68 In the above examples, we’ve used the map2/map operation to multiply the components of two vectors, and the reduce operation to sum the results, computing the dot product of the vectors. Note for Python Users: The reduce operation in Python is part of the functools module, so you need to import it with from functools import reduce. 4.1.4 Exercise: Implement a Generic FizzBuzz Function Ok, this is going to be great. The ultimate FizzBuzz. The final boss. You are a mathematician, and mathematicians generalize things. In this exercise, you are asked to generalize FizzBuzz. Solve it all. You should write a function that takes three arguments: a vector of numbers, and a vector of primes, and a vector of phrases. The vectors of primes and phrases should be of the same length, not necessarily the same length of the vector of numbers. The function should return a vector of the same length as the input vector of numbers. Each element of the output vector should be obtained by replacing each number in the input vector with the corresponding phrase if the number is divisible by the corresponding prime. If a number is divisible by more than one prime, the complete phrase should be formed by concatenating the phrases. If a number is not divisible by any of the primes, the number itself should be returned as a string. For example, the simple FizzBuzz, should be, then, obtained via: R generic_fizzbuzz(1:15, c(3, 5), c(&quot;Fizz&quot;, &quot;Buzz&quot;)) python generic_fizzbuzz(range(1, 16), [3, 5], [&quot;Fizz&quot;, &quot;Buzz&quot;]) Here’s the function signature in R to get you started: R generic_fizzbuzz &lt;- function(x, primes, phrases) { # Your code here } python def generic_fizzbuzz(x, primes, phrases): # Your code here As a test case, consider the following call to your function: generic_fizzbuzz(1:15, c(2, 3, 5, 7), c(&quot;Skibbidi&quot;, &quot;Fizz&quot;, &quot;Buzz&quot;, &quot;Yo&quot;)) or in Python: generic_fizzbuzz(range(1, 16), [2, 3, 5, 7], [&quot;Skibbidi&quot;, &quot;Fizz&quot;, &quot;Buzz&quot;, &quot;Yo&quot;]) NOTE for R users Bored? This module is too easy? Please check the Challenges chapter! 4.1.5 State in Functional Programming The reduce operation is a way of performing a recursion operation in functional programming. It applies a binary function to the first two elements of a list, then applies the function to the result and the next element, and so on, until it has processed all the elements of the list. This is essentially a function concatenation on the result of a previous iteration. Go and have a better look at Figure ??! This brings us to the concept of recursion, which is a method where the solution to a problem depends on solutions to smaller instances of the same problem. In functional programming, recursion is often used as a way to deal with state. Let’s illustrate how the recursion works with the same Fibonacci series example recursion. We can define a function called \\(f\\) that: \\[ f(n)= \\begin{cases} n,&amp; \\text{if } n \\leq 1\\\\ f(n-1) + f(n-2), &amp; \\text{otherwise} \\end{cases} \\] This function, for a given \\(n\\), will return the corresponding \\(r_n\\) value of the Fibonacci sequence (see past week). Now, the cool thing is: it is possible to write this exact statement as a program too! Have a look at the code below: R # Define a recursive function to compute the Fibonacci series fibonacci &lt;- function(n) { if (n &lt;= 1) return(n) else return(fibonacci(n - 1) + fibonacci(n - 2)) } # Print the first 10 numbers of the Fibonacci series map_dbl(0:9, fibonacci) ## [1] 0 1 1 2 3 5 8 13 21 34 Python # Define a recursive function to compute the Fibonacci series def fibonacci(n): if n &lt;= 1: return n else: return(fibonacci(n - 1) + fibonacci(n - 2)) # Print the first 10 numbers of the Fibonacci series list(map(fibonacci, range(10))) ## [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] In the above examples, we’ve defined a recursive function fibonacci that computes the Fibonacci series. We then used this function compute Fibonacci series: recall that the fibonacci function only returns the \\(n^{th}\\) element of the series, so to get the first 10 numbers we need a map statement. However, it’s important to note that while recursion is a powerful concept, it can be impractical in practice due to its high computational complexity and the risk of running out of memory for large inputs. Most of the tasks in functional programming are either solved via map and reduce operations or, eventually, through for loops. These methods are generally more efficient and can handle larger inputs. For this reason, my friends, this is the last time we will be seeing recursions in this module. Brief but intense. 4.2 Doing Linear Algebra 4.2.1 Building Matrices In the previous chapters, we have covered some basics on how to perform operations on one-dimensional vectors, and the dot product. Now, we are going to extend our understanding to two dimensions with matrices. A matrix is a mathematical term for a two-dimensional array of numbers, while a vector is a one-dimensional array. In other words, you can think of a matrix as a homogeneous vector of vectors of doubles, both in R and Python. Let’s see how to create a 4x4 matrix in R and Python: R # Create a 4x4 matrix in R matrix_by_row &lt;- matrix(1:16, nrow=4, ncol=4, byrow = TRUE) matrix_by_row ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 ## [4,] 13 14 15 16 Python # Create a 4x4 matrix in Python matrix_by_row = np.arange(1, 17).reshape(4, 4) # alternatively, you can write it by hand as a list of lists matrix_by_row = np.array([ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) matrix_by_row ## array([[ 1, 2, 3, 4], ## [ 5, 6, 7, 8], ## [ 9, 10, 11, 12], ## [13, 14, 15, 16]]) In the above examples, we’ve created a 4x4 matrix filled by rows. You can also fill the matrix by columns by setting byrow = FALSE in R, or by reshaping a range in Python (reshape will fill automatically by row). Additionally, you can create a matrix by binding vectors together. In R, you can use cbind() to bind vectors as columns or rbind() to bind vectors as rows, whilist in python you can use np.column_stack() as columns and np.row_stack() as rows: R # Create a matrix by binding vectors in R v1 &lt;- c(1, 2, 3, 4) v2 &lt;- c(5, 6, 7, 8) v3 &lt;- c(9, 10, 11, 12) v4 &lt;- c(13, 14, 15, 16) # Bind vectors as columns matrix_by_col &lt;- cbind(v1, v2, v3, v4) matrix_by_col ## v1 v2 v3 v4 ## [1,] 1 5 9 13 ## [2,] 2 6 10 14 ## [3,] 3 7 11 15 ## [4,] 4 8 12 16 Python # Create a matrix by binding vectors in Python v1 = np.array([1, 2, 3, 4]) v2 = np.array([5, 6, 7, 8]) v3 = np.array([9, 10, 11, 12]) v4 = np.array([13, 14, 15, 16]) # Bind vectors as columns matrix_by_col = np.column_stack((v1, v2, v3, v4)) matrix_by_col ## array([[ 1, 5, 9, 13], ## [ 2, 6, 10, 14], ## [ 3, 7, 11, 15], ## [ 4, 8, 12, 16]]) In the above examples, we’ve created a 4x4 matrix by binding four vectors as columns. You can also bind vectors as rows by using rbind() in R, or np.vstack() in Python. Now, let’s illustrate the transpose operation. Recall that the transpose of a matrix is obtained by flipping it over its diagonal. This switches the row and column indices of each element. In R, you can use the t() function to transpose a matrix, while in Python, you can use the T attribute or the transpose() function. Let’s compare the matrices created above with their transposes: R # Transpose the matrix in R t(matrix_by_row) ## [,1] [,2] [,3] [,4] ## [1,] 1 5 9 13 ## [2,] 2 6 10 14 ## [3,] 3 7 11 15 ## [4,] 4 8 12 16 # comparing the elements of the transposed # matrix by row with that filled by columns t(matrix_by_row) == matrix_by_col ## v1 v2 v3 v4 ## [1,] TRUE TRUE TRUE TRUE ## [2,] TRUE TRUE TRUE TRUE ## [3,] TRUE TRUE TRUE TRUE ## [4,] TRUE TRUE TRUE TRUE Python # Transpose the matrix in Python matrix_by_row.T ## array([[ 1, 5, 9, 13], ## [ 2, 6, 10, 14], ## [ 3, 7, 11, 15], ## [ 4, 8, 12, 16]]) # comparing the elements of the transposed # matrix by row with that filled by columns matrix_by_row.T == matrix_by_col ## array([[ True, True, True, True], ## [ True, True, True, True], ## [ True, True, True, True], ## [ True, True, True, True]]) As you can see, unsurprisingly, the transpose of the filled by row has all elements equals to the one filled by column. 4.2.2 Matrix Operations As with vectors, we can do operations with matrices. We’ll start by creating a simple 3x3 matrix, and a 3x1 vector. R # Define a 3x3 matrix in R A &lt;- matrix(c(1:9), nrow=3, ncol=3) # Define a 3x1 vector in R v &lt;- c(1, 2, 3) Python # Define a 3x3 matrix in Python A = np.arange(1,10).reshape(3,3) # Define a 3x1 vector in Python v = np.array([1, 2, 3]) Now, as in chapter two, R and Python (assuming you’re using numpy) will be able to handle both: Element-wise Operations: These operations are performed on corresponding elements of matrices. This is simply done by calling a given function on a matrix. There’s few examples below, including element-wise multiplication, also known as the Hadamard product. Matrix Multiplication: Remember, the dimensions of the matrices must be compatible for these operations to be valid: when we multiply two matrices, the number of columns in the first matrix should be equal to the number of rows in the second matrix. If they’re not, you’ll get an error. The resulting matrix has each element as the dot product of the corresponding row and column from the input matrices. Let’s see these operations in action: R # Matrix addition A + A ## [,1] [,2] [,3] ## [1,] 2 8 14 ## [2,] 4 10 16 ## [3,] 6 12 18 # Element-wise multiplication A * A ## [,1] [,2] [,3] ## [1,] 1 16 49 ## [2,] 4 25 64 ## [3,] 9 36 81 # Squaring all elements (equivalent to above) A^2 ## [,1] [,2] [,3] ## [1,] 1 16 49 ## [2,] 4 25 64 ## [3,] 9 36 81 # Matrix multiplication A %*% A ## [,1] [,2] [,3] ## [1,] 30 66 102 ## [2,] 36 81 126 ## [3,] 42 96 150 # Matrix-vector multiplication A %*% v ## [,1] ## [1,] 30 ## [2,] 36 ## [3,] 42 Python # Matrix addition A + A ## array([[ 2, 4, 6], ## [ 8, 10, 12], ## [14, 16, 18]]) # Element-wise multiplication A * A ## array([[ 1, 4, 9], ## [16, 25, 36], ## [49, 64, 81]]) # Squaring all elements (equivalent to above) A ** 2 ## array([[ 1, 4, 9], ## [16, 25, 36], ## [49, 64, 81]]) # Matrix multiplication A @ A ## array([[ 30, 36, 42], ## [ 66, 81, 96], ## [102, 126, 150]]) # Matrix-vector multiplication np.dot(A, v) # as we saw in week 2 ## array([14, 32, 50]) A @ v ## array([14, 32, 50]) 4.2.2.1 Inversion, Eigenvalues and Eigenvectors For this section, we’ll reuse the matrix A from the previous examples. The rank of A, is, however, 2, as the third column is the sum of the first and second columns. This is going to be cool as it’s going to show us what happens on a computer when a matrix that does not have a unique inverse. Of course, as a counter example, we need to introduce a new full rank matrix B which will have a unique inverse: R # Define a full rank matrix B &lt;- matrix(c(1, 2, 3, 4, 5, 6, 1, 4, 3), nrow=3, byrow=T) B ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 1 4 3 Python # Define a full rank matrix B = np.array([[1, 2, 3], [4, 5, 6], [1, 4, 3]]) B ## array([[1, 2, 3], ## [4, 5, 6], ## [1, 4, 3]]) Now, let’s compute the determinant of our matrices A and B: R # Compute the determinant of A and B det(A) ## [1] 0 det(B) ## [1] 12 Python # Compute the determinant of A and B np.linalg.det(A) ## 0.0 np.linalg.det(B) ## 12.0 As you can see, the determinant of a full-rank matrix is non-zero, while the determinant of a non-full rank matrix is zero. Next, let’s compute the inverse of our matrices. Remember, only full-rank matrices have an inverse: R # Compute the inverse of A solve(A) ## Error in solve.default(A): Lapack routine dgesv: system is exactly singular: U[3,3] = 0 # Compute the inverse of B solve(B) ## [,1] [,2] [,3] ## [1,] -0.7500000 0.5000000 -0.25 ## [2,] -0.5000000 0.0000000 0.50 ## [3,] 0.9166667 -0.1666667 -0.25 solve(B) %*% B ## [,1] [,2] [,3] ## [1,] 1 0 0 ## [2,] 0 1 0 ## [3,] 0 0 1 Python # Compute the inverse of A in Python np.linalg.inv(A) ## Singular matrix np.linalg.inv(B) ## array([[-0.75 , 0.5 , -0.25 ], ## [-0.5 , 0. , 0.5 ], ## [ 0.91666667, -0.16666667, -0.25 ]]) np.dot(np.linalg.inv(B), B) ## array([[1., 0., 0.], ## [0., 1., 0.], ## [0., 0., 1.]]) Finally, let’s compute the eigenvalues and eigenvectors of our matrices A and B. The eigenvalues and eigenvectors provide important insights into the properties of the matrix: R # Compute the eigenvalues and eigenvectors of A and B in R eigen(A) ## eigen() decomposition ## $values ## [1] 1.611684e+01 -1.116844e+00 -5.700691e-16 ## ## $vectors ## [,1] [,2] [,3] ## [1,] -0.4645473 -0.8829060 0.4082483 ## [2,] -0.5707955 -0.2395204 -0.8164966 ## [3,] -0.6770438 0.4038651 0.4082483 eigen(B) ## eigen() decomposition ## $values ## [1] 10.2807637+0.0000000i -0.6403818+0.8701377i ## [3] -0.6403818-0.8701377i ## ## $vectors ## [,1] [,2] ## [1,] 0.3318753+0i -0.2937554-0.4626440i ## [2,] 0.8067885+0i -0.4955070+0.2516526i ## [3,] 0.4888263+0i 0.6251497+0.0000000i ## [,3] ## [1,] -0.2937554+0.4626440i ## [2,] -0.4955070-0.2516526i ## [3,] 0.6251497+0.0000000i Python # Compute the eigenvalues and eigenvectors of A and B in Python np.linalg.eig(A) ## EigResult(eigenvalues=array([ 1.61168440e+01, -1.11684397e+00, -1.30367773e-15]), eigenvectors=array([[-0.23197069, -0.78583024, 0.40824829], ## [-0.52532209, -0.08675134, -0.81649658], ## [-0.8186735 , 0.61232756, 0.40824829]])) np.linalg.eig(B) ## EigResult(eigenvalues=array([10.28076366+0.j , -0.64038183+0.87013768j, ## -0.64038183-0.87013768j]), eigenvectors=array([[ 0.33187527+0.j , -0.29375539-0.46264397j, ## -0.29375539+0.46264397j], ## [ 0.80678845+0.j , -0.49550702+0.25165256j, ## -0.49550702-0.25165256j], ## [ 0.48882634+0.j , 0.62514967+0.j , ## 0.62514967-0.j ]])) In R, the eigen() function returns a list containing two components: values and vectors, which represent the eigenvalues and eigenvectors, respectively. Those are stored in a list (we have seen this earlier). You can access the elements of a list using the $ operator. For example, if result is the output of eigen(B), e.g. result &lt;- eigen(B) you can access the eigenvalues with result$values and the eigenvectors with result$vectors. Alternatively, you can access the first element of a list via result[[1]] and the second via result[[2]]. In Python, the np.linalg.eig() function returns a tuple containing the eigenvalues and eigenvectors. This result can be interpreted as an object of type EigResult. An object in Python is an instance of a class, which can have attributes (data associated with the object) and methods (functions associated with the object). You can access the attributes of an object using the . operator. For example, if result is the output of np.linalg.eig(B), e.g. result &lt;- eigen(B), you can access the eigenvalues with result.eigenvalues and the eigenvectors with result.eigenvectors. Surprisingly enough, you used methods already all this time without knowing! Think about the many occasions you used a .: you were accessing a method in an object. 4.2.3 Exercise: Implementing a Linear Model Solver In this exercise, we will implement a linear model solver from scratch. This will help you understand the underlying mathematics of linear regression and how it can be implemented in code. A linear model is a mathematical model that assumes a linear relationship between the input variables (\\(X\\)) and the single output variable (\\(y\\)). More specifically, that y can be calculated from a linear combination of the input variables (\\(X\\)). When there is a single input variable, the method is referred to as simple linear regression. The general form of this model is: \\[y = X\\beta + \\epsilon\\] where: \\(y\\) is the output variable. \\(X\\) is the input variable. \\(\\beta\\) is the vector of coefficients. \\(\\epsilon\\) is the error term. The coefficients of the linear model can be estimated using the formula for \\(\\hat{\\beta}\\): \\[\\hat{\\beta} = (X^T X)^{-1} X^T y\\] Write some code to create the matrix and vector \\[ X = \\begin{bmatrix} 1 &amp; 2 \\\\ 1 &amp; 3 \\\\ 1 &amp; 4 \\\\ 1 &amp; 5 \\\\ \\end{bmatrix},\\ y = \\begin{bmatrix} 2 \\\\ 3 \\\\ 4 \\\\ 5 \\\\ \\end{bmatrix}. \\] 2. Using the formula above, estimate the coefficients \\(\\hat{\\beta}\\). 4.3 An end note to this chapter Both R and Python are multi-paradigm languages. This means that they have functional programming features, such as those we saw today, as well as object oriented programming features (R, in particular, supports even multiple dispatch). We have covered the first today as this is a scientific computing module, but we won’t cover the second. I heavily encourage you to research about it in your own time, in particular if you enjoy programming. Those are all concepts that gravitate around how we define objects on a computer, and how these objects should interact with functions. It can get pretty abstract really quickly, and there’s no true answer – I personally, to this date, have intense arguments with colleagues about what’s the best way of coding something. R, in particular, being a slab of several programming paradigms, it’s a great playground to test and compare these concepts in practice. Recall it was created from a 1970s programming language, and was modernized at least 3 times, to include 3 implementations of object oriented programming and several functional programming features. You could say I have a love/hate relationship with R… .book .book-body .page-wrapper .page-inner { max-width: 1200px !important; } "],["df_plt.html", "5 Data Frames and Plotting 5.1 Data Frames 5.2 Plotting with ggplot (and plotnine)", " 5 Data Frames and Plotting In this chapter, we will delve into the world of Data Frames and Plotting. These are crucial concepts in Computational Mathematics that will enable us to handle and visualize data effectively. 5.0.0.1 A note for R users. Before we start, we will need to import a very important library for writing modern R code: tidyverse. As mentioned earlier, R has changed a lot over the recent years, including more and more tools for functional programming, fast data manipulation, exploration, analysis and plotting. The tidyverse includes a wide range of packages that improve R for scientific computing. We have already seen one of those, in the past week: the purrr library. However, there’s much more, other of the core packages in the tidyverse include ggplot2 for data visualization, dplyr for data manipulation, and tidyr for data cleaning. By using these packages together, you can efficiently import, clean, manipulate, visualize, and analyze your data in a consistent and reproducible manner. This makes the tidyverse a powerful tool for modern scientific computing, and for this reason I heavily encourage you to use its functions and packages for the rest of this entire module and for your future analyses. To install the tidyverse (already installed on University Machines), run: install.packages(&quot;tidyverse&quot;) And to load the package: library(tidyverse) You only need to install a package once. But you have to load all the packages you want to use at the start of every session. As a suggestion, make sure the library(tidyverse) command sits at the top of your script from now on. In the previous chapters, we learned how to truly extract the power of functions. Well, one of the things introduced in purrr, and that goes really well with the tidyverse package, is the pipe operator. This operator allows you to pass the output of one function to another function as the first argument. This translates the mathematical function composition in programming, e.g. \\((f_1 \\circ f_2)(x)\\). This operator is written as |&gt; and is used to express a sequence of multiple operations in a more readable and intuitive way. In code, the equivalent of our expression would be x |&gt; f1 |&gt; f2. For example, if we want to compute the natural logarithm of the sum of the first 10 natural numbers, \\(\\ln(1 + 2+ 3+ ... + 10)\\), this is: x &lt;- 1:10 # create a vector with the first 10 integers x |&gt; sum() |&gt; log() ## [1] 4.007333 In this example, we start with a vector x containing the numbers from 1 to 10. We then use the pipe operator to pass this vector to the sum() function, which calculates the sum of all elements in the vector. The result of this operation (55) is then passed to the log() function, which calculates the natural logarithm of the input. This code is equivalent to writing: x &lt;- 1:10 log(sum(x)) ## [1] 4.007333 As you can see, using the pipe operator allows us to express the sequence of operations in a more readable and intuitive way. It can be particularly useful when working with complex data transformations, as it allows you to write code that closely matches the logical sequence of operations you have in mind. Remember that the pipe takes the output on its left and passes it as the first argument to the function on its right. For example, the function log takes as first argument the number and as second argument the base of our logarithm. If we want to compute the base-10 logarithm instead of the natural logarithm, we can do this by changing the second base argument after the piping: x &lt;- 1:10 x |&gt; sum() |&gt; log(base = 10) ## [1] 1.740363 This code is equivalent to writing: x &lt;- 1:10 log(sum(x), base = 10) ## [1] 1.740363 5.0.0.2 A note for Python users For this week, we will continue to use the pandas and numpy packages, which, as we learned, are fundamental tools for data manipulation and numerical computations in Python. import pandas as pd import numpy as np However, we will also introduce a new package: plotnine. This package is not included in the standard Python library, so you’ll need to install it. You can do this using pip, Python’s package installer. To do so, type the following command: !python -m pip install plotnine You only need to install this package once, and then you will be able to load it as you did with numpy or pandas. plotnine is an implementation of a grammar of graphics in Python, based on ggplot2 in R. ggplot2 is one of the most used libraries for data visualization in R, and plotnine brings its powerful data visualization capabilities to Python. It’s designed to work seamlessly with pandas data frames, making it extremely convenient for creating complex and beautiful statistical plots. Once you’ve installed plotnine, you can import it in your Python scripts using the following command: from plotnine import * With plotnine, you’ll be able to create a wide variety of plots and visualizations, and gain deeper insights from your data. 5.1 Data Frames A data frame is a table-like data structure available in languages like R and Python. It is similar to a spreadsheet or SQL table, or a dictionary of Series objects in Python. Data frames are generally used for statistical analysis in R and Python programming. In a data frame, the columns are named vectors, each containing a particular type of data (numeric, string, date, time). Unlike a matrix where every element must have the same data type, a data frame allows each column to have a different data type. This makes data frames more flexible for data analysis tasks where we often deal with data that have heterogeneous types. The columns of a data frame are often referred to as variables or features in statistics. In the context of mathematics or physics, these could be considered as parameters or attributes. The rows of the data frame correspond to a single observation across these variables. 5.1.1 Constructing and Accessing Data Frames Let’s start by constructing a data frame. We’ll use a dataset of different types of non-dairy milks, with their respective nutritional contents: Milk Type Calories Protein (g) Fiber (g) Carbohydrates (g) Sugars (g) Fats (g) Almond 60 1 1 8 7 2.5 Soy 100 7 2 10 NA 4 Oat 120 3 NA 20 19 2.5 Rice 130 1 NA 25 NA 2.5 In this dataset, the first column will be a character column, to indicate the type of the milk, whilst the others will be numericals. Furthemore, the “Fiber” and “Sugars” columns for Soy, Oat and Rice milk have NA values, indicating missing or not applicable data. This is often the case in real data, where usually information will not be available to us in the best way as possible. In this case, R and python will just tell us that we have a “Not Applicable (NA)” or “Not a Number (NaN)” unknown value. Now, let’s see how we can create this data frame in R and Python: R # Creating a data frame in R milk_df &lt;- tibble( Milk_Type = c(&quot;Almond&quot;, &quot;Soy&quot;, &quot;Oat&quot;, &quot;Rice&quot;), Calories = c(60, 100, 120, 130), Protein = c(1, 7, 3, 1), Fiber = c(1, 2, NA, NA), Carbohydrates = c(8, 10, 20, 25), Sugars = c(7, NA, 19, NA), Fats = c(2.5, 4, 2.5, 2.5) ) print(milk_df) ## # A tibble: 4 × 7 ## Milk_Type Calories Protein Fiber Carbohydrates Sugars ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Almond 60 1 1 8 7 ## 2 Soy 100 7 2 10 NA ## 3 Oat 120 3 NA 20 19 ## 4 Rice 130 1 NA 25 NA ## # ℹ 1 more variable: Fats &lt;dbl&gt; python # Creating a data frame in Python data = { &#39;Milk_Type&#39;: [&#39;Almond&#39;, &#39;Soy&#39;, &#39;Oat&#39;, &#39;Rice&#39;], &#39;Calories&#39;: [60, 100, 120, 130], &#39;Protein&#39;: [1, 7, 3, 1], &#39;Fiber&#39;: [1, 2, np.nan, np.nan], &#39;Carbohydrates&#39;: [8, 10, 20, 25], &#39;Sugars&#39;: [7, np.nan, 19, np.nan], &#39;Fats&#39;: [2.5, 4, 2.5, 2.5] } milk_df = pd.DataFrame(data) print(milk_df) ## Milk_Type Calories Protein Fiber Carbohydrates Sugars Fats ## 0 Almond 60 1 1.0 8 7.0 2.5 ## 1 Soy 100 7 2.0 10 NaN 4.0 ## 2 Oat 120 3 NaN 20 19.0 2.5 ## 3 Rice 130 1 NaN 25 NaN 2.5 Accessing Variables To access individual variables (columns) of the data frame, we can use the $ operator in R and the [] operator in Python: R # Accessing the &#39;Calories&#39; column in R # way 1 milk_df[&quot;Calories&quot;] ## # A tibble: 4 × 1 ## Calories ## &lt;dbl&gt; ## 1 60 ## 2 100 ## 3 120 ## 4 130 # way 2 milk_df$Calories ## [1] 60 100 120 130 python # Accessing the &#39;Calories&#39; column in Python # way 1 milk_df[&#39;Calories&#39;] ## 0 60 ## 1 100 ## 2 120 ## 3 130 ## Name: Calories, dtype: int64 # way 2 milk_df.Calories ## 0 60 ## 1 100 ## 2 120 ## 3 130 ## Name: Calories, dtype: int64 This will return the relative column. NOTE for R users. In R, we have two different behaviours if we use df[\"COLNAME\"] compared to df$COLNAME. In the first case, a subset of our data frame is returned (and the class is mantained), in the second case, we return the column as a vector (without the column title!). Additionally, we can use the select() function from the tidyverse package to select columns. # Using the select() function in R milk_df |&gt; select(Calories) ## # A tibble: 4 × 1 ## Calories ## &lt;dbl&gt; ## 1 60 ## 2 100 ## 3 120 ## 4 130 Recall that the pipe operator (|&gt;) is used to chain operations together, so it will take whatever we have at the left, and use it as a first argument to the function to the right. The above R code is equivalent to select(milk_df, Calories). Note, select will return the column as a subset of a data frame, and is equivalent to the [\"\"] notation. Sometimes this can be better, as you might not want to change the type of your objects inadvertently during execution. Accessing multiple columns. To access multiple variables at the same time, we can pass a vector of variable names: R # Accessing the &#39;Calories&#39; and &#39;Protein&#39; columns in R and storing it # in a new variable calories_protein &lt;- milk_df |&gt; select(Calories, Protein) # alternative # calories_protein &lt;- milk_df[c(&quot;Calories&quot;, &quot;Protein&quot;)] calories_protein ## # A tibble: 4 × 2 ## Calories Protein ## &lt;dbl&gt; &lt;dbl&gt; ## 1 60 1 ## 2 100 7 ## 3 120 3 ## 4 130 1 python # Accessing the &#39;Calories&#39; and &#39;Protein&#39; columns in Python and storing it # in a new variable calories_protein = milk_df[[&#39;Calories&#39;, &#39;Protein&#39;]] calories_protein ## Calories Protein ## 0 60 1 ## 1 100 7 ## 2 120 3 ## 3 130 1 Note that once we access (and store, as in this second example) a subset of a data frame, we get out another data frame. Note also that the $ (in R) and . (in Python) cannot access multiple columns. Accessing rows. To access individual rows in the data frames, we can use indexing. Similarly to vectors, to access multiple rows at the same time, we can pass a vector of row indices: R # Accessing the first row in R milk_df[1, ] ## # A tibble: 1 × 7 ## Milk_Type Calories Protein Fiber Carbohydrates Sugars ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Almond 60 1 1 8 7 ## # ℹ 1 more variable: Fats &lt;dbl&gt; # Accessing the first and second rows in R milk_df[1:2, ] ## # A tibble: 2 × 7 ## Milk_Type Calories Protein Fiber Carbohydrates Sugars ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Almond 60 1 1 8 7 ## 2 Soy 100 7 2 10 NA ## # ℹ 1 more variable: Fats &lt;dbl&gt; python # Accessing the first row in Python milk_df.iloc[0] ## Milk_Type Almond ## Calories 60 ## Protein 1 ## Fiber 1.0 ## Carbohydrates 8 ## Sugars 7.0 ## Fats 2.5 ## Name: 0, dtype: object # Accessing the first and second rows in Python milk_df.iloc[0:2] ## Milk_Type Calories Protein Fiber Carbohydrates Sugars Fats ## 0 Almond 60 1 1.0 8 7.0 2.5 ## 1 Soy 100 7 2.0 10 NaN 4.0 In R, when we use [1:2, ] on a data frame, we are working with a two-dimensional object. The 1:2 represents the row indices that we want to select, and the empty space after the comma indicates that we want to select all columns. So, [1:2, ] will select the first two rows and all columns of the data frame. This is different from selecting a vector because a vector is a one-dimensional object, and we only need to specify the indices of the elements we want to select. In Python, when we use .iloc[0:2] on a data frame, we are working with a two-dimensional object. The 0:2 represents the row indices that we want to select, and the absence of a second argument after the comma indicates that we want to select all columns. So, .iloc[0:2] will select the first two rows and all columns of the data frame. This is different from selecting elements from a vector because a list is a one-dimensional object, and we only need to specify the indices of the elements we want to select. Note also that when accessing only one row, in python, the returned element will be reshaped into a column vector. Having said that, we can also access a subset of the data frame by specifying both rows and columns simultaneously: R # Accessing a subset of the data frame in R subset_df &lt;- milk_df[1:2, c(&quot;Milk_Type&quot;, &quot;Calories&quot;, &quot;Protein&quot;)] # alternatively # subset_df &lt;- milk_df[1:2, 1:3] subset_df ## # A tibble: 2 × 3 ## Milk_Type Calories Protein ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Almond 60 1 ## 2 Soy 100 7 python # Accessing a subset of the data frame in Python subset_df = milk_df.loc[0:2, [&quot;Milk_Type&quot;, &quot;Calories&quot;, &quot;Protein&quot;]] # alternatively # subset_df = milk_df.iloc[0:2, [0, 1, 2]] subset_df ## Milk_Type Calories Protein ## 0 Almond 60 1 ## 1 Soy 100 7 ## 2 Oat 120 3 NOTE for Python users: Be careful, in this second statement we used an even different function, loc. In pandas, loc and iloc are two ways to select data from a DataFrame, called indexers. The loc indexer is used with the actual labels of the index or columns. On the other hand, iloc is used for indexing by integer position. This means that you’re referring to the row or column by its position in the DataFrame (like the index in a vector), not by its label. In summary, use loc when you want to refer to items by their label and iloc when you want to refer to them by their integer position. Overwriting Elements We can, of course, overwrite and change elements of our data frames. For instance, the simplest thing we could do at the moment, is to fill in the missing values of our data frame for our column “Fibers”. R # Imputing missing values in R # overwriting the original dataset milk_df$Fiber[is.na(milk_df$Fiber)] &lt;- c(1.2, 0.7) milk_df ## # A tibble: 4 × 7 ## Milk_Type Calories Protein Fiber Carbohydrates Sugars ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Almond 60 1 1 8 7 ## 2 Soy 100 7 2 10 NA ## 3 Oat 120 3 1.2 20 19 ## 4 Rice 130 1 0.7 25 NA ## # ℹ 1 more variable: Fats &lt;dbl&gt; python # Imputing missing values in Python # overwriting the original dataset milk_df.loc[np.isnan(milk_df[&#39;Fiber&#39;]), &#39;Fiber&#39;] = [1.2, 0.7] milk_df ## Milk_Type Calories Protein Fiber Carbohydrates Sugars Fats ## 0 Almond 60 1 1.0 8 7.0 2.5 ## 1 Soy 100 7 2.0 10 NaN 4.0 ## 2 Oat 120 3 1.2 20 19.0 2.5 ## 3 Rice 130 1 0.7 25 NaN 2.5 Note that, to impute the missing values, we can also use the replace_na() function in R and the fillna() function in Python, but these functions will overwrite all NAs in the dataset, leaving little to no flexibility. 5.1.1.1 Accessing Information about the Data Frame We can access various information about the data frame, such as its dimensions, number of rows, number of columns, column names, and a summary of its contents, with a lot of different functions. These will be not explained in detail, but can be useful for a lot of reasons related to exploratory analysis. R # Accessing information about the data frame in R # dimensions dim(milk_df) ## [1] 4 7 # number of rows and columns nrow(milk_df) ## [1] 4 ncol(milk_df) ## [1] 7 # variable names colnames(milk_df) ## [1] &quot;Milk_Type&quot; &quot;Calories&quot; &quot;Protein&quot; ## [4] &quot;Fiber&quot; &quot;Carbohydrates&quot; &quot;Sugars&quot; ## [7] &quot;Fats&quot; #variable names and types str(milk_df) ## tibble [4 × 7] (S3: tbl_df/tbl/data.frame) ## $ Milk_Type : chr [1:4] &quot;Almond&quot; &quot;Soy&quot; &quot;Oat&quot; &quot;Rice&quot; ## $ Calories : num [1:4] 60 100 120 130 ## $ Protein : num [1:4] 1 7 3 1 ## $ Fiber : num [1:4] 1 2 1.2 0.7 ## $ Carbohydrates: num [1:4] 8 10 20 25 ## $ Sugars : num [1:4] 7 NA 19 NA ## $ Fats : num [1:4] 2.5 4 2.5 2.5 # summary statistics summary(milk_df) ## Milk_Type Calories Protein ## Length:4 Min. : 60.0 Min. :1 ## Class :character 1st Qu.: 90.0 1st Qu.:1 ## Mode :character Median :110.0 Median :2 ## Mean :102.5 Mean :3 ## 3rd Qu.:122.5 3rd Qu.:4 ## Max. :130.0 Max. :7 ## ## Fiber Carbohydrates Sugars ## Min. :0.700 Min. : 8.00 Min. : 7 ## 1st Qu.:0.925 1st Qu.: 9.50 1st Qu.:10 ## Median :1.100 Median :15.00 Median :13 ## Mean :1.225 Mean :15.75 Mean :13 ## 3rd Qu.:1.400 3rd Qu.:21.25 3rd Qu.:16 ## Max. :2.000 Max. :25.00 Max. :19 ## NA&#39;s :2 ## Fats ## Min. :2.500 ## 1st Qu.:2.500 ## Median :2.500 ## Mean :2.875 ## 3rd Qu.:2.875 ## Max. :4.000 ## python # Accessing information about the data frame in Python # dimensions milk_df.shape ## (4, 7) # number of rows and columns len(milk_df) ## 4 len(milk_df.columns) # or milk_df.shape[1] ## 7 # variable names milk_df.columns ## Index([&#39;Milk_Type&#39;, &#39;Calories&#39;, &#39;Protein&#39;, &#39;Fiber&#39;, &#39;Carbohydrates&#39;, &#39;Sugars&#39;, ## &#39;Fats&#39;], ## dtype=&#39;object&#39;) # variable names and types milk_df.info() ## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; ## RangeIndex: 4 entries, 0 to 3 ## Data columns (total 7 columns): ## # Column Non-Null Count Dtype ## --- ------ -------------- ----- ## 0 Milk_Type 4 non-null object ## 1 Calories 4 non-null int64 ## 2 Protein 4 non-null int64 ## 3 Fiber 4 non-null float64 ## 4 Carbohydrates 4 non-null int64 ## 5 Sugars 2 non-null float64 ## 6 Fats 4 non-null float64 ## dtypes: float64(3), int64(3), object(1) ## memory usage: 356.0+ bytes # summary statistics milk_df.describe() ## Calories Protein Fiber Carbohydrates Sugars Fats ## count 4.000000 4.000000 4.000000 4.000000 2.000000 4.000 ## mean 102.500000 3.000000 1.225000 15.750000 13.000000 2.875 ## std 30.956959 2.828427 0.556028 8.098354 8.485281 0.750 ## min 60.000000 1.000000 0.700000 8.000000 7.000000 2.500 ## 25% 90.000000 1.000000 0.925000 9.500000 10.000000 2.500 ## 50% 110.000000 2.000000 1.100000 15.000000 13.000000 2.500 ## 75% 122.500000 4.000000 1.400000 21.250000 16.000000 2.875 ## max 130.000000 7.000000 2.000000 25.000000 19.000000 4.000 Based on the information above, how would you access the last 2 rows and the last 2 columns of your data frame? 5.1.2 Manipulating Data Frames When working with data in R or Python, most of the time we need to perform some data manipulation. This could involve modifying our data frame, accessing specific parts of it that are of interest, or creating new variables based on existing ones. Fortunately, both R and Python provide a set of powerful functions for these tasks. In R, we have bind_rows, filter, arrange, and mutate. In Python, we have concat, query, sort_values, and assign. We will now explore each of these functions in detail. 5.1.2.1 Adding New Rows To add new rows (or collate two data frames together!) we can use functions bind_rows (in R) and concat (in Python). This is formally referred to concatenating, which means to create a new data frame by attaching new rows to a data frame from a different one that shares the same columns. R # Creating a new data frame in R extra_milk_df &lt;- tibble( Milk_Type = c(&quot;Cashew&quot;, &quot;Hazelnut&quot;), Calories = c(80, 130), Protein = c(0.7, 2), Fiber = c(1, 2), Carbohydrates = c(2, 8), Sugars = c(0.5, 3), Fats = c(3, 9) ) # attaching new rows to our existing data frame milk_df &lt;- milk_df |&gt; bind_rows(extra_milk_df) milk_df ## # A tibble: 6 × 7 ## Milk_Type Calories Protein Fiber Carbohydrates Sugars ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Almond 60 1 1 8 7 ## 2 Soy 100 7 2 10 NA ## 3 Oat 120 3 1.2 20 19 ## 4 Rice 130 1 0.7 25 NA ## 5 Cashew 80 0.7 1 2 0.5 ## 6 Hazelnut 130 2 2 8 3 ## # ℹ 1 more variable: Fats &lt;dbl&gt; python # Creating a new data frame in Python extra_milk_df = pd.DataFrame({ &#39;Milk_Type&#39;: [&quot;Cashew&quot;, &quot;Hazelnut&quot;], &#39;Calories&#39;: [80, 130], &#39;Protein&#39;: [0.7, 2], &#39;Fiber&#39;: [1, 2], &#39;Carbohydrates&#39;: [2, 8], &#39;Sugars&#39;: [0.5, 3], &#39;Fats&#39;: [3, 9] }) # Attaching new rows to our existing data frame milk_df = pd.concat([milk_df, extra_milk_df], ignore_index=True) milk_df ## Milk_Type Calories Protein Fiber Carbohydrates Sugars Fats ## 0 Almond 60 1.0 1.0 8 7.0 2.5 ## 1 Soy 100 7.0 2.0 10 NaN 4.0 ## 2 Oat 120 3.0 1.2 20 19.0 2.5 ## 3 Rice 130 1.0 0.7 25 NaN 2.5 ## 4 Cashew 80 0.7 1.0 2 0.5 3.0 ## 5 Hazelnut 130 2.0 2.0 8 3.0 9.0 Note that in R you can use also the rbind function that we have seen in the past week. In Python you will need to add the ignore_index=True argument, otherwise this will mess up your indexing of the data frame, and could cause unexpected results. 5.1.2.2 Adding New Columns Adding new columns allows us to easily add new columns that are functions of existing ones. In R, we use mutate(), and in Python, we use assign. R # Compute percentage of sugars over carbohydrates in R # Then, adding the total weight of the components and computing the # protein content milk_df &lt;- milk_df |&gt; mutate(sugar_percent = (Sugars / Carbohydrates) * 100, tot_wei = Protein + Fiber + Carbohydrates + Fats, protein_content = Protein / tot_wei * 100) milk_df ## # A tibble: 6 × 10 ## Milk_Type Calories Protein Fiber Carbohydrates Sugars Fats sugar_percent tot_wei protein_content ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Almond 60 1 1 8 7 2.5 87.5 12.5 8 ## 2 Soy 100 7 2 10 NA 4 NA 23 30.4 ## 3 Oat 120 3 1.2 20 19 2.5 95 26.7 11.2 ## 4 Rice 130 1 0.7 25 NA 2.5 NA 29.2 3.42 ## 5 Cashew 80 0.7 1 2 0.5 3 25 6.7 10.4 ## 6 Hazelnut 130 2 2 8 3 9 37.5 21 9.52 python # Compute percentage of sugars over carbohydrates in Python # Then, adding the total weight of the components and computing the # protein content milk_df = milk_df.assign( sugar_percent = lambda df: (df.Sugars / df.Carbohydrates) * 100, tot_wei = lambda df: df.Protein + df.Fiber + df.Carbohydrates + df.Fats, protein_content = lambda df: df.Protein / df.tot_wei * 100 ) milk_df ## Milk_Type Calories Protein Fiber Carbohydrates Sugars Fats sugar_percent tot_wei protein_content ## 0 Almond 60 1.0 1.0 8 7.0 2.5 87.5 12.5 8.000000 ## 1 Soy 100 7.0 2.0 10 NaN 4.0 NaN 23.0 30.434783 ## 2 Oat 120 3.0 1.2 20 19.0 2.5 95.0 26.7 11.235955 ## 3 Rice 130 1.0 0.7 25 NaN 2.5 NaN 29.2 3.424658 ## 4 Cashew 80 0.7 1.0 2 0.5 3.0 25.0 6.7 10.447761 ## 5 Hazelnut 130 2.0 2.0 8 3.0 9.0 37.5 21.0 9.523810 The advantage of using mutate and assign over directly overwriting columns is that those function allow you to reference other columns that are being created within the same call. This makes it possible to create multiple interdependent columns in one go. In contrast, when overwriting columns directly, you would have to create each new column one at a time, which could be less efficient and harder to read. If we had to do the same code manually, each one at a time, this would have looked like the following: R ### equivalent to above statement # Compute percentage of sugars over carbohydrates in R milk_df$sugar_percent &lt;- (milk_df$Sugars / milk_df$Carbohydrates) * 100 # Then, adding the total weight of the components milk_df$tot_wei &lt;- milk_df$Protein + milk_df$Fiber + milk_df$Carbohydrates + milk_df$Fats # Finally, computing the protein content milk_df$protein_content = milk_df$Protein / milk_df$tot_wei * 100 milk_df ## # A tibble: 6 × 10 ## Milk_Type Calories Protein Fiber Carbohydrates Sugars ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Almond 60 1 1 8 7 ## 2 Soy 100 7 2 10 NA ## 3 Oat 120 3 1.2 20 19 ## 4 Rice 130 1 0.7 25 NA ## 5 Cashew 80 0.7 1 2 0.5 ## 6 Hazelnut 130 2 2 8 3 ## # ℹ 4 more variables: Fats &lt;dbl&gt;, sugar_percent &lt;dbl&gt;, ## # tot_wei &lt;dbl&gt;, protein_content &lt;dbl&gt; python ### equivalent to above statement # Compute percentage of sugars over carbohydrates in Python milk_df[&#39;sugar_percent&#39;] = (milk_df[&#39;Sugars&#39;] / milk_df[&#39;Carbohydrates&#39;]) * 100 # Then, adding the total weight of the components milk_df[&#39;tot_wei&#39;] = milk_df[&#39;Protein&#39;] + milk_df[&#39;Fiber&#39;] + milk_df[&#39;Carbohydrates&#39;] + milk_df[&#39;Fats&#39;] # Finally, computing the protein content milk_df[&#39;protein_content&#39;] = milk_df[&#39;Protein&#39;] / milk_df[&#39;tot_wei&#39;] * 100 milk_df ## Milk_Type Calories Protein Fiber Carbohydrates Sugars Fats sugar_percent tot_wei protein_content ## 0 Almond 60 1.0 1.0 8 7.0 2.5 87.5 12.5 8.000000 ## 1 Soy 100 7.0 2.0 10 NaN 4.0 NaN 23.0 30.434783 ## 2 Oat 120 3.0 1.2 20 19.0 2.5 95.0 26.7 11.235955 ## 3 Rice 130 1.0 0.7 25 NaN 2.5 NaN 29.2 3.424658 ## 4 Cashew 80 0.7 1.0 2 0.5 3.0 25.0 6.7 10.447761 ## 5 Hazelnut 130 2.0 2.0 8 3.0 9.0 37.5 21.0 9.523810 You can see how this makes the code longer and potentially harder to read, particularly in R. Note also how, over the rows of soy and rice, the sugar_percent column has missing values, and similarly the protein_content variable has skewed values: this is because the value of the sugar content was missing originally. Be careful about missing values! 5.1.2.3 Filtering Rows Filtering allows us to focus on a subset of the rows of a data frame. This is based on the result of a vectorised logic expression. In a way, we have already seen this in the past when selecting subsets of vectors! In R, we use filter(), and in Python, we use query(). R # Filtering rows where Calories is greater than 100 in R milk_df |&gt; filter(Calories &gt; 100) ## # A tibble: 3 × 10 ## Milk_Type Calories Protein Fiber Carbohydrates Sugars ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Oat 120 3 1.2 20 19 ## 2 Rice 130 1 0.7 25 NA ## 3 Hazelnut 130 2 2 8 3 ## # ℹ 4 more variables: Fats &lt;dbl&gt;, sugar_percent &lt;dbl&gt;, ## # tot_wei &lt;dbl&gt;, protein_content &lt;dbl&gt; python # Filtering rows where Calories is greater than 100 in Python milk_df.query(&#39;Calories &gt; 100&#39;) ## Milk_Type Calories Protein Fiber Carbohydrates Sugars Fats sugar_percent tot_wei protein_content ## 2 Oat 120 3.0 1.2 20 19.0 2.5 95.0 26.7 11.235955 ## 3 Rice 130 1.0 0.7 25 NaN 2.5 NaN 29.2 3.424658 ## 5 Hazelnut 130 2.0 2.0 8 3.0 9.0 37.5 21.0 9.523810 5.1.2.4 Reordering Rows Reordering allows us to arrange the rows in the data frame in a specific order. In R, we use arrange(), and in Python, we use sort_values(). R milk_df &lt;- milk_df |&gt; arrange(desc(sugar_percent)) milk_df ## # A tibble: 6 × 10 ## Milk_Type Calories Protein Fiber Carbohydrates Sugars ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Oat 120 3 1.2 20 19 ## 2 Almond 60 1 1 8 7 ## 3 Hazelnut 130 2 2 8 3 ## 4 Cashew 80 0.7 1 2 0.5 ## 5 Soy 100 7 2 10 NA ## 6 Rice 130 1 0.7 25 NA ## # ℹ 4 more variables: Fats &lt;dbl&gt;, sugar_percent &lt;dbl&gt;, ## # tot_wei &lt;dbl&gt;, protein_content &lt;dbl&gt; python # Arranging rows by decreasing sugar_percent in Python milk_df = milk_df.sort_values(&#39;sugar_percent&#39;, ascending=False) milk_df ## Milk_Type Calories Protein Fiber Carbohydrates Sugars Fats sugar_percent tot_wei protein_content ## 2 Oat 120 3.0 1.2 20 19.0 2.5 95.0 26.7 11.235955 ## 0 Almond 60 1.0 1.0 8 7.0 2.5 87.5 12.5 8.000000 ## 5 Hazelnut 130 2.0 2.0 8 3.0 9.0 37.5 21.0 9.523810 ## 4 Cashew 80 0.7 1.0 2 0.5 3.0 25.0 6.7 10.447761 ## 1 Soy 100 7.0 2.0 10 NaN 4.0 NaN 23.0 30.434783 ## 3 Rice 130 1.0 0.7 25 NaN 2.5 NaN 29.2 3.424658 These examples show the power of modern R and Python for data manipulation! By these functions we can perform complex data manipulations with just a few lines of code. Now the coolest thing, is that you can run all the commands above (and more!) in one single statement, through, in R, the power of the pipe (|&gt;), and in Python with Pandas by concatenating methods. See the two chunks below: R milk_df |&gt; filter(!is.na(Sugars)) |&gt; mutate(sugar_percent = (Sugars / Carbohydrates) * 100, tot_wei = Protein + Fiber + Carbohydrates + Fats, protein_content = Protein / tot_wei * 100) |&gt; arrange(desc(protein_content)) |&gt; select(Milk_Type, protein_content) ## # A tibble: 4 × 2 ## Milk_Type protein_content ## &lt;chr&gt; &lt;dbl&gt; ## 1 Oat 11.2 ## 2 Cashew 10.4 ## 3 Hazelnut 9.52 ## 4 Almond 8 python ( milk_df .query(&#39;Sugars == Sugars&#39;) # Equivalent to !is.na(Sugars) in R .assign( sugar_percent = lambda df: (df.Sugars / df.Carbohydrates) * 100, tot_wei = lambda df: df.Protein + df.Fiber + df.Carbohydrates + df.Fats, protein_content = lambda df: df.Protein / df.tot_wei * 100 ) .sort_values(&#39;protein_content&#39;, ascending=False) [[&#39;Milk_Type&#39;, &#39;protein_content&#39;]] ) ## Milk_Type protein_content ## 2 Oat 11.235955 ## 4 Cashew 10.447761 ## 5 Hazelnut 9.523810 ## 0 Almond 8.000000 NOTE for Python users: In this Python code, query('Sugars == Sugars') is used to filter out rows where ‘Sugars’ is NaN (since NaN != NaN). Also, for the statement to evaluate correctly, we need the () brackets around the whole code chunk. This is because python is reading it as whole line, equivalent to INPUT_DF.QUERY_OUT.ASSIGN_OUT.SORT_OUT[[INDEXING]]. NOTE for users learning both: The difference between these two statements is one of the reasons I personally prefer modern R for data manipulation and plotting. Good news is: you can use Python functions in R in a seamless way. Whilst this will be beyond the scope of this module, if you are curious on how to do so, you should probably read the reticulate interface guide. You will find this here. As a testament, this whole module was made possible via reticulate: these notes were written using R and python simultaneously. You can see how in the environment corner R Studio is tracking both the python environment and the R environment side to side in a seamless way. 5.1.3 A Real Data Frame Now that we have the basis of manipulating data frames, before proceeding to the next steps, let’s work with a real-world data frame: mtcars! This data frame is available in both R (natively) and Python (in plotnine.data.mtcars) and contains various car attributes. However, to simulate a real world scenario, we’ll see how to import it from a csv file. 5.1.3.1 Importing the Data Frame First, let’s import the mtcars data frame. You’ll need to download this from Moodle, and save it under your working directory as “mtcars.csv”. Remember that we learned how to read from CSV files in week 1! Well, this is the first time we are doing this in a practical sense. R # Importing the data frame in R mtcars &lt;- read.csv(&quot;mtcars.csv&quot;) python mtcars = pd.read_csv(&quot;mtcars.csv&quot;) 5.1.3.2 Understanding the Data Frames The mtcars data frame contains the following columns: mpg: Miles/(US) gallon cyl: Number of cylinders disp: Displacement (cu.in.) hp: Gross horsepower drat: Rear axle ratio wt: Weight (1000 lbs) qsec: 1/4 mile time vs: Engine (0 = V-shaped, 1 = straight) am: Transmission (0 = automatic, 1 = manual) gear: Number of forward gears carb: Number of carburetors 5.1.3.3 Exploring your data frame We can display the first few values of the data frame using the head() function in R and Python. R # Displaying the first few values in R head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 python # Displaying the first few values in Python mtcars.head() ## mpg cyl disp hp drat wt qsec vs am gear carb ## 0 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 1 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 2 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 3 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 4 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 In RStudio, you can also explore the data frame visually via the View() function. This opens the data frame in a spreadsheet-like view, which can be very useful for getting a sense of the data. A shortcut for this is via the “spreadsheet” button on your environment pane, highlighted in yellow in the figure below: Try to click it! 5.1.3.4 Factor (or Categorical) Variables In R, a factor is a variable that can take on a limited number of distinct values, such as ‘yes’ and ‘no’. It’s used to store categorical data. In Python, we use the category data type for similar purposes. In the mtcars data frame, the vs and am columns are currently integers, but they represent categorical data. In fact, one represent the engine type of the car, and the other the type of transmission. Therefore, to specifically tell our programming languages this, we should convert them to factors (in R) or categories (in Python). This will affect many things when dealing with those variables, like producing summaries or displaying those in plots. Here’s how we can do this: R # Converting to factors in R mtcars &lt;- mtcars |&gt; mutate(vs = factor(vs, labels = c(&quot;V-shaped&quot;, &quot;straight&quot;)), am = factor(am, labels = c(&quot;automatic&quot;, &quot;manual&quot;))) # Checking the conversion str(mtcars) ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : int 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num 160 160 108 258 360 ... ## $ hp : int 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : Factor w/ 2 levels &quot;V-shaped&quot;,&quot;straight&quot;: 1 1 2 2 1 2 1 2 2 2 ... ## $ am : Factor w/ 2 levels &quot;automatic&quot;,&quot;manual&quot;: 2 2 2 1 1 1 1 1 1 1 ... ## $ gear: int 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: int 4 4 1 1 2 1 4 2 2 4 ... python # assigning labels as strings mtcars = mtcars.assign( vs = list(map(lambda x: &quot;V-Shaped&quot; if x == 0 else &quot;straight&quot;, mtcars[&#39;vs&#39;])), am = list(map(lambda x: &quot;automatic&quot; if x == 0 else &quot;manual&quot;, mtcars[&#39;am&#39;])) ) # Converting to categories in Python mtcars[&#39;vs&#39;] = mtcars[&#39;vs&#39;].astype(&#39;category&#39;) mtcars[&#39;am&#39;] = mtcars[&#39;am&#39;].astype(&#39;category&#39;) # Checking the conversion mtcars.info() ## &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; ## RangeIndex: 32 entries, 0 to 31 ## Data columns (total 11 columns): ## # Column Non-Null Count Dtype ## --- ------ -------------- ----- ## 0 mpg 32 non-null float64 ## 1 cyl 32 non-null int64 ## 2 disp 32 non-null float64 ## 3 hp 32 non-null int64 ## 4 drat 32 non-null float64 ## 5 wt 32 non-null float64 ## 6 qsec 32 non-null float64 ## 7 vs 32 non-null category ## 8 am 32 non-null category ## 9 gear 32 non-null int64 ## 10 carb 32 non-null int64 ## dtypes: category(2), float64(5), int64(4) ## memory usage: 2.7 KB mtcars.head() ## mpg cyl disp hp drat wt qsec vs am gear carb ## 0 21.0 6 160.0 110 3.90 2.620 16.46 V-Shaped manual 4 4 ## 1 21.0 6 160.0 110 3.90 2.875 17.02 V-Shaped manual 4 4 ## 2 22.8 4 108.0 93 3.85 2.320 18.61 straight manual 4 1 ## 3 21.4 6 258.0 110 3.08 3.215 19.44 straight automatic 3 1 ## 4 18.7 8 360.0 175 3.15 3.440 17.02 V-Shaped automatic 3 2 This code converts the vs and am columns to factors or categories and then checks that the conversion was successful via the str function in R and the info() method in python. The process in Python is a bit more involved as the astype function does not allow automatic assignment of labels to the categories. 5.1.4 Group by and summarise Ok cool, we know how to handle data frames. Great. However, this is the time we make something useful of them, no? Like, for instance, extracting information. You know, starting to see the patterns, connecting the dots. All of that crazy stuff that they do in Social Media companies, like learning your family favorite band’s, the type of food they’re eating, or the dance moves they’re doing every morning. You know, turning things and people into numbers, the favorite statistician’s activity. We have already saw how to compute the mean, the max and other summary information across the data frame as a whole, but that doesn’t help us at all… Well, we showed how we have some variables in data frames that show certain distinct characteristics, which are shared across multiple individuals. Like the city you live in, for instance, or the type of engine of a car. Well, the idea, is that, when we take a data frame, in all that chaos of numbers, when we start to split the observations across certain characteristics, suddenly, patterns start to emerge. More formally, we create groups of observations, and we want to summarize and aggregate information within these groups. A grouped data frame is a version of the data frame split into groups based on specified conditions. Each group is a subset of data frame rows that have the same values in specified columns. Grouping is a powerful concept because it allows you to perform operations on subsets of the data frame. This is achieved via group_by in R and groupby in Python. Then, the summarise function (in R), or agg (in Python, for aggregate) applies a transformation to one or more columns within each subgroup of a grouped data frame. This transformation is typically an aggregation operation that reduces each subgroup to a single row, such as computing the mean, sum, or count. Graphically: Let’s use our mtcars data frame to illustrate these functions work. First, we’ll compute the average miles per gallon (mpg) and horsepower (hp) across various engine types (vs). In the mtcars data frame, the vs column represents the engine type: 0 for V-shaped and 1 for straight. In our graph above one would be the circle, the other the square. We will group by the vs column, and we will run a summary, the mean, in this case, for the variables mpg and hp . In our graph mean(mpg) would be \\(f_1(V1)\\), and mean(hp) would be corresponding to \\(f_2(V2)\\). R # Group by &#39;vs&#39; and compute average &#39;mpg&#39; and &#39;hp&#39; in R mtcars |&gt; group_by(vs) |&gt; summarise(avg_mpg = mean(mpg), avg_hp = mean(hp)) ## # A tibble: 2 × 3 ## vs avg_mpg avg_hp ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 V-shaped 16.6 190. ## 2 straight 24.6 91.4 python ( mtcars .groupby(&#39;vs&#39;, observed=True) .agg({&#39;mpg&#39; : &#39;mean&#39;, &#39;hp&#39; : &#39;mean&#39;}) ) ## mpg hp ## vs ## V-Shaped 16.616667 189.722222 ## straight 24.557143 91.357143 The results show that the average mpg are higher for straight engines compared to V-shaped engines. Controversely, on the other hand, the average horse power are lower for straight engines compared to V-shaped engines. This could be due to the design and efficiency differences between the two engine types: usually straight engines are for regular small cars, whilst V-shaped engines tend to be in sports cars. The first will be more efficient and be less powerful compared to the second. See? We have extracted information! We can make this example more and more complicated. Let’s add a second grouping variable: the type of transmission (am). In the mtcars data frame, the am column represents the transmission type: 0 for automatic and 1 for manual. R # Group by &#39;vs&#39; and &#39;am&#39;, and compute average &#39;mpg&#39; and &#39;hp&#39; # and min qsec mtcars |&gt; group_by(vs, am) |&gt; summarise(avg_mpg = mean(mpg), avg_hp = mean(hp), min_qsec = min(qsec)) ## `summarise()` has grouped output by &#39;vs&#39;. You can override ## using the `.groups` argument. ## # A tibble: 4 × 5 ## # Groups: vs [2] ## vs am avg_mpg avg_hp min_qsec ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 V-shaped automatic 15.0 194. 15.4 ## 2 V-shaped manual 19.8 181. 14.5 ## 3 straight automatic 20.7 102. 18.3 ## 4 straight manual 28.4 80.6 16.9 python # Group by &#39;vs&#39; and &#39;am&#39;, and compute average &#39;mpg&#39; and &#39;hp&#39; # and min qsec ( mtcars .groupby([&#39;vs&#39;, &#39;am&#39;]) .agg({&#39;mpg&#39; : &#39;mean&#39;, &#39;hp&#39; : &#39;mean&#39;, &#39;qsec&#39; : &#39;min&#39;}) ) ## mpg hp qsec ## vs am ## V-Shaped automatic 15.050000 194.166667 15.41 ## manual 19.750000 180.833333 14.50 ## straight automatic 20.742857 102.142857 18.30 ## manual 28.371429 80.571429 16.90 ## ## &lt;string&gt;:5: FutureWarning: The default of observed=False is deprecated and will be changed to True in a future version of pandas. Pass observed=False to retain current behavior or observed=True to adopt the future default and silence this warning. By adding a second grouping variable, we can explore more complex relationships in our data. Looking at the mtcars analysis, we see that cars with automatic transmissions from the 1973-74 era generally consumed more fuel and took longer to accelerate, regardless of the engine type. Hold up, isn’t that contrary to what we know about cars today? Well, remember, this data is from the early 70s when automatic transmissions were mostly hydraulic and not as efficient as they are now. Fast forward to today, and you’ll find that automatic transmissions can be just as, if not more, fuel-efficient than manual ones. They can even outpace manual transmissions in terms of acceleration in certain vehicles! Just think about F1: while it’s true that drivers have control over gear changes, it’s not entirely manual. They use a semi-automatic transmission system where they initiate gear changes using paddles on the steering wheel, but the actual gear change is performed by an onboard computer. So, while our analysis holds true for the cars of yesteryears, the automotive world has come a long way since then! 5.1.5 Exercise: an mtcars analysis In this exercise, we will further explore the mtcars dataset. The goal is to create a new variable, efficiency, and summarise the data to produce meaningful statistics. You should: Create a new column “efficiency” which is the ratio of miles per gallon to horsepower. Filter the data to only include cars with the straight engine. Arrange these cars in descending order of efficiency and print the head of our d Group the original data by type of transmission and number of cylinders. Calculate the average efficiency for each group. Do our finding reflect what we mentioned above? 5.2 Plotting with ggplot (and plotnine) When we talk about plotting with ggplot and plotnine, we’re referring to two powerful tools for creating graphics in R and Python, respectively. These tools are based on a concept known as the Grammar of Graphics. So, what is the Grammar of Graphics? Well, just like how grammar rules can help us construct sentences in a language, the Grammar of Graphics provides a structured framework for describing and building graphs. In other words, it’s like a language for creating graphics, where we translate data in visual elements. This grammar was implemented in R through a package called ggplot2 and in Python through a package called plotnine. The Grammar of Graphics allows us to create a wide variety of plots by breaking up graphs into semantic components, specifically scales and layers. Scales refer to the rules for mapping variables from our data to aesthetics (visual elements) like color, size, or position. These are specified via the aes function. For example, in a scatter plot of the car horsepower hp against miles per gallon mpg (from our mtcars dataset), the scale determines how the each car horsepower is translated into positions along the x-axis and how miles per gallon are translated into positions along the y-axis. So to plot the hp against mpg, we will need to write aes(x=hp, y=mpg). Layers are the actual data elements that we can see in the plot, like points, lines, or bars. These are specifed in through functions starting with geom_. In our scatter plot example, each point representing a car is a layer. Some of the geometries will share the same aesthetics: for example, both the scatter plot and the line plot share the \\(x\\) and the \\(y\\) axis, however one represents data with points, the other with interconnected lines. By specifying these components, we can flexibly and systematically create a wide variety of plots. For instance, we could easily switch from a scatter plot to a line plot, or change the way data values are mapped to colors. This makes ggplot and plotnine extremely powerful for data visualization. If this sounds complicated, it’s really not in practice! ggplot is one of those things that it’s easier done that said. Let’s start with some basic plots to hopefully clear things a bit! 5.2.1 Basic Plots 5.2.1.1 Plotting the distribution of a variable A histogram is a representation of the distribution of a single variable, hence the aes() will only have the x. The histogram layer is translated via the function geom_histogram. Let’s create a histogram of mpg (miles per gallon). R ggplot(mtcars, aes(x=mpg)) + geom_histogram(binwidth=5) python ( ggplot(mtcars, aes(x=&#39;mpg&#39;)) + geom_histogram(binwidth=5) ) ## &lt;Figure Size: (640 x 480)&gt; Let’s break down the syntax: - ggplot(mtcars, aes(x=mpg)). initializes a ggplot object. mtcars is the data frame we’re using we wish to get the data from, and aes(x=mpg) sets the aesthetic mappings, which define how variables in the data are mapped to visual properties of the plot. In this case, we’re mapping the mpg variable to the x-axis. +. The plus operator is used to add layers to the plot. You can add as many layers as you want to a ggplot by chaining them together with +. geom_histogram(binwidth=5). This adds a histogram layer to the plot. The binwidth argument sets the width of the bins in the histogram. Geometries can have different options! Try to change the binwidth and see what happens. To solidify the concept of aesthetic mapping, let’s see what happens by swapping the x for a y in our aes function: R # python users looking at this example: this is one particular # case where ggplot2 in R is better then plotnine in python. The difference # here is that, in R, boxplot can accept both an x or y aesthetic ggplot(mtcars, aes(y=mpg)) + geom_histogram(binwidth=5) python # this will produce an error in python since # geom_histogram only works with the x axis in plotnine. # plotnine has still minor limitations # compared to ggplot2 in R. Just look at the R output. ( ggplot(mtcars, aes(y=&#39;mpg&#39;)) + geom_histogram() ) ## &#39;stat_bin() must not be used with a y aesthetic.&#39; # we can obtain a similar visualization via coord flip ( ggplot(mtcars, aes(x=&#39;mpg&#39;)) + geom_histogram() + coord_flip() ) ## &lt;Figure Size: (640 x 480)&gt; ## ## /home/romano/Documents/EpiC/.venv/lib/python3.11/site-packages/plotnine/stats/stat_bin.py:109: PlotnineWarning: &#39;stat_bin()&#39; using &#39;bins = 6&#39;. Pick better value with &#39;binwidth&#39;. You can see by how changing the axis aesthetic, the histogram was mirrored over the axis. Let’s see what happens now, if we swap the geom_histogram layer for a geom_boxplot: R ggplot(mtcars, aes(y=mpg)) + geom_boxplot() python ( ggplot(mtcars, aes(y=&#39;mpg&#39;)) + geom_boxplot() ) ## &lt;Figure Size: (640 x 480)&gt; This will give us a complete different type of distribution plot, the boxplot! A boxplot is a very useful graphical representation of a variable’s distribution based on a five-number summary: the minimum, first quartile (Q1), median, third quartile (Q3), and maximum. The box represents the interquartile range (IQR), containing the middle 50% of the data, with a line indicating the median. The whiskers extend from the box to the minimum and maximum values, excluding outliers, which are represented as individual points. Boxplots are useful for understanding data distribution, detecting outliers, and comparing data sets. The boxplot has a common aesthetic with the histogram: in fact, it’s just a different way to represent a distribution! All we had to do was change the layer. Funny enough, in ggplot, if we want, and they share aeshtetics, we can stack layers on top of each other just by adding more. For instance: R # R users, look at the output of python plot. # We can make the same plot in R! # Can you translate the python code to ggplot2? ggplot(mtcars, aes(y=mpg)) + geom_boxplot() + geom_density() python # the same plot in plotnine is not possible as # the boxplot and the density plot have different aestethics. # however, we can plot (this should work in R too): ( ggplot(mtcars, aes(x=&quot;mpg&quot;)) + geom_histogram(aes(y = &quot;..density..&quot;), binwidth=3) + geom_density() ) ## &lt;Figure Size: (640 x 480)&gt; We have just added an estimate of our density to our boxplot/histogram! 5.2.1.2 Plotting multiple dimensions A scatterplot uses two dimensions, allowing us to visualize the relationship between two variables. So, our aestetic, now gets another argument: we have now both the x and the y! Let’s create a scatterplot of mpg against hp (horsepower), to replicate our initial example. R ggplot(mtcars, aes(x=hp, y=mpg)) + geom_point() # + theme_minimal() python ( ggplot(mtcars, aes(x=&#39;hp&#39;, y=&#39;mpg&#39;)) + geom_point() # + theme_minimal() ) ## &lt;Figure Size: (640 x 480)&gt; Uncomment the theme_minimal to add an additional theme to our plot, and you will have recreated the plot at the beginning of the section. Representing higher dimentions. Now, the cool stuff is that we can introduce higher dimensions by mapping additional variables to other aesthetics like color (or the point shape). Let’s color the points in our scatterplot based on the type of transmission (am). R ggplot(mtcars, aes(x=hp, y=mpg, color=am)) + geom_point() python ( ggplot(mtcars, aes(x=&#39;hp&#39;, y=&#39;mpg&#39;, color=&#39;am&#39;)) + geom_point() ) ## &lt;Figure Size: (640 x 480)&gt; We can see graphically now why the mean consumption in the automatic transmission was higher in the example before! You can see that it’s separate. Note that we can add as many dimensions as our layer allows it. For instance, to throw the engine type into the mix, I can change the shape of my points: R ggplot(mtcars, aes(x=hp, y=mpg, color=am, shape= vs)) + geom_point() python ( ggplot(mtcars, aes(x=&#39;hp&#39;, y=&#39;mpg&#39;, color=&#39;am&#39;, shape=&#39;vs&#39;)) + geom_point() ) ## &lt;Figure Size: (640 x 480)&gt; Or again, maybe we want a different visualization completely! As I can change the shape of my points, I can change the linetype of my boxplots: R ggplot(mtcars, aes(y=mpg, color=am, linetype = vs)) + geom_boxplot() python ( ggplot(mtcars, aes(y=&#39;mpg&#39;, color=&#39;am&#39;, linetype=&#39;vs&#39;)) + geom_boxplot() ) ## &lt;Figure Size: (640 x 480)&gt; 5.2.2 Advanced plots This section will not be evaluated on the quizzes, however if you are feeling confident you should read it anyway as it shows how powerful ggplot can get. If you’re overwelmed, feel free to skip at the exercise, and complete up to the medium level. In ggplot you can change a bunch of graphical characteristics very easily by just adding things. This is a very functional way of thinking of a plot, where we can concatenate (again, function compositions!) multiple graphical elements! Few things you can easily change include: Themes: By adding themes you can use different themes to change the overall appearance of your plot. For example, theme_minimal() gives a minimal theme with no background grid. Try theme_bw() for a different one. Title: You can add or change the title of your plot by adding ggtitle(\"Your Title\"). Labels: You can change the axis labels by adding labs(x = \"X Label Name\", y = \"Y Label Name\"). Limits: You can set the limits of your axes by adding xlim(lower, upper) and ylim(lower, upper). Remember, you can concatenate all these things together one after the other in one single ggplot call: R ggplot(mtcars, aes(x=hp, y=mpg, color=am)) + geom_point() + ggtitle(&quot;Power Against Consumption&quot;) + labs(x=&quot;Horse Power&quot;, y=&quot;Consumption (mpg)&quot;) + xlim(0, 250) + theme_bw() ## Warning: Removed 2 rows containing missing values ## (`geom_point()`). python ( ggplot(mtcars, aes(x=&#39;hp&#39;, y=&#39;mpg&#39;, color=&#39;am&#39;)) + geom_point() + ggtitle(&quot;Power Against Consumption&quot;) + labs(x=&quot;Horse Power&quot;, y=&quot;Consumption (mpg)&quot;) + xlim(0, 250) + theme_bw() ) ## &lt;Figure Size: (640 x 480)&gt; ## ## /home/romano/Documents/EpiC/.venv/lib/python3.11/site-packages/plotnine/layer.py:364: PlotnineWarning: geom_point : Removed 2 rows containing missing values. 5.2.2.1 Multiple Plots with Facets Faceting is a way to create multiple subplots at once based on an extra factor variable. This is a very clean way of representing several variables, as the subplots will share the relevant axes. For instance, let’s show the relationship between miles per gallon (mpg) and horsepower (hp), transmission type (am) but separated by the highest gear (gear): R ggplot(mtcars, aes(x=hp, y=mpg, color=am)) + geom_point() + facet_wrap(~gear) python ( ggplot(mtcars, aes(x=&#39;hp&#39;, y=&#39;mpg&#39;, color=&#39;am&#39;)) + geom_point() + facet_wrap(&#39;~gear&#39;) ) ## &lt;Figure Size: (640 x 480)&gt; On your own, try what happens by adding the argument nrow=3 to the facet_wrap, e.g. facet_wrap(~gear, nrow=3). 5.2.2.2 Few extra layers For completion, let’s see and explore some extra layers we can have. R # linegraph # great for continuous time variables ggplot(mtcars, aes(x=hp, y=disp, color=am)) + geom_line() # recall we can always filter based on any type of # variable, what we learned over the first half translates equally # to the second! And the plot adapts magically. ggplot(mtcars |&gt; filter(am == &quot;manual&quot;), aes(x=hp, y=disp)) + geom_line() # barcharts # great for categorical variables ggplot(mtcars, aes(x=cyl, fill=am)) + geom_bar() # we can store the plot in a variable and add more layers if # needed pt &lt;- ggplot(mtcars, aes(x=cyl, fill=am)) + geom_bar() pt + facet_wrap(~vs) python # linegraph # great for continuous time variables ( ggplot(mtcars, aes(x=&#39;hp&#39;, y=&#39;disp&#39;, color=&#39;am&#39;)) + geom_line() ) ## &lt;Figure Size: (640 x 480)&gt; # recall we can always filter based on any type of # variable, what we learned over the first half translates equally # to the second! And the plot adapts magically. ( ggplot(mtcars.query(&quot;am == &#39;manual&#39;&quot;), aes(x=&#39;hp&#39;, y=&#39;disp&#39;)) + geom_line() ) ## &lt;Figure Size: (640 x 480)&gt; # barcharts # great for categorical variables ( ggplot(mtcars, aes(x=&#39;cyl&#39;, fill=&#39;am&#39;)) + geom_bar() ) ## &lt;Figure Size: (640 x 480)&gt; # we can store the plot in a variable and add more layers if # needed pt = (ggplot(mtcars, aes(x=&#39;cyl&#39;, fill=&#39;am&#39;)) + geom_bar()) pt + facet_wrap(&#39;~vs&#39;) ## &lt;Figure Size: (640 x 480)&gt; 5.2.2.3 Saving and Exporting Plots You can save your plots to a file in both R and Python. To do so, you will first need to assign the plot to a variable. R g &lt;- ggplot(mtcars, aes(x=mpg, y=hp)) + geom_point() + theme_minimal() ggsave(&quot;my_plot.png&quot;, g, width=6, height=4) python g = ( ggplot(mtcars, aes(x=&#39;mpg&#39;, y=&#39;hp&#39;)) + geom_point() + theme_minimal() ) g.save(&quot;my_plot.png&quot;, width=6, height=4) ## /home/romano/Documents/EpiC/.venv/lib/python3.11/site-packages/plotnine/ggplot.py:587: PlotnineWarning: Saving 6 x 4 in image. ## /home/romano/Documents/EpiC/.venv/lib/python3.11/site-packages/plotnine/ggplot.py:588: PlotnineWarning: Filename: my_plot.png This will save the scatter plot as a PNG file named “plot.png”. You can change the filename to save it as a different type (like .jpg or .pdf) or to a different location as usual!. 5.2.3 Exercise: ggplots of periodic functions In this exercises we will be plotting few sine and cosine waves. This should combine both knowledge of creating a data frame, and ggplot. The exercise has various levels of completition, from a basic level where we will be plotting a sine function from 1 to 10, to an advance level where we will be displaying multiple periodic functions. Basic. Via ggplot, plot a sinusoidal function, \\(y = \\sin(x)\\), from 0 to 10: You want to create a sequence of numbers, x, of at least 100 values ranging from 0 to 10. You then want to run the sine function on this sequence to get the y Store the results of this operation in a data frame Plot a line using ggplot’s geom_line(). Medium. Modify the code above to add the additional function \\(y=\\cos(x)\\). You should get something like: The x-axis should range from 0 to 10, with a step size of 0.01. Use different colours for each curve (sine or cosine) How many columns should have your dataframe? Advanced. Using ggplot, write a program that generates the plot below: Each subplot should be comparing sines and cosines with different frequencies. The plot should show 6 sinusoidal functions:\\[\\sin\\left(\\frac{x}{2}\\right), \\sin(x), \\sin(2x), \\cos\\left(\\frac{x}{2}\\right), \\cos(x), \\cos(2x)\\] The plot should have three subplots, one for each frequency (\\(\\frac{1}{2}\\), 1, and 2). Each subplot should contain both the sine and cosine functions, as above Avoid computing everything by hand (e.g. copy pasting the dataframe code 6 times) or for loop. TIP: Use map to generate your dataframes and reduce to combine them. Use lambda functions where necessary. .book .book-body .page-wrapper .page-inner { max-width: 1200px !important; } "],["challenge.html", "6 Additional Programming Challenges 6.1 Part 1: Scientific Computing", " 6 Additional Programming Challenges 6.1 Part 1: Scientific Computing 6.1.1 Generic FizzBuzz Imagine R as the ‘Ugly Duckling’ of programming languages. Initially, it’s often misunderstood and overlooked by coding newbies who see it as clunky or uncool. But, thanks to the magic of the tidyverse, R has been going through a major glow-up. It’s evolving into one of the most elegant and powerful languages out there 🦢. To see this, what if I tell you that you can code the above generic_fizzbuzz of the exercise in Section 6.1.1 in a very elegant, compact way? More formally, rewrite generic_fizzbuzz respecting the following conditions: Your generic_fizzbuzz code should be under 4 statements (lines) and human readable You should not use any brackets {} You should avoid for cycles You will probably need the pipe operator |&gt; (See intro in Chapter 5.1), and another couple of purrr functions (see the cheatsheet, which you can find here). .book .book-body .page-wrapper .page-inner { max-width: 1200px !important; } "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]

---
title: "Lancaster University MATH245 Computational Mathematics"
author: "Lecturers: Dr Eduard Campillo-Funollet and Dr Gaetano Romano"
date: "2023/2024"
site: bookdown::bookdown_site
documentclass: book
output:
  #bookdown::tufte_html2:
    #toc: yes
    #self_contained: false
  #bookdown::tufte_book2:
    #toc: yes
    #includes:
      #in_header: preamble.tex
  bookdown::gitbook:
    toc_depth: 2
---

# Preface {-}

These are the R programming notes for MATH245 Computational Mathematics. They were written by.... They were based off...

Here we should have the table of content of the module?

```{r include=FALSE}
knitr::opts_chunk$set(fig.path = "images/", out.width = "50%")
```

<!--chapter:end:index.Rmd-->

# Introduction to Computational Mathematics {#intro_prog}

The boss was passing by, so they minimized the browser with the useless Instagram tab and found themselves staring at an Excel window. They had spent hours working on this spreadsheet, crunching pointless numbers and averages. They felt exhausted and bored. They looked at the grid of the spreadsheet, and felt like they were behind the bars of a prison. They wondered if this was what computing was supposed to be like.

They had loved mathematics once, and wanted to learn how to use it in creative and exciting ways. They wanted to explore new and emerging fields, such as data science, machine learning, AI, cryptography, share their code and results online. Well, too late now.

They wished that back in uni there was a course that could teach them the basics and fundamentals of programming, and show them how to use two of the most popular and powerful languages for scientific computing: R and Python.

Oh, what...

![](images/chapter1/skyrim-finally-awake.jpg){width="547"}

Welcome to MATH245, Computational Mathematics! In this course, you will learn how to use two of the most popular and powerful programming languages for scientific computing: R and Python. You will also learn a bunch of cool algorithms and how to apply them to various mathematical problems.

Why should you learn programming in mathematics? Well, there are many reasons, but few that could be of interest to you are:

1.  This is a mandatory module. You need to learn how to program to pass. Sometimes life is harsh, we know.

2.  Sometimes you will face in computing some problems that are simply too hard to solve by hand. Can't digest that integral? That ODE is beating up your little brother in school for lunch money?\
    *Well, with a computer those will not be a problem anymore.* You will learn how to perform complex and large-scale calculations and simulations that would be impossible or impractical by hand or with a calculator.

3.  Programming is the butter to the bread of these emerging fields of mathematics, such as machine learning, statistical learning, data science and artificial intelligence. Do you want to convert your grandma into a robot? Gottcha, you'll need to know what a neural network is. And likely what stochastic gradient descent is, we will cover that. *Oh, and you need to know how to program.*

4.  Oh, nice Bayesian nested model you got here. It would be a shame if there was not a closed form... What? Your data set has three-thousand features? Well, *modern statistics is done behind a computer.*

In short, programming can make mathematics more fun, more useful, and more relevant to the modern world. As a mathematician in the 21st century, you need to be able to work with a computer and use it as a tool for discovery and innovation.

And well, don't worry if you have no prior knowledge of programming. We will start from the basics, like really the basics basics, as you can see from the next section header. We will then guide you through the fundamentals and concepts of programming, and then will follow through the basics of Computational Mathematics and Algorithms. We will also give you plenty of examples and exercises to practice and test your skills. By the end of this course, you will be able to write and run your own code in both R and Python, which are two of the most popular programming languages for scientific computing, and learn very useful algorithms that you will apply to various mathematical problems.

## What is a Computer?

Few years ago Apple came up with yet another iPad. And with that, another one of their ads. In one specifically, a kid would do a bunch of things with an iPad pro, like working on Word, reading comics or drawing silly things. Then, at the end, a peeping neighbor, perhaps too curious, would ask them: *"Wattcha doing on your computer?"*. To which the kid, holding the iPad, replies: *"What's a computer?"*. Here, look for yourself:

<iframe width="560" height="315" src="https://www.youtube.com/embed/3S5BLs51yDQ?si=7SZjrvf_ojbtjYx7" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen>

</iframe>

Well, you silly! Your iPad is a computer. So it's your smartphone. And your smartwatch, probably your TV, your Fridge and your car - if you have a fancy electric car. We're living in a world of computers.

There are many kinds of computers, but you have probably interacted mostly with smartphones and desktop or laptop computers. As a student of in this module, you will likely use a desktop (the university machine) or your own laptop for programming. Theoretically, however, you can also program on other devices, such as tablets (or smartwatches, even!), obviously with some caveats and limitations.\
Also, computers will have different architectures, such as x86, ARM, or RISC-V, that determine how they processes the instructions and data. You might not know it, but your laptop could have a mobile processor, like the such as Snapdragon, Exynos, or Apple M-series. **This could impact your learning experience in this module, so, if you are not familiar with the concept above stick to the university machines.**

More formally, a computer is a device that can perform calculations and manipulate data, all by following a set of instructions known as a program. It has the ability to process a variety of data types, including numbers, text, images, sound, and video, and can produce a range of outputs. This could be anything from displaying information on a screen, playing audio, or transmitting information over the internet (which, in its simplest form, is just two computers exchanging text).

Let's delve a bit deeper into the main components of a computer:

1.  **Central Processing Unit (CPU)**: Often referred to as the 'brain' of the computer, the CPU is responsible for executing the program's instructions.

2.  **Memory**: This is the computer's short-term memory, sometimes known as **RAM (Random Access Memory)**. It stores the data that the CPU needs to access quickly and frequently. RAM is volatile, which means that its contents are lost when the computer is turned off or restarted.

3.  **Storage**: This is the computer's long-term memory. It holds data that isn't required immediately or frequently by the CPU. This could include the program itself or files created by the user. Hard drives are non-volatile, meaning their contents persist even when the computer is turned off.

To illustrate how these components interact, let's consider what happens when you run a program e.g. a series of instruction that make sense to your CPU:

![](images/chapter1/architecture.png){width="522"}

Say that your program and your data are saved on your hard drive (a type of storage). The program, along with any necessary data, is then loaded from the hard drive into the memory. This allows the CPU to access it. The CPU then carries out the program's instructions, performing calculations and operations on the data stored in the memory. The results of these operations remain in the memory and can be displayed on the screen, saved back to the hard drive, or sent to another device. This process highlights the integral role each component plays in the functioning of a computer.

### Computer Programs and Programming Languages

We have mentioned a program earlier, but what is a program? A program is a sequence of instructions that tells the computer what to do. A program can be written in different ways, depending on the level of abstraction and the intended audience. For example, a program can be written in natural language, such as English, or in a formal language, such as mathematics. However, the computer cannot understand these languages directly. It can only understand a very low-level language, called machine code, which consists of binary digits (0s and 1s) that represent the basic operations of the CPU. We call this set of binary instructions **a computer program**.

![](images/chapter1/chad_pc.png){width="630"}

Therefore, to make the computer execute a program, we need to translate it from a higher-level language to a lower-level language. This is where programming languages come in. A programming language is a formal language that defines the syntax and semantics of a program. A programming language allows us to write programs in a more human-readable and expressive way, and then, as an interpreter, translate them to machine code that the computer can understand and execute.

There are many programming languages, and they have different features and purposes. Some programming languages are designed for specific domains or tasks, such as web development, data analysis, or game design, whilst others are more general-purpose and can be used for a variety of applications.

In this course, we will focus on two of the most popular and versatile programming languages for scientific computing: R and Python. Both of these languages are high-level, interpreted, and general-purpose languages:

-   **High-level** means that the programming language is closer to natural language and more abstracted from the details of the machine code. This makes the language easier to read, write, and understand, but also requires more translation and processing by the interpreter or the compiler. But don't worry about this... Fortunately most of the heavy lifting is done by the compiler, which is the interpreter that converts the code from human readable to machine readable.

-   **Interpreted** means that the programming language does not need to be compiled before execution, but rather is translated and executed line by line by a program called an interpreter. This allows the language to be more dynamic and flexible, but also slower and less efficient than compiled languages. One of the advantages of interpreted languages is that you can execute commands **directly in the console**, in addition to writing and saving these in a script. This is useful for testing and debugging your code, or for performing quick calculations and operations.

-   **General-purpose** means that the programming language can be used for a variety of applications and domains, and is not limited to a specific purpose or task. This makes the language more versatile and adaptable, but also less specialized and optimized than domain-specific languages. General-purpose languages can be used for web development, video game engineering, automation, and... Scientific computing, among other things.

### R and Python

Well, finally it's time to introduce our two friends. And as with any good introduction, we give a bit of history.

**R** is a language and environment for statistical computing and graphics. It was created by Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand, in 1993. It is based on the S language, which was developed at Bell Laboratories by John Chambers and others in the 1970s. R is free and open source, and has a large and active community of users and developers. R is especially popular among statisticians, data scientists, and researchers in various fields.

**Python** is a high-level, interpreted, general-purpose programming language. It was created by Max Verstappen in the Netherlands 5 years ago. Nah, just kidding... It was made though in the Netherlands in 1991 by Guido van Rossum, at Centrum Wiskunde & Informatica (CWI). It is named after the comedy group Monty Python, and has a philosophy of simplicity, readability, and elegance. Python is also free and open source, and has a huge and diverse community of users and developers. Python is widely used for a variety of tasks and it's getting more and more popular in statistics and for scientific computing.

Both R and Python have many advantages and features that make them suitable for mathematical applications, such as:

-   They are easy to learn and use, with clear and consistent syntax and semantics. They allow you to write concise and elegant code that can handle complex problems, without getting too lost in complicated syntax (have a look at some C or Fortran code for instance).

-   They are extensible and modular, supporting multiple paradigms and styles of programming, such as functional, object-oriented, and procedural. For this course, we will be focusing on **functional programming.** This will come later, as it's the a way of programming that is really close with mathematics.

-   They have rich and comprehensive libraries and packages that provide a wide range of functions and tools for various domains and tasks, such as linear algebra, optimization, machine learning, visualization, and web scraping.

-   They have interactive and user-friendly environments and interfaces that facilitate development and debugging, such as the console, the editor, and the notebook. We will be using, for this module **R studio.**

## Computing, Accessing Memory and Storing

We covered the three components of the computer: the CPU, the memory and the storage. Well, a programming language is a powerful tool that allows to build a set of instructions that use all these three components. By the end of this chapter, we won't be able to write a full program yet, but hopefully we will show how these three interact.

Before we proceed, a quick rundown on how to read the lines of code in these notes. Every once in a while you will see a chunk of code, and sometimes a result of what the chunk of code does. For example:

```{r}
# Hi, I am a chunk of R code that prints to output "Beep bop beep"
print("Beep bop beep")
```

As the comment (that bit in gray that starts with the `#)`, suggests, what you saw is a chunk of R code that *prints to output* the text "Beep bop beep". On top you will find the code, and on the bottom the result, *i.e.* the output. The comment does not get executed, so it's just an explanation of what you are seeing. The actual code statement, `print("Beep bop beep")`, is the one that does all the job, and, as the comments sugests, prints the text "Beep bop beep".

*Wait, but I thought we would have learned Python in this module?* Well, patience, my dear friend (btw, we are not friends). The python equivalent of that statement would be:

```{python}
# Hi, I am a chunk of Python code that prints to output "Beep bop beep"
print("Beep bop beep")
```

Wait, they're basically the same? Well, yes, that's the point, and the reason why we teach them both simultaneously. Despite the culture war that there's currently in Statistics and Data Science, we believe that there's no such thing as a best programming language: **the expert worker should use all tools available at this hand**. R and Python, for scientific computing, are almost equivalent at this day, and given recent developments, **they can work together**. For your project you will have to pick either one, or the other, but if you are confident enough, feel to learn both, you're more then welcome.

As a matter of fact, for all the these notes, we will always try to have them both side to side.\
**On the left you will always an R code chunk, and on the right you will find the Python equivalent:**

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
print("R chunk on the left.")
```

</div>

<div>

**python**

```{python}
print("Python chunk on the right.")
```

</div>
:::

If for formatting reasons we won't be able to show the code side to side, you can always tell which is which by the bold text immediately above the chunk, e.g. **R** or **python**.

Anyway, how did we made such a fancy set of lecture notes? Through **Rmarkdown** using **Rstudio**. Don't worry, we will learn about these two tools later. Another cool thing you can do with a computer.

### A glorified calculator

That's it, the CPU. End of the Section. The CPU is a glorified calculator, nothing more to it, even if sometimes you might have heard complex codes and names like i7, i5, A4, Pentium 5, Neural Pre-processor, Snapdragon, Qbits, SmartBpprop, Bombastic, Mr fantastic, etc. Anyway, let us not worry about this now, but open up the console. Either the R or Python one. And copy and paste the following code snippets into it. Then, press enter, you will see the result. What's going to happen under the hood once you are sending a command to R or Python, is that process I mentioned earlier. The interpreter, will convert your command into machine code, and pass it down to the processor. The processor is going to crunch the numbers, and send back an output, that will then be displayed on your screen. 

This is how we do additions:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
3 + 5
```

</div>

<div>

**python**

```{python}
3 + 5
```

</div>
:::

The result is automatically printed back to the user. Now, this is how we do subtractions:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
3 - 5
```

</div>

<div>

**python**

```{python}
3 - 5
```

</div>
:::

And this is how we do additions and subtractions, and multiplications, and algebra in general:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
3 + 5 * 2
```

</div>

<div>

**python**

```{python}
3 + 5 * 2
```

</div>
:::

The order of the operations comes from algebra, so in that snippet, we will first have `5 * 2`, that gives us `10`, and then we will do `3 + 10`. Of course we can do much more then simple additions of subtractions and multiplications. Here I have a list of basic operations we can do with both the languages. Note that the syntax will not always be the same:

| Operation    | R Example     | Python Example           |
|--------------|---------------|--------------------------|
| Add          | `2 + 3`       | `2 + 3`                  |
| Subtract     | `2 - 3`       | `2 - 3`                  |
| Multiply     | `2 * 3`       | `2 * 3`                  |
| Divide       | `2 / 3`       | `2 / 3`                  |
| Modulus      | `2 %% 3`      | `2 % 3`                  |
| Square root  | `sqrt(2)`     | `math.sqrt(2)`           |
| Power        | `2^3`         | `2 ** 3`                 |
| Cosine       | `cos(2 * pi)` | `math.cos(2 * math.pi)`  |
| Sine         | `sin(pi / 2)` | `math.sin(math.pi / 2)`  |
| Tangent      | `tan(pi / 4)` | `math.tan(math.pi / 4)`  |
| Natural log  | `log(2)`      | `math.log(2)`            |
| Expontential | `exp(2)`      | `math.exp(2)`            |

Please note that in Python, you need to import the `math` module to use mathematical functions like `sqrt`, `cos`, `sin`, `tan`, `log`, and `exp`. Also, `pi` is accessed as `math.pi` in Python.
At the start of your **python** script, just add the following:

**Python**
```{python}
import math
```
Don't worry too much about this for now.

#### Exercise

Using numbers of your own, try the other basic mathematical operations listed below. Split a £10 bill across 3 people, check if 91 is a prime number using the modulus with the first 5 primes or get the Euler number. Play around, be wild.

#### Putting an order to operations

Once you're happy, try stringing some of these calculations all into one command, for example:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
3 + 7 * 5 / 3 - 2
(3 + 7) * 5 / (3 - 2)
```

</div>

<div>

**Python**

```{python}
3 + 7 * 5 / 3 - 2
(3 + 7) * 5 / (3 - 2)
```

</div>
:::

The multiplication and division calculations are performed first (`*` and `/`), followed by addition and subtraction (`+` and `-`), going from left to right.

You may remember this from School as BODMAS: Brackets, Orders (powers, square roots), Division, Multiplication, Addition, Subtraction

This can be overridden by using putting the calculations we want to perform first in brackets. For instance, there's this formula that has been really bothering me. It popped up this morning at 4am, and kept me awake. What is the square root of three fourth, over a third minus 2 divided by pi square? A hunted seagull of chalk flying around the vast sea of obsidian that is the blackboard of my mind, over and over and over again: 
$$
\frac{\sqrt{3/4}}{\frac{1}{3} - \frac{2}{\pi^2}}.
$$ 
Here you go, be free, little bird:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
sqrt(3 / 4) / (1 / 3 - 2 / pi^2)
```

</div>

<div>

**Python**

```{python}
math.sqrt(3 / 4) / (1 / 3 - 2 / math.pi**2)
```

</div>
:::

### What if calculators could remember?

Yeah, what if? Well, that's what the memory is for, keeping things in mind. You can think of the memory as a bookshelf, filled with boxes. Or if you're one fan of that Henry Popper, the Magician Kid of Hogtwarz, (I do not wish to pay for the rights to Warner Bros) it's like that room filled with shelves and bottles of thoughts and spells. Yes, that's a better image. So the CPU is the Ministerium of Evil Magicians can access each shelf whenever it feels or needs. Now, in a computer, of course, instead of bottles, you have areas of the memory, and instead of spells, you have numbers, or vectors, or strings (text, e.g. a series of characters).

Now, the Ministerium, to access the spells and the thoughts in the bottles, has a bunch of Evil Magicians, that walk in the archive, and that can claim these bottles by putting labels onto them. Those magicians are, in the computer, our programs. Putting a label on an area of memory is called *creating a variable.*

Tere's the thing: when a magician grabs a bottle, they can either look at which thought or spell is in it, or put a new thought into it. An existing thought in a bottle cannot be modified. If they wish to keep the same bottle with the same label, but change the content, they open it, get rid of the old content, and simply put a new one.

To give an example, Prof. Sinsinius Snap, to kill that guy that kinda of looks like Gandalf, needs to store two spells. In one he needs to store the formula of the spell that causes the victim to feel a lot of pain (this was in a children book, by the way), and in the other, the formula that makes the heart's victim stop. To do so, it cretes two labels, *spell_to_torture* and *spell_to_kill,* so it won't loose the bottles in the archive,and in each it puts the evil spell:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
spell_to_torture <- "porcosus"
spell_to_kill <- "avada kebaba"
```

</div>

<div>

**python**

```{python}
spell_to_torture = "porcosus"
spell_to_kill = "avada kebaba"
```

</div>
:::

What did we do? We assigned two strings, `"porcosus"` and `"avada kebaba"`, indicative of our spells, in two variables, called `spell_to_torture` and `spell_to_kill` (the labels). You can read the code above as *assign "porcosus" to spell_to_torture, and assign "avada kebaba" to spell_to_kill*. This can be done with the `<-` sign in R and with the `=` sign in Python. What we did reserved an area of memory where now our two strings are stored and are accessible to our program.

Our dear Prof. Sinsinius Snap, to access the spells again, all he needs to do, is to recall the labels he used, e.g. the variable names, and the archive will remind him of the content of the bottles:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
spell_to_torture
spell_to_kill
```

</div>

<div>

**python**

```{python}
spell_to_torture
spell_to_kill
```

</div>
:::

Ouch! He realizes he putted the wrong spell in the `spell_to_torture` bottle. Well, no problem, as mentioned above, he can re-bottle the correct one. To do so, he simply reassigns the correct spell `"cruccio"` to the bottle labelled `spell_to_torture`:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
spell_to_torture <- "cruccio"
```

</div>

<div>

**python**

```{python}
spell_to_torture = "cruccio"
```

</div>
:::

Note that now, the old spell `"porcosus"` is lost. In fact, when he looks at the `spell_to_torture` bottle, he sees:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
spell_to_torture
```

</div>

<div>

**python**

```{python}
spell_to_torture
```

</div>
:::

"Well done Sinsinius!" he says, patting himself on the shoulder.

#### Doing maths with variables

Now of course, this is a university, not a school of magic and divination, so we ultimately need to do some maths.
In programming, we often need to store the results of our calculations for later use. This is where variables come in handy. We mentioned you can think of a variable as a bottle where you can store a value. You can give this bottle a label (a name), and use this label to refer to the bottled value later on.

For example, let's say we want to perform some calculations:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
x  <- 20 - 16
y <- 4 + 5
x - y
```

</div>

<div>

**Python**

```{python}
x  = 20 - 16
y = 4 + 5
x - y
```

</div>
:::

Here, `x` and `y` are variables. We've assigned them the results of some calculations. Now, whenever we refer to `x` or `y`, we're actually referring to the results of these calculations.

We can check the values stored in `x` and `y` by simply typing their names:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
x
y
```

</div>

<div>

**Python**

```{python}
x
y
```

</div>
:::

Remember, R and Python are case-sensitive, so `x` is different from `X`. If you try to access `X`, you'll get an error because we haven't assigned anything to `X`:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r error=TRUE}
X
```

</div>

<div>

**Python**

```{python error=TRUE}
X
```

</div>
:::

Also, if you assign a new value to a variable, the old value will be overwritten without any warning:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
x <- -100
x
```

</div>

<div>

**Python**

```{python}
x = -100
x
```

</div>
:::

Now, here's something cool. In maths, an equation like $x = x + 1$ doesn't make much sense. But in programming, it's perfectly valid. It means "take the current value of `x`, add 1 to it, and store the result back in `x`". This is a common way to increment a variable:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
x <- x + 1
x
```

</div>

<div>

**Python**

```{python}
x = x + 1
x
```

</div>
:::

In fact, you can use all mathematical operations in this way. You should use variables as much as you can to keep the code as clean and readable as possible. Let's revisit the example above:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
numerator <- sqrt(3 / 4)
denominator <- (1 / 3 - 2 / pi^2)
result <- numerator / denominator
result
```

</div>

<div>

**Python**

```{python}
numerator = math.sqrt(3 / 4)
denominator = (1 / 3 - 2 / math.pi**2)
result = numerator / denominator
result
```

</div>
:::

In this refactored code, we first calculate the numerator and the denominator separately and store them in variables. Then, we perform the division operation and store the result in another variable. This makes the code easier to read and understand. It also allows us to reuse the `numerator` and `denominator` calculations if needed elsewhere in the code. This is a good practice in programming. It not only makes the code cleaner but also more efficient.

### Storing Data on the Hard Drive

When you're working with a programming language like R or Python, any variables you create are stored in your computer's memory (the RAM). This is a type of storage that's fast and easy for your computer to access, which is why it's used for tasks that are currently running. However, memory is volatile, which means that once the power is turned off or your program finishes running, any data stored in memory is lost.

Sometimes, you might want your program to produce something tangible that doesn't get lost when the power is turned off or your program stops running. This could be a report, a graph, or even just a set of numbers. To do this, you can write this data to a file on your hard drive. Unlike memory, data stored on your hard drive remains there until it's deleted, so you can access it again later.

Let's look at how you can write data to a file in R and Python.

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Create some data
data <- c(1, 2, 3, 4, 5)

# Write the data to a file
write.csv(data, file = "data.csv")
```

</div>

<div>

**Python**

```{python}
# Import the pandas library
import pandas as pd

# Create some data
data = [1, 2, 3, 4, 5]

# Convert the data to a DataFrame
df = pd.DataFrame(data)

# Write the data to a file
df.to_csv("data.csv", index=False)
```

</div>
:::

In both of these examples, we're creating a set of data (the numbers 1 through 5), and then writing this data to a file called "data.csv". The `write.csv` function in R and the `to_csv` function in Python are used to write the data to a file.

In R, when you see `c(1, 2, 3)`, we're making a vector. As in maths, this is a collection of numbers that you’ve bundled together in a specific order: first 1, then 2, then 3.
In Python, when you see `[1, 2, 3]`, it’s very similar. This in python is called a list.

We’ll learn more about these collections (vectors in R and lists in Python) **next week**. For now, just remember that they are a way to keep your items organized and in a specific order. It’s like having a container where you can keep your things neatly instead of having them scattered all over the place. This makes it easier to find what you need later on. Moreover, in the Python example, you might have noticed the `pd.DataFrame` statement. This is a way to create a DataFrame, which is a kind of table, using the pandas library. Again, don't worry! We'll cover these topics in more detail later on. For now, just know that we're using a DataFrame to store our data in a structured way that can be easily written to a file.

Now, let's talk about CSV files. CSV stands for "Comma-Separated Values". It's a simple file format used to store tabular data, such as a spreadsheet or database. Each line of the file is a data record, and each record consists of one or more fields, separated by commas. This is why it's called a "comma-separated values" file.

When we write our data to a CSV file, each item of data goes into its own field, and each set of data (like a row from a table) goes into its own record. This makes CSV files a great way to store tabular data, because it's easy to input the data into a spreadsheet or database program later on.

I encourage you to open the "data.csv" file we created in a text editor or spreadsheet program. You'll see that the data is stored in a structured, easy-to-read format. Each number is in its own field, and each set of numbers is in its own record.

Remember, storing data on your hard drive is a great way to preserve your data for later use. It's also a great way to share your data with others, or to move your data between different programs. So don't be afraid to use file input and output in your own programs. It's a powerful tool that can help you do more with your data.

#### Reading back your data
Now, let's say we want to access this data at a later time. We can do this by reading the file back into our program. Here's how you can do it in R and Python:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Read the data from the file
data_from_file <- read.csv("data.csv")

# Print the data
print(data_from_file)
```

</div>

<div>

**Python**

```{python}
# Read the data from the file
data_from_file = pd.read_csv("data.csv")

# Print the data
print(data_from_file)
```

</div>
:::

In both of these examples, we're using the `read.csv` function in R and the `read_csv` function in Python to read the data from the file back into our program. When we print this data, we can see that it's the same as the data we originally wrote to the file.

This is a basic introduction to storing data on your hard drive using R and Python. There's a lot more you can do with file input and output, but this should give you a good starting point. Remember, the key is to use variables to store your data in memory while your program is running, and then write this data to a file on your hard drive if you want to keep it for later.

<style type="text/css">
.book .book-body .page-wrapper .page-inner {
  max-width: 1200px !important;
}
</style>

<!--chapter:end:01-week1.Rmd-->

---
editor_options: 
  markdown: 
    wrap: 72
---

# Logic and Vectors {#log_vec}

In this chapter, we will introduce you to the basics of logic in a
computer. Computer Logic is related in its own way to the branch of
mathematical logic, in particular with the branch of Boolean algebra.
And if truth is something elusive in the philosophical discourse, in
Boolean algebra it is well defined, as the $\land, \ \lor, \lnot$ logic
operators are. If you're used to these, for the rest of this chapter, we
will use a different notation for these three symbols: `AND`, `OR` and
`NOT`.

In programming, logic is essential, as it allows us to create and
manipulate expressions and statements that can be evaluated as true or
false. In this way logic enables us to control the flow and structure of
our programs, and to perform various operations and calculations on
data.

## Comparisons

Before we start with the logic, we should cover what *comparison* is. I
mean, we can again phylosofize about it, but pulling out the Oxford
English Dictionary, "[Comparison is ] the action, or an act, of
comparing, likening, or representing as similar: see compare." If we
pull out the definition of *compare,* we simply get "To liken". The
concept of comparison is inherit in human existence, as it's the concept
of what `TRUE` is, (Kierkegaard lost his mind to find out that there's
not a way that two things are the same, that truth is subjective, and
that please do not compare people, that is not nice).

![](images/chapter2/kier.jpeg){width="495"}

Anyway, in programming, comparison is the process of examining two or
more objects or values and determining their relationship or difference.
Comparison can be used for various purposes, such as checking the
validity of an input, showing that two variables contain the same item,
or most importantly to control the flow of a program (later with this).
For now, let's focus on how to compare objects and values in both R and
Python, and how to use the results of comparison in your programs.

First, let's see how to check for equality in R and Python. Equality
means that two objects or values are exactly the same in every aspect.
To check for equality, we use the operator `==`, which returns `TRUE` if
the objects or values are equal, and `FALSE` if they are not. As you
will see, R uses uppercase letters for `TRUE` and `FALSE`, while
Python uses lowercase letters for `True` and `False`.

For example, we can compare two strings, two integers, or two doubles,
as shown below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Comparing two strings
"Hello" == "Hello"

"Hello" == "hello"


# Comparing two integers
2 == 2

2 == 3


# Comparing two doubles
3.14 == 3.14

3.14 == 3.1415

```

</div>

<div>

**python**

```{python}
# Comparing two strings
"Hello" == "Hello"

"Hello" == "hello"


# Comparing two integers
2 == 2

2 == 3


# Comparing two doubles
3.14 == 3.14

3.14 == 3.1415

```

</div>
:::

From these examples, we can notice how the computer is, indeed, very
strict with the definition of *equality.* Two things might seem similar,
or likely to be the same, but they are not.

Note that the comparison is case-sensitive, meaning that uppercase and
lowercase letters are considered different. Also note that the
comparison is precise, meaning that even a small difference in the
decimal places can make two doubles unequal. Try adding more decimals to
the above examples, and see how far you can get until you get two same
numbers! The amount of decimal places in doubles *is at the basis of
precision* and how comparisons of doubles are made will affect your
programs. For this reason **be careful when you compare two floats** and
try to avoid equality.

Similar to equality, we can check for inequality. Inequality means that
two objects or values are not exactly the same in every aspect. To check
for inequality, we use the operator `!=`, which returns `TRUE` if the
objects or values are not equal, and `FALSE` if they are. As earlier:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Comparing two strings
"Hello" != "Hello"

"Hello" != "hello"


# Comparing two integers
2 != 2

2 != 3


# Comparing two doubles
3.14 != 3.14

3.14 != 3.1415

```

</div>

<div>

**python**

```{python}
# Comparing two strings
"Hello" != "Hello"

"Hello" != "hello"


# Comparing two integers
2 != 2

2 != 3


# Comparing two doubles
3.14 != 3.14

3.14 != 3.1415

```

</div>
:::

As mentioned above, we can also compare the content of variables. As we
learned last week, a variable is a name that refers to a value or an
object that is stored in the memory, so by comparing variables we
compare the value they refer to. For example, we can assign the string
`"Hello"` to the variable `x` in both languages, as shown below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Assigning a string to a variable
x <- "Hello"
```

</div>

<div>

**python**

```{python}
# Assigning a string to a variable
x = "Hello"
```

</div>
:::

And we can then use the same operators as before, `==` for equality and
`!=` for inequality. For example, we can compare the variable `x` with
another string, another variable, or itself, as shown below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Comparing a variable with a string
x == "Hello"

x == "hello"


# Comparing a variable with another variable
y <- "World"
x == y

y <- "Hello"
x == y


# Comparing a variable with itself
x == x

```

</div>

<div>

**python**

```{python}
# Comparing a variable with a string
x == "Hello"

x == "hello"


# Comparing a variable with another variable
y = "World"
x == y

y = "Hello"
x == y


# Comparing a variable with itself
x == x

```

</div>
:::

In addition to equality and inequality, we can also compare the
magnitude or the order of two values or objects. This is especially
useful in computational maths, as we often need to check if a value is
within a certain range, or if a value satisfies a certain condition. To
compare the magnitude or the order of two values or objects, we use the
following operators:

-   Greater than (`>`): This operator returns `TRUE` if the left operand
    is larger than the right operand, and `FALSE` otherwise. For
    example, `3 > 2` returns `TRUE`, but `2 > 3` returns `FALSE`.
-   Less than (`<`): This operator returns `TRUE` if the left operand is
    smaller than the right operand, and `FALSE` otherwise.
-   Greater than or equal to (`>=`): This operator returns `TRUE` if the
    left operand is larger than or equal to the right operand, and
    `FALSE` otherwise. For example, `3 >= 2` and `3 >= 3` both return
    `TRUE`, but `2 >= 3` returns `FALSE`.
-   Less than or equal to (`<=`): As above, this operator returns `TRUE`
    if the left operand is smaller than or equal to the right operand,
    and `FALSE` otherwise.

The comparison is going to be consistent with the equality and
inequality operators, meaning that if `x == y`, then `x >= y` and
`x <= y` are both `TRUE`, and if `x != y`, then either `x > y` or
`x < y` is `TRUE`.

As an exercise, try to compare two integers, two doubles, or two
variables, as done above, but with the inequality operators, and see the
result.

In the next section, we will introduce you to another important aspect
of logic: logical arithmetic. Logical arithmetic is the process of
combining and manipulating logical values, such as `TRUE` and `FALSE`,
using logical operators, such as `AND` and `OR`. Logical arithmetic can
be used for various purposes, such as creating complex conditions,
testing multiple hypotheses, or performing set operations. In this
section, we will show you how to use logical arithmetic in both R and
Python, and how to use the results of logical arithmetic in your
programs.

## Logical Arithmetic

This might seem easy if you already have a background in logic, but even
if you haven't, the following paragraphs should cover all the necessary
concepts that you will need for programming.

Logical arithmetic is the process of combining and manipulating logical
values, `TRUE` and `FALSE`, which are *logic operands*, using the
*logical operators* `AND` and `OR` or `NOT`.

Let's start from `AND` and `OR`:

-   The `AND` operator returns `TRUE` if both operands are `TRUE`, and
    `FALSE` otherwise.

-   The `OR` operator returns `TRUE` if either or both operands are
    `TRUE`, and `FALSE` otherwise.

We can use the `AND` and `OR` operators to combine two logical values,
such as `TRUE` and `FALSE`, as shown below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Using the AND operator
TRUE & TRUE

TRUE & FALSE

FALSE & TRUE

FALSE & FALSE


# Using the OR operator
TRUE | TRUE

TRUE | FALSE

FALSE | TRUE

FALSE | FALSE

```

</div>

<div>

**python**

```{python}
# Using the AND operator
True and True

True and False

False and True

False and False


# Using the OR operator
True or True

True or False

False or True

False or False

```

</div>
:::

The syntax and the output are very similar in both languages, except that R uses `&` and `|` for `AND` and `OR`, while
Python uses `and` and `or`. More formally, we can use a table to show
all the possible outcomes of the `AND` and `OR` operators. Let's say
that $a, \ b$ are our operands, then:

| $a$   | $b$   | $a$ AND $b$ | $a$ OR $b$ |
|-------|-------|-------------|------------|
| TRUE  | TRUE  | TRUE        | TRUE       |
| TRUE  | FALSE | FALSE       | TRUE       |
| FALSE | TRUE  | FALSE       | TRUE       |
| FALSE | FALSE | FALSE       | FALSE      |

The table has four rows, corresponding to the four
possible combinations of the operands a and b. Again, the table is easy
to build, as it shows a AND b is only TRUE when both a and b are TRUE, a
OR b is only FALSE when both a and b are FALSE.

### Precendence of operators

In logical operations, as in general algebra, the precedence of
operators determines the order in which operations are performed:

1.  **Logical NOT**: This operator has the highest precedence and is
    performed first¹⁴.
2.  **Logical AND**: This operator has the next highest precedence after
    Logical NOT¹⁵.
3.  **Logical OR**: This operator has lower precedence than Logical
    AND¹⁵.

So, in an expression without parentheses, the NOT operation is performed
first, followed by the AND operation, and finally the OR operation.

For example, in the expression `NOT p AND q AND r`, the operations would
be performed in the following order:

1.  `NOT p` is performed first due to the highest precedence of `NOT`.
2.  Then, `(NOTp) AND q` is performed due to the next highest precedence
    of `AND`.
3.  Finally, `((NOT p) AND q) OR r` is performed due to the lowest
    precedence of `OR`.

Parentheses can be used to change this order. For example, in the
expression `p ∧ (q ∨ r)`, the operation `q ∨ r` is performed first due
to the parentheses, even though `∨` has lower precedence than `∧`.

For example, consider the following expression:

`TRUE | TRUE & FALSE`

Without parentheses, in this expression the `AND` operator has higher
precedence than the `OR` operator, so it is evaluated first. The result
is then combined with the `OR` operator. The expression is equivalent
to:

`TRUE | (TRUE & FALSE)`

However, if we use parentheses to group the operands differently, we can
change the order of evaluation and the result of the expression. If we
use parentheses to group the first and the last operands, we get:

`(TRUE | TRUE) & FALSE`

The value of this expression is in fact `FALSE`. Now, the `OR` operator
is evaluated first, giving `TRUE` and the result is then combined with
the `AND` operator, giving `FALSE`.

#### Exercise

To test your understanding of logical arithmetic, try to find what is
the value of:

-   `TRUE | TRUE & FALSE`?
-   `FALSE | FALSE & TRUE`?
-   `(TRUE & FALSE) | (FALSE & TRUE)`?
-   `(TRUE | TRUE) & FALSE`?
-   `(TRUE | FALSE) & (FALSE | TRUE)`?

You should use the console in R or Python to check your answers. You can
review the table and the examples above, and try to understand the logic
behind each expression.

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Checking the answers
TRUE | TRUE & FALSE
FALSE | FALSE & TRUE
(TRUE & FALSE) | (FALSE & TRUE)
(TRUE | TRUE) & FALSE
(TRUE | FALSE) & (FALSE | TRUE)
```

</div>

<div>

**python**

```{python}
# Checking the answers
True and False or True
False or False and True
(True and False) or (False and True)
True and (False or True)
(True or False) and (False or True)
```

</div>
:::

## Flow

Another important aspect of logic is flow. Flow is the order and
direction in which the instructions of a program are executed **and is
at the base of an algorithm**.

Normally, a computer program, has a start, it will do something, and
then terminate (return an output). This is called the *flow* of a
program. Now, of course, to control the flow, you need a mechanism that
checks on the state of your program, and performs an action based on the
state in which you are. Surprisingly enough, we run programs in every
day tasks too. When driving down from Glasgow to London, we need to
check where we are, and turn the steering wheel accordingly in such a
way that our car points towards South. When doing the laundry in a
laundrette, we first check the amounts of money we have, and then, if we
have enough, load up the washing machine, if we don't, well, we need to
get some more. Or say, for example, that you need to code something,
maybe for an assignment :) What you might end up doing, is the
following:

![](images/chapter2/code_something.png)

**I have to remark that this was a joke:** remember that if you cheat at
this stage with programming you are just cheating yourself.

More formally, in computer programs, flow can be controlled by using
*conditional statements*, such as if - else if - else. Conditional
statements allow us to execute different blocks of code depending on the
result of a logical expression or condition. For example, we can use
conditional statements to perform different actions based on the value
of a variable, the input of the user, or the outcome of a calculation.

### The if-then-else statement

The simplest form of a conditional statement is the if statement. The if
statement checks a single condition, and executes a block of code if the
condition is true. For example, we can use an if statement to print a
message if a variable is positive, as shown below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Assigning a value to a variable
x <- 10

# Using an if statement
if (x > 0) {
  print("x is positive")
}
# x is positive
```

</div>

<div>

**python**

```{python}
# Assigning a value to a variable
x = 10

# Using an if statement
if x > 0:
  print("x is positive")
# x is positive
```

</div>
:::

Concerning syntax, e.g. the way we write the code:

-   To enclose the condition that is checked by the if statement, e.g.
    where your logic expression goes (e.g. the block of code that
    evaluates either to `TRUE` or `FALSE):`

    -   R uses an `if` followed by parentheses `()`, where the condition
        goes

    -   Python has no parentheses, but has a `:` symbol to indicate that
        the condition has ended and the block of code to execute has
        started

-   To denote the block of code to execute if the condition is true:

    -   R uses curly braces `{}` to enclose the block of code that is
        executed if the condition is true. All code that is relative to
        the if condition needs to be within these brackets

    -   Python, uses indentation to delimit the block of execution. All
        code that needs to execute needs to be indented at the same
        level. Indentation in Python is achieved either with a tab
        (recommended), or with 4 spaces.

The if statement only executes the block of code if the
condition is true, and does nothing otherwise. This means, that if the
condition is `FALSE`, the program will simply skip the code within the
block, as if it never existed.

Sometimes, we may want to check more than one condition, and execute
different blocks of code for each condition. For this, we can use the
if - else if - else statement. The if - else if - else statement checks
multiple conditions in order, and executes the first block of code that
corresponds to a true condition. If none of the conditions are true, the
else block of code is executed. For example, we can use an if - else
if - else statement to print a message based on the sign of a variable,
as shown below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Assigning a value to a variable
x <- 10

# Using an if - else if - else statement
if (x < 0) {
  print("x is negative")
} else if (x == 0) {
  print("x is zero")
} else {
  print("x is positive")
}
# x is positive
```

</div>

<div>

**python**

```{python}
# Assigning a value to a variable
x = 10

# Using an if - else if - else statement
if x < 0:
  print("x is negative")
elif x == 0:
  print("x is zero")
else:
  print("x is positive")
# x is positive
```

</div>
:::

Concerning syntax, R uses `else if` and Python uses `elif` for the second
condition. The order of the conditions is important, as only
the first condition that is true is executed. If none of the conditions
are true, the else block is executed.

Sometimes, we may want to check two or more independent conditions, and
execute different blocks of code for each condition. For this, we can
use two or more if statements one after another. This is different from
using an if - else if - else statement, as each if statement is
evaluated separately, and more than one block of code can be executed.
For example, we can use two if statements to print a message based on
the divisibility of a variable by 2 and 3, as shown below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Assigning a value to a variable
n <- 12

# Using two if statements
if (n %% 2 == 0) {
  print("n is divisible by 2")
}
if (n %% 3 == 0) {
  print("n is divisible by 3")
}
# n is divisible by 2
# n is divisible by 3
```

</div>

<div>

**python**

```{python}
# Assigning a value to a variable
n = 12

# Using two if statements
if n % 2 == 0:
  print("n is divisible by 2")
if n % 3 == 0:
  print("n is divisible by 3")
# n is divisible by 2
# n is divisible by 3
```

</div>
:::

In R the modulo operator is `%%`, while Python
uses `%`. Both if statements are executed, as both conditions
are true. If we used an if - else if - else statement instead, only the
first condition would be executed, and the second condition would be
ignored.

### Nesting if-statements

Sometimes, we may want to check a condition within another condition,
and execute different blocks of code for each combination. For this, we
can use a nested if statement. A nested if statement is an if statement
inside another if statement. A nested if statement can have multiple
levels of nesting, and can also include else if and else blocks. For
example, we can use a nested if statement to print a message based on
the value and the sign of a variable, as shown below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Assigning a value to a variable
x <- -10

# Using a nested if statement
if (x > 0) {
  if (x > 10) {
    print("x is positive and greater than 10")
  } else {
    print("x is positive and less than or equal to 10")
  }
} else {
  if (x < -10) {
    print("x is negative and less than -10")
  } else {
    print("x is negative and greater than or equal to -10")
  }
}
```

</div>

<div>

**python**

```{python}
# Assigning a value to a variable
x = -10

# Using a nested if statement
if x > 0:
  if x > 10:
    print("x is positive and greater than 10")
  else:
    print("x is positive and less than or equal to 10")
else:
  if x < -10:
    print("x is negative and less than -10")
  else:
    print("x is negative and greater than or equal to -10")
```

</div>
:::

Concerning syntax, you can now see the double indentation in the python
code. The nested if statement checks the outer condition first (x being
positive), and then checks the inner condition if the outer condition is
true (x being greater then 10). Note also that the nested if statement
can have multiple levels of nesting, and can also include else if and
else blocks.

In the next section, we will introduce you to a fun and popular game
that involves logic and flow: FizzBuzz.

### FizzBuzz

FizzBuzz is a game that tests your ability to use logic and flow in
programming. The rules of the game are simple: given a number, print
"Fizz" if the number is divisible by 3, print "Buzz" if the number is
divisible by 5, print "FizzBuzz" if the number is divisible by both 3
and 5, and print the number itself otherwise. For example, given the
number 15, print "FizzBuzz", given the number 9, print "Fizz", given the
number 10, print "Buzz", and given the number 7, print 7.

To play FizzBuzz in R or Python, we can use a variable to store the
number, and then use an if - else if - else statement to check the
conditions and print the output, as shown below:


::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Assigning a value to a variable
n <- 15

# Playing FizzBuzz
if (n %% 3 == 0 & n %% 5 == 0) {
  print("FizzBuzz")
} else if (n %% 3 == 0) {
  print("Fizz")
} else if (n %% 5 == 0) {
  print("Buzz")
} else {
  print(n)
}
```

</div>

<div>

**python**

```{python}
# Assigning a value to a variable
n = 15

# Playing FizzBuzz
if n % 3 == 0 and n % 5 == 0:
  print("FizzBuzz")
elif n % 3 == 0:
  print("Fizz")
elif n % 5 == 0:
  print("Buzz")
else:
  print(n)
```

</div>
:::


The Fizzbuzz condition uses the modulo `%%` (`%` in Python) operator. This, recall,
returns the remainder of the division. The logical and operator
returns true if both operands are true. Note also that the order of the
conditions is important, as we need to check the divisibility by both 3
and 5 first, and then we check the divisibility by 3 or 5 separately.

To see how FizzBuzz works, try to replace the value of the
variable `n` with different numbers, and see what the output is. For
example, try `n <- 45` in R, or `n = 45` in Python, and see what
happens!

#### Exercise: Skibbidifizzbuzz

As an exercise, try to write a variation of FizzBuzz, called
Skibbidifizzbuzz, where the rules are the same as above, but now you
have to add "Skibbidi" if the number is divisible by 2. For example,
given the number 12, print "SkibbidiFizz", given the number 20, print
"SkibbidiBuzz", given the number 30, print "SkibbidiFizzBuzz", and given
the number 8, print "Skibbidi".


## Vectors

We now introduce the first (and the most fundamental!) data structures in programming: vectors. Vectors, as in maths, are ordered collections of values that can be manipulated as a single unit. All elements in a vector need to be homogeneous, e.g. of the same type, for example we cannot have a vector with a string and an integer together. Later on, when we will introduce matrices, we will find out that these are nothing but a collection of vectors (vectors of vectors).
And we, in maths, know how powerful linear algebra is: through vectors, we can store, process, and analyze large amounts of numerical data efficiently and elegantly.

### Creating vectors
We will now see how to create and use vectors in R and Python, and how to perform element wise operations on vectors.

To create a vector in R, we use the `c` function, which stands for concatenate. The `c` function takes one or more values as arguments, and returns a vector that contains those values. For example, we can create a vector that contains the numbers 1, 2, and 3, as shown below:

```{r}
# Creating a vector in R
x <- c(1, 2, 3)
x
```

To create a vector in Python, we use the `array` function from the `numpy` module, which stands for numerical Python. While technically the Python array is not the same of an R vector (as you can have arrays of arrays, which is a similar structure to a matrix), we will use the Python array interchangeably for now, as they behave very similar and they fulfill similar roles.
The first thing to use arrays in python, is to import the `numpy` array. The `numpy` module is a library that provides various tools and functions for working with numerical data and scientific computing. The `array` function takes a list as an argument, and returns an array that contains the elements of the list. A list, in Python, is another, built-in structure to represent and ordered set of data, but it comes from the original python, was designed with different aims, and comes with a lot less powers then the numpy `array`. So for now, please stick to the following when you create vectors in python.
We can create an array that contains the numbers 1, 2, and 3, as shown below:

```{python}
# Importing the numpy module
import numpy as np

# This is a simple python list
[1, 2, 3]

# Creating an array in Python
x = np.array([1, 2, 3])
x
```

We need to import the `numpy` library before using the `array` function, and we use the alias `np` to refer to the module. Therefore, before we proceed it is probably a good time to introduce what a library is. 

#### Libraries
A library is a collection of code that provides predefined functions, classes, variables, and other resources that can be used by other programs. Libraries can save time and effort by allowing programmers to reuse existing code and avoid writing everything from scratch. Libraries can also enhance the functionality and the performance of a programming language by offering specialized tools and features that are not built-in.

For example, the numpy library is a library that provides various tools and functions for working with numerical data and scientific computing. The numpy library is not part of the standard Python language, but it can be installed and imported by using the import statement. The import statement tells Python to load the library and make it available for use. The import statement can also assign an alias or a nickname to the library, such as np, to make it easier to refer to the library in the code.

Normally, one has to reference import numpy as np only at the beginning of the script, before using any of the functions or resources from the numpy library:

**python**

```{python}
# this is the math library from past week!
import math
# Importing the numpy library and assigning an alias
import numpy as np

#     rest of your script!    #
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~ # 
```
This way, Python knows where to find the functions that is needed, and the programmer does not have to repeat the import statement every time.

R has libraries too, those are imported via the command `library`, but we will see how to use these at a later time as R has already plenty of scientific computing functions and structures built in.

#### Creating sequences

One of the common ways to create vectors or arrays is to use sequences. Sequences are ordered collections of values that follow a certain pattern or rule. Sequences can be useful for generating data, plotting, or creating loops, as we will see later on.
As you will see, here the syntax is going to be a bit different in each language, as R uses functions such `:` or `seq` and Python uses `np.arange` or `np.linspace` to create and initialize vectors. We will see how to create sequences of integers, any sequence of equally spaced numbers, and finally, how to initialize an empty vectors with all same values. 

**To create a sequence of integers in R**, we can use the colon operator `:`, in Python, we can use the `arange` function from `numpy`. Both take two integers as arguments, and returns a vector or an array that contains all the integers from the first argument to the second argument, with a step size of 1. For example, we can create a sequence of integers from -5 to 10, as shown below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Creating a sequence of integers from -5 to 10
x <- -5:10
x
```

</div>

<div>

**python**

```{python}
# Creating a sequence of integers from -5 to 10
x = np.arange(-5, 11)
x
```


</div>
:::

Differently from R, `arange` requires the second argument to be one step more than the desired end point of the sequence, so if we want to go up to 10, we need to have the second argument to be 11.

**To create any sequence**, we can use the `seq` function in R, and the `arange` or `linspace` functions in Python. For example, we can create a sequence of numbers from 0 to 1, with a step size of 0.1, or with a length of 11, as shown below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

The `seq` function in R can take named arguments, such as `from`, `to`, `by`, or `length.out`, to specify the parameters of the sequence. 
```{r}
# Creating a sequence of numbers from 0 to 1, with a step size of 0.1
x <- seq(from = 0, to = 1, by = 0.1)
x

# Creating a sequence of numbers from 0 to 1, with a length of 11
y <- seq(from = 0, to = 1, length.out = 11)
y
```

</div>

<div>

**python**

The `np.arange` function in Python, with an additional argument, will indicate the step size. Again, in this case, arange requires the second argument to be one step more than the desired end point of the sequence. The `np.linspace` function, instead, will create a vector of a desired length (11 elements) of equally spaced elements. It requires the third argument to be the desired length of the sequence.
```{python}
# Creating a sequence of numbers from 0 to 1, with a step size of 0.1
x = np.arange(0, 1.1, 0.1)
x

# Creating a sequence of numbers from 0 to 1, with a length of 11
y = np.linspace(0, 1, 11)
y
```

</div>
:::

**Empty vectors.** Lastly, there might be some cases where we have to create an empty vector or array in R and Python. An empty vector or array can be useful for initializing a vector or array that will be filled with values later, as we will see in the next chapters. For this, we can use the `vector` or `array` function, respectively, and specify the type and the length of the vector or array. An empty vector or array is a vector or array that contains no values, but has a predefined type and length. For example, we can create an empty vector or array of type numeric and length 5, as shown below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Creating an empty vector of type numeric and length 5
x <- vector(mode = "numeric", length = 5)
x
```

</div>

<div>

**python**

```{python}
# Creating an empty array of type numeric and length 5
x = np.empty(5, dtype = "float")
x
```

</div>
:::

Note that the `vector` function in R takes the `mode` argument to specify the type of the vector, and the `length` argument to specify the length of the vector. The `np.empty` function in Python takes the the length of the array as the first argument, and the `dtype` argument to specify the type of the array, e.g. integer, float, Python object, etc.

### Modifying vectors

One of the main advantages of using vectors or arrays is that we can perform elementwise operations on them. Elementwise operations are operations that are applied to each element of the vector or the array individually, and return a new vector or array that contains the results. Elementwise operations preserve the shape and the length of the vector or the array, meaning that the resulting vector or array has the same number of elements as the original vector or array.

For example, we can add, subtract, multiply, or divide a vector or an array by a scalar (which is a single value):

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Adding a scalar to a vector
x + 1

# Subtracting a scalar from a vector
x - 1

# Multiplying a vector by a scalar
x * 2

# Dividing a vector by a scalar
x / 2
```

</div>

<div>

**python**

```{python}
# Adding a scalar to an array
x + 1

# Subtracting a scalar from an array
x - 1

# Multiplying an array by a scalar
x * 2

# Dividing an array by a scalar
x / 2
```

</div>
:::

The element wise operations are performed by using the same arithmetic operators as the past chapter, such as `+`, `-`, `*`, and `/`.

#### Functions and algebra with vectors

But we can do more! One of the benefits of using vectors or arrays is that we can apply a whole function, such as `sin(.)` or `log(.)`, on the entire vector elementwise. This means that the function is applied to each element of the vector individually, and returns a new vector that contains the results. For example, let's apply the `sin(.)` function, which calculates the sine of an angle in radians, on a vector that contains the angles $0$, $\pi/2$, $\pi$, and $3 \pi/2$:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Creating a vector of angles in radians
x <- c(0, pi/2, pi, 3*pi/2)
x

# Applying the sin function on the vector elementwise
sin(x)
```

</div>

<div>

**python**

```{python}
# Creating an array of angles in radians
x = np.array([0, np.pi/2, np.pi, 3*np.pi/2])
x

# Applying the sin function on the array elementwise
np.sin(x)
```

</div>
:::

The function is applied to each element of the vector or the array individually, and returns a new vector or array that contains the results. Note also that by default the results are in scientific notation.

We can also apply many other functions! Go back to last week introduction and see how many of the functions we introduced already, such as `log()`, run elementwise on vectors.

And as we can sum two scalars, another benefit of using vectors or arrays is that we can do elementwise product and sum of two vectors. If two vectors or arrays are the same length, this will return a new vector or array that contains the elementwise results of your desired operation:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Creating two vectors of the same length
x <- 1:4
y <- 5:8

# Doing elementwise product of two vectors
x * y

# Doing elementwise sum of two vectors
x + y
```

</div>

<div>

**python**

```{python}
# Creating two arrays of the same length
x = np.arange(1, 5)
y = np.arange(5, 9)

# Doing elementwise product of two arrays
x * y

# Doing elementwise sum of two arrays
x + y
```

</div>
:::

The elementwise product and sum are performed by using the same arithmetic operators as before, such as `*` and `+`. Note also that the elementwise product and sum preserve the shape and the length of the vectors or the arrays, meaning that the resulting vector or array has the same number of elements as the input vectors or arrays.

#### Doing the dot product of two vectors

Lastly, one important operation that we can do with vectors or arrays is the dot product, and this will be super useful to you in the future as you will deal with applications in linear algebra, geometry, and machine learning. Recall that the dot product takes two vectors or arrays of the same length, and returns a single number that is the sum of the elementwise products of the vectors or arrays. For example, the dot product of the vectors `[1, 2, 3, 4]` and `[5, 6, 7, 8]` is `1*5 + 2*6 + 3*7 + 4*8 = 70`.

To calculate the dot product of two vectors or arrays in R and Python, we use the following functions:

- In R, we use the `%*%` operator, which performs matrix multiplication. If the input vectors are one-dimensional, the matrix multiplication is equivalent to the dot product. For example, we can calculate the dot product of two vectors, as shown below:

```{r}
# Doing the dot product of two vectors
x %*% y
```

- In Python, we use the `dot` function from the `numpy` module, which performs the dot product of two arrays. For example, we can calculate the dot product of two arrays, as shown below:

```{python}
# Doing the dot product of two arrays
np.dot(x, y)
```

The syntax are quite different in both languages, as R uses a special operator and Python uses a function from `numpy`. Note also that the dot product requires the input vectors or arrays to have the same length, otherwise it will produce an error.

We will cover how to do algebra with Python and R in the next chapters. 

## Accessing vectors

We will see now how to access the elements of a vector. Accessing the elements of a vector or an array is important as it allows us to select, extract and even modify specific values or subsets of values from a vector.

### Checking the size and dimension of a vector

Before we access the elements of a vector or an array, it is useful to know the size and the dimension of the vector or the array. **The size** of a vector or an array is the number of elements that it contains. **The dimension**, on the other hand, is the number of axes or directions that it has. For example, a one-dimensional vector or array has only one axis or direction, and a two-dimensional vector or a matrix will have two axes or directions, such as rows and columns.

To check the size and the dimension of a vector or an array in R and Python, we can use the following functions:

In R, we can use the `length` function to get the size of a vector, and the `dim` function to get the dimension of a vector.

**R**

```{r}
# Creating a vector of numbers
x <- 1:4

# Checking the size of the vector
length(x)

# Checking the dimension of the vector
dim(x)
```

The `length` function returns the number of elements in the vector, which is 4, and the `dim` function returns `NULL`, which means that the vector has no dimension. This is because a vector in R is always one-dimensional, and the `dim` function is more useful for higher-dimensional objects, such as **matrices** or **data frames**. We will learn about these structures later on, so do not worry about it for now. 

In Python, we can use the `size` attribute or the `len` function to get the size of an array, and the `shape` attribute or the `ndim` attribute to get the dimension of an array.

**python**

```{python}

# Creating an array of numbers
x = np.arange(1, 4)

# Checking the size of the array
x.size
# 4
len(x)
# 4

# Checking the dimension of the array
x.shape
# (4,)
x.ndim
# 1
```

The `size` attribute and the `len` function both return the number of elements in the array, which is 4, and the `shape` attribute and the `ndim` attribute both return the dimension of the array, which is 1. The `shape` attribute returns a *tuple*, that contains the length of each axis of the array, and the `ndim` attribute returns an integer that represents the number of axes of the array. Note that a one-dimensional array in Python has a shape of `(n,)`, where `n` is the size of the array, and a comma is needed to indicate that it is a tuple. A *tuple* is another one dimentional structure in Python, but for now you can treat it as just a couple of numbers.

### Accessing Vector Elements

We can access the elements of the vector or the array by using indexing. Indexing is a way of referring to a specific element or a subset of elements of a vector or an array by using their position or location. Every element of a vector, in fact, has an index, that is a number that indicates its order in the vector.

Indexing the elements of a vector or an array in R and Python has **a fundamental difference** that you need to be extremely careful about. R uses what is called *one-based* indexing, while Python uses *zero-based* indexing. This means that R starts counting the elements of a vector or an array from 1, e.g. the first element starts at one, while Python starts counting the elements of a vector or an array from 0. This difference can cause confusion and errors if you are not aware of it, so you need to pay attention to the indexing system of each language:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# The index will be
    #  1  2  3  4
x <- c(1, 2, 3, 4)
```

</div>

<div>

**python**

```{python}
# The index will be:
           #  0  1  2  3
x = np.array([1, 2, 3, 4])
```

</div>
:::



Let's see how to practically access the single elements by using indexing.

- In R, the elements of a vector are indexed from 1 to the size of the vector, and we can use the square brackets `[ ]` to access them by using their index.

```{r}
# Accessing the first element of the vector
x[1]

# Accessing the last element of the vector
x[length(x)]

# Accessing any element of the vector
x[3]
```

The first element of the vector has an index of 1, the last element of the vector has an index of the size of the vector, which is 4. The square brackets `[ ]` are used to access the elements of the vector: therefore the index must be an integer between 1 and the size of the vector, otherwise it will produce an error or a missing value.

- In Python, the elements of an array are indexed from 0 to the size of the array minus 1, and we can use the square brackets `[ ]` to access them by using their index.

```{python}
# Accessing the first element of the array
x[0]

# Accessing the last element of the array
x[len(x) - 1]

# Accessing any element of the array
x[2]
```

In Python, the first element of the array has an index of 0, the last element of the array has an index of the size of the array minus 1, which in our case is 3. The square brackets `[ ]` are used to access the elements of the array by using their index, and that the index must be an integer between 0 and the size of the array minus 1, otherwise it will produce an error or an out of bounds exception. 
Differently from R, in Python, however we can access the arrays from the back, using negative integers. Try:
```{python}
# Accessing the last element of the array
x[-1]

# Accessing the second last element of the array
x[-2]

# Accessing the first element of the array
x[-len(x)]
```

#### Accessing multiple elements at once

In addition to accessing a single element of a vector or an array, we can also access multiple elements at once by using indexing. This can be useful for selecting, modifying, or extracting specific values or subsets of values from a vector or an array. There are different ways to access multiple elements at once, depending on the criteria or the pattern that we want to use.

- To access any sequence of elements of a vector or an array, we can use sequences of integers as indices. This means we can use the colon operator `:` to create sequences of integers in R and Python, as we saw in the previous section, and use these to access and splice the first three elements, the last three elements, or even the *even-indexed* elements of a vector or an array (pun not intended).

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Creating a vector of the first 6 integers
x <- 1:6

# Accessing the first three elements of the vector
x[1:3]

# Accessing the last three elements of the vector
# index is 4, 5, 6
x[(length(x) - 2):length(x)]

# Accessing the even-indexed elements of the vector
x[seq(from = 2, to = length(x), by = 2)]
```

</div>

<div>

**python**

```{python}
# Creating an array of the first 6 integers
x = np.arange(1, 7)

# Accessing the first three elements of the array
x[0:3]

# Accessing the last three elements of the array
# index is 3, 4, 5
x[(len(x) - 3):len(x)]

# Accessing the even-indexed elements of the array
x[np.arange(1, len(x), 2)]
```

</div>
:::

Recall that R uses one-based indexing and Python uses zero-based indexing. The sequences of integers for accesing the indeces are created by using the colon operator `:` or the `seq` function in R, and the `np.arange` function in Python. The sequences of integers can have different start, end, or step values, depending on the desired subset of elements. Try to experiment a bit with the start and end values of the subsets introduced above! 

- Similarly, we can use vectors or arrays of integers as indices to access multiple elements *at every location*. To do so, we will first create some vectors, and then use those vectors to access the elements of other vectors respectively. For example, we can access three elements at random of a vector or an array, as shown below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Accessing element 2, 5 and 6 of the vector
x[c(2, 5, 6)]

# note how in this way we can shuffle order!
x[c(2, 6, 5)]
```

</div>

<div>

**python**

```{python}
# Accessing element 2, 5 and 6 of the vector
x[[1, 4, 5]]

# note how in this way we can shuffle order!
x[[1, 5, 4]]
```

</div>
:::


To access multiple elements at random of a vector or an array, we can also use vectors or arrays of booleans as indices. Vectors or arrays of booleans are collections of logical values, as introduced above, e.g. either `TRUE` or `FALSE`. In this case, it is important that the vectors or arrays of booleans have the same length as the vector or the array, and that only the elements that correspond to `TRUE` (in R) or `True` (in Python) values are selected.

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# boolean index vector:
#                    2                   5     6
index <- c(FALSE, TRUE, FALSE, FALSE, TRUE, TRUE)

# Accessing element 2, 5 and 6 of the vector
x[index]
```

</div>

<div>

**python**

```{python}
# boolean index vector:
#                   1                   4     5
index = [False, True, False, False, True, True]

# Accessing element 2, 5 and 6 of the vector
x[index]
```

</div>
:::

Why is this useful? Well, with this trick, we can use logical operators obtained by logical arithmetic to create vectors or arrays of booleans in R and Python. For example, we can access the elements that are greater than 3 of a vector or an array, as shown below:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Creating a vector of numbers
x <- c(1, 2, 3, 4, 5, 6)

# Accessing the elements that are greater than 3 of the vector
x[x > 3]

# Accessing even elements 
x[x %% 2 == 0]
```

</div>

<div>

**python**

```{python}
# Creating an array of numbers
x = np.array([1, 2, 3, 4, 5, 6])

# Accessing the elements that are greater than 3 of the array
x[x > 3]

# Accessing even elements 
x[x % 2 == 0]
```

</div>
:::

#### Overwriting elements of vectors

Finally, as we can overwrite variables, we can overwrite single (or multiple!) elements of a vector without modifying the entire vector. This is essentially achieved by selecting the elements of interest, and then assigning new elements to those. The replacement, of course needs to be of the same length of the elements we wish to replace. If the new values are not compatible with the type and the length of the vector, both languages will produce an error or a warning.

In R, we can use the square brackets `[ ]` to access the elements of the vector by using their index, and the left arrow `<-` to assign new values to them. For example, to overwrite the first element, the last element, and the third element:

**R**

```{r}
# Creating a vector of numbers
x <- c(1, 2, 3, 4)

# Overwriting the first element of the vector
x[1] <- 10
x

# Overwriting the last element of the vector
x[length(x)] <- 20
x

# Overwriting any element of the vector
x[3] <- 30
x
```

In Python, we can use the square brackets `[ ]` to access the elements of the array by using their index, and the equal sign `=` to assign new values to them. For example, to overwrite the first element, the last element, and third element:

**python**

```{python}
# Creating an array of numbers
x = np.array([1, 2, 3, 4])

# Overwriting the first element of the array
x[0] = 10
x

# Overwriting the last element of the array
x[len(x) - 1] = 20
x

# Overwriting any element of the array
x[2] = 30
x
```

In this code, the square brackets `[ ]` are used to access the elements of the array by using their index, and the equal sign `=` is used to assign new values to them

Note that the final vector has the three elements we accessed all changed. 
As mentioned, we can select and replace multiple elements simultaneously in a single command, look for instance at the code below. 

#### Exercise: vector fizzbuzz
You are ready to see your first complex program. Can you tell what it does?
Break down, comment and describe the following code, and adapt it do perform Skibbidifizzbuzz.

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
x <- 1:100

fizz_index <- x %% 3 == 0
buzz_index <- x %% 5 == 0

x[fizz_index] <- "fizz"
x[buzz_index] <- "buzz"
x[fizz_index & buzz_index] <- "fizzbuzz"
x
```

</div>

<div>

**python**

```{python}
x = np.arange(1, 101, dtype=object)

fizz_index = x % 3 == 0
buzz_index = x % 5 == 0


x[fizz_index] = "fizz"
x[buzz_index] = "buzz"
x[np.logical_and(fizz_index, buzz_index)] = "fizzbuzz"
x
```

</div>
:::

Small hint: You should be careful about the type of output vector in R. You'll notice now it's a character vector. 
Python does not convert the type of vector automatically, the dtype argument is needed to ensure the vector can contain both integers and strings. Remove the dtype argument from the first line and see what happens.

```{=html}
<style type="text/css">
.book .book-body .page-wrapper .page-inner {
  max-width: 1200px !important;
}
</style>
```

<!--chapter:end:02-week2.Rmd-->

---
editor_options: 
  markdown: 
    wrap: 72
---

# Functions and Loops {#func_loop}

## Functions

Functions in mathematics, is an assignment of an element from a set to a
different set. Here we give a more "practical" definition.

In the realm of programming, a function is a reusable piece of code that
performs a specific task. Think of it as a mini-program within your
program, a tool you create to do a job so you don't have to. And as a
program does, you give it an input, it will do some voudou magic, and it
will spit an output.

![](images/chapter3/dark_magic.png)

What's the point of a function you might ask? Well, in programming, we
use functions when we have tasks that must be performed again and again.
When we notice a repetitive task occurring, it is a good idea to write a
function that performs this task. If you find yourself copying and
pasting the same piece of code more than three times, it's time to stop
and think: "Should I write a function for this?" Remember, in the world
of coding, being lazy is often a good thing! We aim for efficiency, not
repetitive strain injury.

![](images/chapter3/homer.jpg){width="366"}

Imagine if every time you need to compute the square root, you need to
write the code to compute the square root over and over again. Well, but in practice, you don't have to!
There's *a function* that does the job for you already: `sqrt`
In fact, it won't come as a surprise that we've already encountered many
functions in the past weeks. For instance:

-   Mathematical functions like `sqrt()` or `sin()` in R, and
    `math.sqrt()` or `math.sin()` in Python.
-   Functions like `np.array()` or `c()` to create vectors.
-   Functions like `length()` in R or `len()` in Python to get
    information about our data structures.

Again, each function I mentioned, has an input, and an output: `sqrt`
takes a number as input and returns the square root of such number,
`length` or `len` take a whole vector as input, and return the length of
it...

Another incredibly useful function is the `help()` function, available
in both R and Python. This function takes a **function** as an input,
and provides us with information said function as output! For example:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r eval=FALSE}
help(sqrt)
```

</div>

<div>

**python**

```{python eval=FALSE}
help(math.sqrt)
```

</div>
:::

Whenever you will meet a **built-in** function, or a function from a **documented external library** you can call the help on the function to have an explanation about it! Documentation is a requirement in R libraries, so pretty much all the functions you will meet are documented! Unfortunately this is not the case for Python, where documenting functions is not a requirement, so not always the `help` will return something. 

### Writing new functions

The real power of functions comes when we start creating our own. We
can write new functions that perform specific tasks, tailored to our
needs. This allows us to do more complex, interesting, and fun things
with our code. So let's dive in and learn how to create our own
functions!
We can wrap our code in a function, and every time the function is called, this code is run. This is incredibly useful for tasks we need to perform multiple times. Let’s build for example a simple function that converts pounds (lbs) to grams (g).

Mathematically, this is simply done by the formula:
$$
g = 453.5924 * lbs
$$

In **R**, we define a function using the `function()` command. The arguments of the function are placed within the parentheses. Here's how we can create a function in R:

```{r}
lbs_to_grams <- function(lbs) {
  grams <- 453.5924 * lbs
  return(grams)
}
```

In this function, `lbs` is the input (or argument), and the function returns the equivalent weight in grams. In R, we create a new function with the `function` statement, and then we assign it to a variable, which is going to be containing our function. The `return()` statement is used to specify the result that the function should output.

In **Python**, we define a function using the `def` keyword. The arguments of the function are placed within the parentheses. Again we need to use indentation: this is crucial in Python as it determines the code blocks. Here's how we can create a function in Python:

```{python}
def lbs_to_grams(lbs):
  grams = 453.5924 * lbs
  return grams
```

In this function, `lbs` is the input (or argument), and the function returns the equivalent weight in grams: following the `def` keyword we need both the function name, followed by the argument. The `return` statement is used to specify the result that the function should output.


Now, once we have made the new function, we can call it with:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
lbs_to_grams(lbs=2)
lbs_to_grams(lbs=3)

# when calling we can also omit 
# the argument name for brevity
lbs_to_grams(3)
```

</div>

<div>

**python**

```{python}
lbs_to_grams(lbs=2)
lbs_to_grams(lbs=3)

# when calling we can also omit 
# the argument name for brevity
lbs_to_grams(3)
```

</div>
:::

By creating functions like these, we can make our code more efficient and easier to read. Plus, it saves us from having to remember the conversion rate each time we want to convert pounds to grams!

The name of the function `lbs_to_grams` and its argument `lbs` are just names that I chose.
There are a few guidelines that could be useful when naming functions:
-   Names should be lowercase.
-   Use an underscore, _, to separate words within a name.
-   Strive for names that are concise and meaningful (this is not easy!).
-   Avoid existing function names in R and python, such as `length()` or `len()`.

Also, you might have noticed we made a variable within the function code, `grams`. But what does it mean to have variables within functions? The variables used inside a function are local to that function. Think of your function as a guarded sandbox, where no child leaves unless you specifically tell them to. This sandbox is called and *enviroment*. Let's cover this concept formally!

#### Enviroments 
In programming, an environment refers to a structure that holds variables. When you create a variable in a program, the environment is where this variable lives. The environment keeps track of the variable's name and its current value.

There are two types of environments: global and local.

- The **global environment** is the default environment where your variables live unless you specify otherwise. When you create a variable at the top level of your script, it's stored in the global environment.

- A **local environment** is created when you call a function. Each time a function is called, a new local environment is created for that function call. This environment holds the variables that are created within the function. These variables are only accessible within the function call and cease to exist once the function call is over.

Let's consider the `lbs_to_grams` function we made:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r error=TRUE}
lbs_to_grams <- function(lbs) {
  grams = 453.5924 * lbs
  return(grams)
}

# Create a variable in the global environment
glo_grams <- 2

# Try to access the local variable "grams"
print(grams)
# Try to access the global variable "glo_grams"
print(glo_grams)
```

</div>

<div>

**python**

```{python error=TRUE}
def lbs_to_grams(lbs):
  grams = 453.5924 * lbs
  return grams

# Create a variable in the global environment
glo_grams = 2

# Try to access the local variable "grams"
print(grams)
# Try to access the global variable "glo_grams"
print(glo_grams)
```

</div>
:::

In these functions, `lbs` and `grams` are variables in the local environment of the function. They are created when the function is called and cease to exist when the function call is over. If you try to access `grams` outside of the function, you'll get an error because `grams` is not in the global environment.

On the other hand, `glo_grams` is in the global environment because it's created at the top level of the script, not within a function. You can access `glo_grams` anywhere in your script **even within a function**.

This distinction between global and local variables helps keep our code clean and reduces the chance of errors. It ensures that the function does its job without interfering with the rest of our script! However, it can be prone to errors too. Say for instance, I make a typo in the argument name of my function above, and, for whatever reason I created a lbs variable in the global... Like for instance:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r error=TRUE}
# I specified in the global lbs at some point 
lbs <- 3

# and here I made a typo!
#                            V
bug_lbs_to_grams <- function(lb) {
  grams = 453.5924 * lbs
  return(grams)
}

# Then, no matter what I call, I will always get the same result! 
# e.g.: 453.5924 * 3 
bug_lbs_to_grams(2)
bug_lbs_to_grams(10)
bug_lbs_to_grams(42)
```

</div>

<div>

**python**

```{python error=TRUE}
# I specified in the global lbs at some point 
lbs = 3

# and here I made a typo!
#                     V
def bug_lbs_to_grams(lb):
  grams = 453.5924 * lbs
  return grams

# Then, no matter what I call, I will always get the same result! 
# e.g.: 453.5924 * 3 
bug_lbs_to_grams(2)
bug_lbs_to_grams(10)
bug_lbs_to_grams(42)
```

</div>
:::

What happened above, is that I pass down as an input the `lb` argument (without the s) *but this is nowhere used in the function* as inside the code, at `grams = 453.5924 * lbs` I call the `lbs`. Now since the compiler can't find any `lbs` within the local enviroment, it will just assume that this is the `lbs` I specified in the global. 
Hence, no matter what I feed to the function, it will return the evaluation with the global `lbs`.
**For this reason try not to name the variables inside your functions as those outside it, in the rest of your script**. What happens if I do name a local variable and global variable in the same way? Well, in this case, the function will use the local `lbs` variable, and the global will use the global `lbs` variable **but this is still risky and prone to bugs**.

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r error=TRUE}
# global lbs
lbs <- 3

# but this does not affect the "lbs" of the function argument
lbs_to_grams(2)
lbs_to_grams(10)
lbs_to_grams(42)
```

</div>

<div>

**python**

```{python error=TRUE}
# global lbs 
lbs = 3

# but this does not affect the "lbs" of the function argument
lbs_to_grams(2)
lbs_to_grams(10)
lbs_to_grams(42)
```

</div>
:::

#### Multiple arguments

Say we want now to convert pounds to milliliters. To convert from mass to volume, we will need an additional information, the specific mass. In physics, the specific mass (also known as the volumetric mass density) of a substance is the mass per unit volume. 

Fortunately for us, functions can take multiple arguments, allowing us to give more elements to the local environment of the function. This means we can customize the function's behavior based on these inputs. Let's see how we can add more arguments to a function.

We'll create a new function to convert pounds to milliliters. This function will take a second argument: `specific_mass`. We'll use the function **we created earlier** to convert pounds to grams, and then, using the `specific_mass`, we'll convert grams to liters.

Here's how we can do this in both R and Python:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
lbs_to_ml <- function(lbs, specific_mass) {
  grams <- lbs_to_grams(lbs)
  ml <- grams / specific_mass
  return(ml)
}

# Specific mass of water and oil
water_mass = 1
oil_mass = 0.92

# Convert 2 lbs of water and oil to ml
lbs_to_ml(2, water_mass)
lbs_to_ml(2, oil_mass)
```

</div>

<div>

**python**

```{python}
def lbs_to_ml(lbs, specific_mass):
  grams = lbs_to_grams(lbs)
  ml = grams / specific_mass
  return ml

# Specific mass of water and oil
water_mass = 1
oil_mass = 0.92

# Convert 2 lbs of water and oil to ml
lbs_to_ml(2, water_mass)
lbs_to_ml(2, oil_mass)
```

</div>
:::

To run the functions we just made: 

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
# Specific mass of water and oil
water_mass = 1
oil_mass = 0.92

# Convert 2 lbs of water and oil to ml
lbs_to_ml(2, specific_mass=water_mass)
lbs_to_ml(2, specific_mass=oil_mass)
```

</div>

<div>

**python**

```{python}
# Specific mass of water and oil
water_mass = 1
oil_mass = 0.92

# Convert 2 lbs of water and oil to ml
lbs_to_ml(2, specific_mass=water_mass)
lbs_to_ml(2, specific_mass=oil_mass)
```

</div>
:::

Let's say that 90% of the time when we are doing these calculations, they are relative to using water. Then, to be more efficient, rather than continuously having to give the mass of water, we could set the arguments to have these as default values. 

This is where default arguments in functions come into play. They are incredibly useful for several reasons:

- They allow us to make certain parameters optional, which can make the function easier to use.
- They can provide sensible defaults for a function, allowing it to be used without requiring the user to specify every single parameter.
- They can make the code more readable by clearly stating what the default behavior of the function is.

Here's how we can do this in both R and Python:

::: {style="display: grid; grid-template-columns: 1fr 1fr; grid-column-gap: 10px;"}
<div>

**R**

```{r}
cups_to_ml <- function(cups, specific_weight = 1) {
  grams <- cups_to_grams(cups)
  ml <- grams / specific_weight
  return(ml)
}

# Convert 2 cups of water to ml (default behavior)
cups_to_ml(2)

# Convert 2 cups of oil to ml (specific behavior)
cups_to_ml(2, 0.92)
```

</div>

<div>

**python**

```{python}
def cups_to_ml(cups, specific_weight=1):
  grams = cups_to_grams(cups)
  ml = grams / specific_weight
  return ml

# Convert 2 cups of water to ml (default behavior)
cups_to_ml(2)

# Convert 2 cups of oil to ml (specific behavior)
cups_to_ml(2, 0.92)
```

</div>
:::

As you can see, default arguments make our function more flexible and easier to use. They allow the function to handle a wider range of scenarios while keeping the code clean and readable.
```{=html}
<style type="text/css">
.book .book-body .page-wrapper .page-inner {
  max-width: 1200px !important;
}
</style>
```

<!--chapter:end:03-week3.Rmd-->

